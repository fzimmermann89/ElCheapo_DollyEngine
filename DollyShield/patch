diff --git a/BareMinimum.cpp b/BareMinimum.cpp
deleted file mode 100644
index 1214b10..0000000
--- a/BareMinimum.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-#line 1 "BareMinimum.ino"
-#include <avr/io.h>
-#include <avr/interrupt.h>
-
-#include "Arduino.h"
-void setup();
-void loop();
-void test();
-void writemotor(uint8_t value);
-void writedisplay(uint8_t value);
-#line 4
-uint16_t volatile timeoutms;
-
-void (*timeoutfunc)();
-
-void settimeout(uint16_t ms,void (*f)()){
-  timeoutms=ms;
-  timeoutfunc=f;
-}
-
-void setup() {
-  Serial.begin(115200);
-  // PWM Port einstellen
-
-  DDRD = 0xFF;         // Port als Ausgang
-  // zus\u00e4tzliche PWM-Ports hier setzen
-  
-  // Timer 2 vorbereiten
-  cli();
-  TCCR2A = 0x00;        //Timer2 Control Reg A: Wave Gen Mode normal
-  TCCR2B = 4;             // Timer l\u00e4uft mit Prescaler 64
-  TIMSK2 |= (1<<OCIE2A);   // Interrupts freischalten
-  TIMSK2 |= (1<<OCIE2B);  
-  TIMSK2 |= (1<<TOIE2);   
-                   // Interrupts global einschalten
-
-writedisplay(128);
-writemotor(128);
-sei(); 
-settimeout(200,test);
-PORTD|=_BV(4);
-}
-
-void loop() {
-  if (Serial.available()) {
-   int mode = Serial.parseInt();
-    Serial.print("prescaler:");
-    Serial.println(mode);
-    TCCR2B=mode;
-    int value = Serial.parseInt();
-    Serial.print("value:");
-    Serial.println(value);
-    writemotor(value);
-  }
-}
-void test(){
-  Serial.println("test");
-  delay(50);
-  timeoutms=200;
-}
-
-
-
-void writemotor(uint8_t value){
-  OCR2A=value;
-}
-
-void writedisplay(uint8_t value){
-  OCR2B=value;
-}
-
-ISR(TIMER2_COMPA_vect) {
-  //motor off
-  PORTD &= ~_BV(2);   
-}
-
-ISR(TIMER2_COMPB_vect) {
-  //display off
-  PORTD &= ~_BV(3);
-}
-
-ISR(TIMER2_OVF_vect){
-    
-  if (timeoutms==0){
-     PORTD&= ~_BV(4);
-  (*timeoutfunc)();
-  }
-  else timeoutms--;
-  if (OCR2A>0) PORTD|=_BV(2); //motor on
-  if (OCR2B>0)PORTD|=_BV(3); //display on
-
-}
-
-
diff --git a/DollyShield/DollyShield.ino b/DollyShield/DollyShield.ino
index 6edeb66..fd669b6 100644
--- a/DollyShield/DollyShield.ino
+++ b/DollyShield/DollyShield.ino
@@ -1,628 +1,587 @@
 /* 
- 
- El Cheapo Dollyshield
- modified Version of Dynamic Perception LLC's DollyShield
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
-
-/*
-NOTES:
- -use timer2 for lcd and motor "soft pwm" to use any pin. in slow pulse mode use counter in isr. less overhead than timer1
- -user timer1 in ctc mode with couter for general purpose ms-timer, instead of mstimer2 OR as compare..
 
- -check bulb mode/stop camera using ir
- 
- timer1 thoughts:
- 16bit timer, dh bis 65535.
- bei 16mhz:
- prescaler    zeit pro tick   max zeit    ticks pro ms
- 1        0,0625us      4ms       16000
- 8        0,5us       32ms      2000
- 64       4us         262ms     250
- 256      16us        1s        62.5  ~63   wert=wert<<6-wert
- 1024     64us        4s        15.625  ~16   wert=wert<<4
- 
+   MX2 Dolly Engine version
+   
+   (c) 2010-2011 C.A. Church / Dynamic Perception LLC
+   
+   Sketch to run the "DollyShield" design, provides control of
+   the arduino shield.  A dual 1Amp motor control 
+   shield with integrated LCD, 5 buttons, two generic I/O ports,
+   and dual opto-coupled input for camera control.  
  
- */
-
-#define EEPROM_TODO 123
-
-
+   This sketch creates a user interface and implements core features
+   of the shield, allowing for integrated control of one camera and 
+   up to two axes of motion.  Features allow for all of the following
+   motion types: shoot-move-shoot, continuous, and slow "pulsing" of 
+   the full speed motor to allow for very slow speeds without more
+   expensive steppers or even encoders.  
+   
+   For more info go to http://openmoco.org
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+    
+*/
 
 
 #include <avr/pgmspace.h>
 #include <EEPROM.h>
 #include <LiquidCrystal.h>
-#include "digitalWriteFast.h"
-//#include "MsTimer2.h"
-//#include "TimerOne.h"
-
+#include "MsTimer2.h"
+#include "TimerOne.h"
+#include "merlin_mount.h"
 
 
 #define FIRMWARE_VERSION  92
 
-// motor PWM
-#define MOTOR0_P 3
-#define MOTOR0_DIR 13
-
-// camera pins
-#define CAMERA_PIN 12
-#define FOCUS_PIN 15
-#define IR_PIN 12
+  // motor PWM
+#define MOTOR0_P 5
+#define MOTOR1_P 6
+#define MOTOR0_DIR 15
+#define MOTOR1_DIR 16
 
-//IR Settings
-#define FREQ 38400
-#define oscd 16 //TODO
+ // camera pins
+#define CAMERA_PIN 13
+#define FOCUS_PIN 12
 
-//IR sequences
+#define MAX_MOTORS 2
 
-  //NIKON
-unsigned int seq_nikon[]={14,77,1069,15,61,16,137,15,2427,77,1069,15,61,16,10};
-    //CANON
-unsigned int seq_canon[]={3,16,458,16};
+//#define MP_PERIOD 30
+#define MP_PERIOD 30
 
-unsigned int *seqs[] = {seq_nikon,seq_canon};
-#define IR_NIKON 0
-#define IR_CANON 1
 
 /* User Interface Values */
 
-// lcd pins
-#define LCD_RS  8
-#define LCD_EN  9
-#define LCD_D4  4
-#define LCD_D5  5
-#define LCD_D6  6
-#define LCD_D7  7
+  // lcd pins
+#define LCD_RS  17
+#define LCD_EN  18
+#define LCD_D4  11
+#define LCD_D5  8
+#define LCD_D6  7
+#define LCD_D7  4
 
-// which input is our button
-#define BUT_PIN A0
+ // which input is our button
+#define BUT_PIN 14
 
-// lcd backlight pin
-#define LCD_BKL 10
+  // lcd backlight pin
+#define LCD_BKL 9
 
-// max # of LCD characters (including newline)
+  // max # of LCD characters (including newline)
 #define MAX_LCD_STR 17
 
 
-// how many buttons dow we have?
+
+ // how many buttons dow we have?
 #define NUM_BUTTONS 5
 
-// button return values
+ // button return values
+
 #define BUT0  1
 #define BUT1  2
 #define BUT2  3
 #define BUT3  4
 #define BUT4  5
 
-// which buttons?
-#define BUT_UP BUT1
-#define BUT_DN BUT2
-#define BUT_CT BUT4
-#define BUT_LT BUT3
-#define BUT_RT BUT0
-
-// analog button read values
-#define BUT0_VAL  0
-#define BUT1_VAL  100
-#define BUT2_VAL  255
-#define BUT3_VAL  405
-#define BUT4_VAL  640
+  // which buttons?
+#define BUT_UP BUT4
+#define BUT_DN BUT3
+#define BUT_CT BUT0
+#define BUT_LT BUT2
+#define BUT_RT BUT1
 
-// button variance range
-#define BUT_THRESH  40
+  // analog button read values
+#define BUT0_VAL  70
+#define BUT1_VAL  250
+#define BUT2_VAL  450
+#define BUT3_VAL  655
+//#define BUT3_VAL 540
+#define BUT4_VAL  830
 
+  // button variance range
+#define BUT_THRESH  60
 
-// how many ms does a button have
-// to be held before triggering another
-// action? (for scrolling, etc.)
 
+ // how many ms does a button have
+ // to be held before triggering another
+ // action? (for scrolling, etc.)
+ 
 #define HOLD_BUT_MS 200
 
-// how much to increment for each cycle the button is held?
-
+ // how much to increment for each cycle the button is held?
+ 
 #define HOLD_BUT_VALINC 10
 
-// ALT input debouncing time
+ // ALT input debouncing time
+ 
 #define ALT_TRIG_THRESH 250
 
 
-// menu strings
-const char menu_0[] PROGMEM = "Movements";
-const char menu_1[] PROGMEM = "Motor  Setup";
-const char menu_2[] PROGMEM = "Camera Setup";
-const char menu_3[] PROGMEM = "General Setup";
-
-const char manual_menu_0[] PROGMEM = "Manual Move";
-const char manual_menu_1[] PROGMEM = "Fast Simulat.";
-
-const char axis_menu_0[] PROGMEM = "Movement Mode";
-const char axis_menu_1[] PROGMEM = "Ramp In Shots";
-const char axis_menu_2[] PROGMEM = "Ramp Out Shots";
-const char axis_menu_3[] PROGMEM = "Angle";
-const char axis_menu_4[] PROGMEM = "Lead In";
-const char axis_menu_5[] PROGMEM = "Lead Out";
-const char axis_menu_6[] PROGMEM = "Advanced";
-
-const char axis_adv_menu_0[] PROGMEM = "Calibrate";
-const char axis_adv_menu_1[] PROGMEM = "max RPM";
-const char axis_adv_menu_2[] PROGMEM = "Dist per Rev";
-const char axis_adv_menu_3[] PROGMEM = "Min Cont. Speed";
-const char axis_adv_menu_4[] PROGMEM = "Pulse Power";
-const char axis_adv_menu_5[] PROGMEM = "Cal. Spd Low";
-const char axis_adv_menu_6[] PROGMEM = "Cal. Spd Hi";
-
-const char camera_menu_0[] PROGMEM = "Interval sec";
-const char camera_menu_1[] PROGMEM = "Max Shots";
-const char camera_menu_2[] PROGMEM = "Exp. Time ms";
-const char camera_menu_3[] PROGMEM = "Shutter Type";
-const char camera_menu_4[] PROGMEM = "Bulb Mode";
-const char camera_menu_5[] PROGMEM = "Repeat";
-const char camera_menu_6[] PROGMEM = "Repeat Delay ms";
-const char camera_menu_7[] PROGMEM = "PreExp Delay ms";
-const char camera_menu_8[] PROGMEM = "PstExp Delay ms";
-const char camera_menu_9[] PROGMEM = "Focus Delay ms";
-
-
-const char set_menu_0[] PROGMEM = "Backlight";
-const char set_menu_1[] PROGMEM = "AutoDim (sec)";
-const char set_menu_2[] PROGMEM = "Blank LCD";
-const char set_menu_3[] PROGMEM = "I/O 1";
-const char set_menu_4[] PROGMEM = "I/O 2";
-const char set_menu_5[] PROGMEM = "In Delay ms";
-const char set_menu_6[] PROGMEM = "Out Delay ms";
-const char set_menu_7[] PROGMEM = "USB Trigger";
-const char set_menu_8[] PROGMEM = "Invert Dir";
-const char set_menu_9[] PROGMEM = "Invert I/O";
-const char set_menu_10[] PROGMEM = "Reset Mem";
-
-// menu organization
-
-const char * const menu_str[] PROGMEM = { 
-  menu_0,menu_1, menu_2, menu_3};
-
-const char * const man_str[] PROGMEM = { 
-  manual_menu_0,  manual_menu_1 };
-
-const char * const axis0_str[] PROGMEM = { 
-  axis_menu_0,axis_menu_1, axis_menu_2, axis_menu_3, axis_menu_4, axis_menu_5};
-
-const char * const cam_str[] PROGMEM = { 
-  camera_menu_0, camera_menu_1, camera_menu_2, camera_menu_3, camera_menu_4, camera_menu_5, camera_menu_6, camera_menu_7, camera_menu_8,camera_menu_9 };
-
-const char * const set_str[] PROGMEM = { 
-  set_menu_0, set_menu_1, set_menu_2, set_menu_3, set_menu_4, set_menu_5, set_menu_6,set_menu_7, set_menu_8, set_menu_9, set_menu_10};
-
-const char * const axis_adv_str[] PROGMEM = { 
-  axis_adv_menu_0, axis_adv_menu_1,  axis_adv_menu_2,axis_adv_menu_3,axis_adv_menu_4,axis_adv_menu_5,axis_adv_menu_6};
-
-// max number of inputs for each menu (in order listed above, starting w/ 0)
-byte max_menu[7]  = {
-  3,1,6,9,10,6};
-
-// support a history of menus visited up to 5 levels deep
-byte hist_menu[5] = {
-  0,0,0,0,0};
-
-
-//Special Return Codes used / Magic Values
-#define MENU_MANUAL 254
-#define MENU_CALIBRATION 253
-#define MENU_INPUT 255
+  // menu strings
+prog_char menu_1[] PROGMEM = "Manual Move";
+prog_char menu_2[] PROGMEM = "Axis 1";
+prog_char menu_3[] PROGMEM = "Axis 2";
+prog_char menu_4[] PROGMEM = "Camera";
+prog_char menu_5[] PROGMEM = "Settings";
+prog_char menu_6[] PROGMEM = "Scope";
+
+prog_char manual_menu_1[] PROGMEM = "Axis 1";
+prog_char manual_menu_2[] PROGMEM = "Axis 2";
+prog_char manual_menu_3[] PROGMEM = "Scope";
+
+prog_char axis_menu_1[] PROGMEM = "Ramp Shots";
+prog_char axis_menu_2[] PROGMEM = "RPM";
+prog_char axis_menu_4[] PROGMEM = "Angle";
+prog_char axis_menu_5[] PROGMEM = "Calibrate";
+prog_char axis_menu_6[] PROGMEM = "Slow Mode IPM";
+prog_char axis_menu_7[] PROGMEM = "Dist. per Rev";
+prog_char axis_menu_8[] PROGMEM = "Min Pulse";
+prog_char axis_menu_10[] PROGMEM = "Lead In";
+prog_char axis_menu_11[] PROGMEM = "Lead Out";
+prog_char axis_menu_12[] PROGMEM = "Cal. Constant";
+
+
+prog_char camera_menu_1[] PROGMEM = "Interval sec";
+prog_char camera_menu_2[] PROGMEM = "Max Shots";
+prog_char camera_menu_3[] PROGMEM = "Exp. Time ms";
+prog_char camera_menu_4[] PROGMEM = "Exp. Delay ms";
+prog_char camera_menu_5[] PROGMEM = "Focus Tap ms";
+prog_char camera_menu_6[] PROGMEM = "Shutter+Focus";
+prog_char camera_menu_7[] PROGMEM = "Repeat";
+prog_char camera_menu_8[] PROGMEM = "Repeat Delay";
+
+prog_char set_menu_1[] PROGMEM = "Motor Disp";
+prog_char set_menu_2[] PROGMEM = "Motor Sl.Mod";
+prog_char set_menu_3[] PROGMEM = "Backlight";
+prog_char set_menu_4[] PROGMEM = "AutoDim (sec)";
+prog_char set_menu_5[] PROGMEM = "Blank LCD";
+prog_char set_menu_6[] PROGMEM = "I/O 1";
+prog_char set_menu_7[] PROGMEM = "I/O 2";
+prog_char set_menu_8[] PROGMEM = "Metric Disp.";
+prog_char set_menu_9[] PROGMEM = "Reset Mem";
+prog_char set_menu_10[] PROGMEM = "Scope";
+prog_char set_menu_11[] PROGMEM = "Cal. Spd Low";
+prog_char set_menu_12[] PROGMEM = "Cal. Spd Hi";
+prog_char set_menu_13[] PROGMEM = "AltOut Pre ms";
+prog_char set_menu_14[] PROGMEM = "AltOut Post ms";
+prog_char set_menu_15[] PROGMEM = "USB Trigger";
+prog_char set_menu_16[] PROGMEM = "Invert Dir";
+prog_char set_menu_17[] PROGMEM = "Invert I/O";
+
+
+prog_char scope_menu_1[] PROGMEM = "Pan Man. Spd.";
+prog_char scope_menu_2[] PROGMEM = "Tilt Man. Spd.";
+
+ // menu organization
+
+PROGMEM const char *menu_str[]  = { menu_1, menu_2, menu_3, menu_4, menu_5, menu_6 };
+
+PROGMEM const char *man_str[]   = { manual_menu_1, manual_menu_2, manual_menu_3 };
+
+PROGMEM const char *axis0_str[] = { axis_menu_1, axis_menu_10, axis_menu_11, axis_menu_2, axis_menu_4, axis_menu_5, axis_menu_12, axis_menu_6, axis_menu_7, axis_menu_8 };
+PROGMEM const char *axis1_str[] = { axis_menu_1, axis_menu_10, axis_menu_11, axis_menu_2, axis_menu_4, axis_menu_5, axis_menu_12, axis_menu_6, axis_menu_7, axis_menu_8 };
+PROGMEM const char *cam_str[]   = { camera_menu_1, camera_menu_2, camera_menu_3, camera_menu_4, camera_menu_5, camera_menu_6, camera_menu_7, camera_menu_8 };
+PROGMEM const char *set_str[]   = { set_menu_1, set_menu_2, set_menu_3, set_menu_4, set_menu_5, set_menu_6, set_menu_7, set_menu_8, set_menu_9, set_menu_10, set_menu_11, set_menu_12, set_menu_13, set_menu_14, set_menu_15, set_menu_16, set_menu_17 };
+PROGMEM const char *scope_str[] = { scope_menu_1, scope_menu_2 };
+
+ // max number of inputs for each menu (in order listed above, starting w/ 0)
+
+ byte max_menu[7]  = {5,2,9,9,7,16,1};
+
+ // support a history of menus visited up to 5 levels deep
+byte hist_menu[5] = {0,0,0,0,0};
 
 char lcd_buf[MAX_LCD_STR];
 
-// what is our currently selected menu?
-// what is our current position?
+  // what is our currently selected menu?
+  // what is our current position?
 byte cur_menu      = 0;
 byte cur_pos       = 0;
 byte cur_pos_sel   = 0;
 
-// which input value position are we in?
+  // which input value position are we in?
 byte cur_inp_pos   = 0;
 
-// input buffers
+  // input buffers
 unsigned long cur_inp_long  = 0;
 float cur_inp_float         = 0.0;
 boolean cur_inp_bool        = false;
 
-// which input are we on, if on
-// the main screen.
+  // which input are we on, if on
+  // the main screen.
+  
 byte main_scr_input         = 0;
 
-// last read button (analog) value
+  // last read button (analog) value
 int last_but_rd = 1013;
 
-// flags for each button
-// use indivial bits to indicate
-// whether a given button was pressed.
+  // flags for each button
+  // use indivial bits to indicate
+  // whether a given button was pressed.
+  
 byte button_pressed = 0;
 
-// input value multiplier
+  // input value multiplier
+  
 unsigned int inp_val_mult = 1;
 
-// how long has a button been held for?
+  // how long has a button been held for?
 unsigned long hold_but_tm = 0;
-
-// when was ui last updated on home scr?
+  // when was ui last updated on home scr?
 unsigned long ui_update_tm = 0;
 
-// lcd dim control
+  // lcd dim control
 byte cur_bkl     = 255;
 boolean blank_lcd   = false;
 
-// for dimming lcd
+ // for dimming lcd
 unsigned int lcd_dim_tm     = 5;
 unsigned long input_last_tm = 0;
 
-// invert L/R displays?
-boolean ui_invdir = false;
-
-// floats are input in tenths?
+ // show cm instead of inch?
+boolean ui_is_metric = false;
+ // invert L/R displays?
+ boolean ui_invdir = false;
+ 
+  // floats are input in tenths?
 boolean ui_float_tenths = false;
 
-// user interface control flags
- #define UI_UPDATE_DISP (1<<0)        //B0 = update display
- #define UI_SETUP_MENU (1<<1)         //B1 = currently in setup menu
- #define UI_VALUE_ENTRY (1<<2)        //B2 = in value entry
- #define UI_DRAWN_INITAL_VALUE (1<<3) //B3 = have drawn initial value in value entry
- #define UI_USED_DECIMAL (1<<4)       //B4 = have used decimal in current value
- #define UI_MANUAL_MODE (1<<5)        //B5 = in manual mode
- #define UI_LCD_BKL_ON (1<<6)         //B6 = lcd bkl on
- #define UI_CALIBRATE_MODE (1<<7)     //B7 = in calibrate mode
+ /* user interface control flags
+ 
+   B0 = update display
+   B1 = currently in setup menu
+   B2 = in value entry
+   B3 = have drawn initial value in value entry
+   B4 = have used decimal in current value
+   B5 = in manual mode
+   B6 = lcd bkl on
+   B7 = in calibrate mode
+   
+ */
+   
 byte ui_ctrl_flags = B00000000;
 
-//calibration screen flags
-#define UI_CAL_CALIBRATING (1<<0)     //B0 = Currently calibrating
-#define UI_CAL_DONE        (1<<1)     //B1 = Done Calibrating
+ /* calibration screen flags
+ 
+    B0 = Currently calibrating
+    B1 = Done Calibrating
+    
+ */
+ 
 byte ui_cal_scrn_flags = 0;
 
-// whether to show cpm (true) or % (false)
+ // whether to show ipm (true) or pct (false)
+ 
 boolean ui_motor_display = true;
-#define CPM true
-#define PCT false
-
-//input type flags
-
- enum  __attribute__((packed)) INPUTS {
-     INPUT_FLOAT, INPUT_LONG, INPUT_ONOF, INPUT_SHUTTER, INPUT_LTRT, INPUT_CMPCT,INPUT_CONTSMS,INPUT_ANGLE,INPUT_IO,INPUT_SPEED,INPUT_PREPOST
- };
-
-
-byte ui_type = 0;
-
-// run status flags
-typedef struct
-{
-unsigned char bit0:
-  1;
-unsigned char bit1:
-  1;
-unsigned char bit2:
-  1;
-unsigned char bit3:
-  1;
-unsigned char bit4:
-  1;
-unsigned char bit5:
-  1;
-unsigned char bit6:
-  1;
-unsigned char bit7:
-  1;
-}
-io_reg;
-
-#define S_F_1                         ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit0
-#define S_SLOW_MODE_MON                ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit1
-#define S_SLOW_MODE                   ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit2
-#define S_MOT_RUNNING                 ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit3
-#define S_EXT_TRIG_ENGAGED             ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit4
-#define S_TIMER1_SET                  ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit5
-#define S_TIMER2_SET                  ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit6
-#define S_TIMER3_SET                  ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR0))->bit7
-
-#define S_RUNNING                     ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit0
-#define S_CAM_ENGAGED                 ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit1
-#define S_CAM_CYCLE_COMPLETE          ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit2
-#define S_5                           ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit3
-#define S_4                           ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit4
-#define S_3                           ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit5
-#define S_2                           ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit6
-#define S_1                           ((volatile io_reg*)_SFR_MEM_ADDR(GPIOR1))->bit7
 
-/* 
- B0 = running
- B1 = camera currently engaged
- B2 = camera cycle complete
- B3 = motor currently running
- B4 = external trigger engaged
- b5 = slow mode
- b6 = motor ran
- b7 
+ /* input type flags
+ 
+   B0 = input value is a float
+   B1 = input is a bool (on/off) value
+   B2 = input is a bool (up/dn) value
+   B3 = input is a bool (lt/rt) value
+   B4 = input is a bool (ipm/pct) value
+   B5 = input is a bool (pulse/sms) value
+   B6 = input is a bool (rotary/linear) value
+   B7 = input is list (0,45,90) value
+   
  */
+ 
+byte ui_type_flags = 0;
 
-// external intervalometer
-#define EXT_INTV_1 (1 << 0) //B0 = I/O 1 is external intervalometer
-#define EXT_INTV_2 (1 << 1) //B1 = I/O 2 is external intervalometer
-#define EXT_INTV_OK (1 << 2) //B2 = interval OK to fire
-//external trigger via alt i/o pins
-#define EXT_TRIG_1_BEFORE (1 << 3) //B0 = I/O 1 external enabled (before)
-#define EXT_TRIG_2_BEFORE (1 << 4) //B1 = I/O 2 external enabled (before)
-#define EXT_TRIG_1_AFTER  (1 << 5) //B2 = I/O 1 external enabled (after)
-#define EXT_TRIG_2_AFTER  (1 << 6) //B3 = I/O 2 external enabled (after)
-byte external_io = 0;
-
-// trigger delays //TODO
-//unsigned long ext_trig_pre_delay = 0;
-//unsigned long ext_trig_pst_delay = 0;
-unsigned long ext_in_delay = 0;
-unsigned long ext_out_delay = 0;
-// camera exposure time
-unsigned long exp_tm      = 100;
+ /* input type flags vector #2
+ 
+   B0 = input value is list (Disable/Start/Stop)
+   B1 = input value is forced metric
+   
+ */
+ 
+byte ui_type_flags2 = 0;
 
-// tap focus before exposing
-unsigned int focus_tap_tm = 0;
 
-// other delays in ms
-unsigned int post_delay_tm      = 100;
-unsigned int pre_delay_tm;
 
- enum  __attribute__((packed)) SHUTTER_MODE {
-     SHUTTER_MODE_IR_NIKON=0, SHUTTER_MODE_IR_CANON=1, SHUTTER_MODE_CABLE_NO_FOCUS=2, SHUTTER_MODE_CABLE_FOCUS=3};
+  /* run status flags
+  
+    B0 = running
+    B1 = camera currently engaged
+    B2 = camera cycle complete
+    B3 = motors currently running
+    B4 = external trigger engaged
+    
+  */
+  
+volatile byte run_status = 0;
+
+  /* external intervalometer
+    
+    B0 = I/O 1 is external intervalometer
+    B1 = I/O 2 is external intervalometer
+    B2 = interval OK to fire
+  
+  */
+  
+byte external_interval = 0;
 
-// shutter mode (0:NikonIR/1:CanonIR/2:Shutter Cab/3:Shut+Foc Cab)
-byte shutter_mode   = 0;
-boolean bulb_mode=false;
+ /* external trigger via alt i/o pins
+ 
+  B0 = I/O 1 external enabled (before)
+  B1 = I/O 2 external enabled (before)
+  B2 = I/O 1 external enabled (after)
+  B3 = I/O 2 external enabled (after)
 
-// intervalometer time (seconds)
-float cam_interval = 1.0;
+ */
+  
+byte external_trigger  = 0;
 
-// max shots
-unsigned int cam_max  = 0;
+ // trigger delays
+unsigned long ext_trig_pre_delay = 0;
+unsigned long ext_trig_pst_delay = 0;
 
-// camera repeat shots
-byte cam_repeat = 0;
+ // motor slow mode is pulse (true) or sms (false)
+boolean motor_sl_mod = true;
 
-// delay between camera repeat cycles
+ // camera exposure time
+unsigned long exp_tm      = 100;
+ // tap focus before exposing
+unsigned int focus_tap_tm = 0;
+ // delay after exposing (mS)
+unsigned int post_delay_tm      = 100;
+ // brign focus pin high w/ shutter
+boolean focus_shutter   = true;
+ // intervalometer time (seconds)
+float cam_interval = 1.0;
+ // max shots
+unsigned int cam_max  = 0;
+  // camera repeat shots
+byte cam_repeat = 0;
+  // delay between camera repeat cycles
 unsigned int cam_rpt_dly = 250;
 
+byte pre_focus_clear      = 0;
 unsigned long cam_last_tm = 0;
 
-// set speed for the current motor
-unsigned int m_speed = 0;
-
-// currently set speed (for altering motor speed)
-unsigned int m_cur_speed=0;
-
-//direction of motor
-byte m_dir = 0;
-
-// distance (i) per revolution
-float m_diarev =  3.53;
-
-// motor RPMs
-float m_rpm    = 9;
-
-// calculated max cpm
-float max_cpm =  m_diarev * m_rpm;
-
-// user-configurable min cpm
-float min_cpm = 20.0;
-
-// minimumspeed (min cpm->255 scale value) //TODO WHY?
-byte min_spd =  (min_cpm / max_cpm) * 255;
+  // currently selected motor
+byte cur_motor = 0;
+  // set speed for the current motor
+unsigned int m_speeds[2] = {0,0};
+  // currently set speed (for altering motor speed)
+unsigned int mcur_spds[2] = {0,0};
+  // prev direction for motor
+byte m_wasdir[2] = {0,0};
+  // distance (i) per revolution
+float m_diarev[2] = {3.53, 3.53};
+  // motor RPMs
+float m_rpm[2]    = { 8.75, 8.75 };
+  // calculated max ipm
+float max_ipm[2] = {m_diarev[0] * m_rpm[0], m_diarev[1] * m_rpm[1]};
+  // user-configurable min ipm
+float min_ipm[2] = {20.0, 20.0};
+  // minimumspeed (min ipm->255 scale value)
+byte min_spd[2] = { (min_ipm[0] / max_ipm[0]) * 255, (min_ipm[1] / max_ipm[1]) * 255 };
+ // minimum pulse cycles per motor
+byte m_min_pulse[2] = { 125, 125 };
+ // calibration points
+byte motor_spd_cal[2] = {1,40};
+
+
+  // maximum sms distance
+unsigned int m_maxsms[2] = { max_ipm[0] * 100, max_ipm[1] * 100};
+
+
+ // for timer1 pulsing mode control
+boolean timer_used = false;
+volatile  bool timer_engaged      = false;
+volatile bool motor_engaged      = false;
+volatile byte motor_ran = 0;
+
+ // motor calibration
+
+float m_cal_constant[2] = {0.69, 0.69};
+
+float m_cal_array[2][3][3][2] = { 
+              { 
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                },
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                },
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                } 
+              }, 
+              { 
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                },
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                },
+                {
+                  {0.61914329,0.61914329},{1.0,1.0},{2.01133251,2.11453032}
+                } 
+              } 
+            };
+            
+byte m_cur_cal = 0;
+byte m_angle[2] = {0,0};
 
+boolean m_cal_done = false;
 
-// calibration points
-byte motor_spd_cal[2] = {
-  2,10};
+ // ramping data
+byte m_ramp_set[2]     = {0,0};
+float m_ramp_shift[2]  = {0.0,0.0};
+byte m_ramp_mod[2]     = {0,0};
 
-// maximum sms distance //TODO
-unsigned int m_maxsms =  max_cpm * 100;
+ // lead-ins for axis movement
+unsigned int m_lead_in[2] = {0,0};
+unsigned int m_lead_out[2] = {0,0};
 
-//SMS or Cont. Mode?
-#define MODE_SMS true
-#define MODE_CONT false
-boolean m_mode=MODE_SMS;
+ // for controlling pulsing and sms movement
+unsigned long on_pct[2]                = {0,0};
+unsigned long off_pct[2]               = {0,0};
+unsigned int m_sms_tm[2]              = {0,0};
 
-//slow mode settings
-unsigned int  m_counter_max_on;
-unsigned int  m_counter_max_off;
-unsigned int  m_counter_cur;
-uint8_t m_pulse_length;
+ // shots fired
+unsigned long shots = 0;
 
-volatile bool motor_engaged      = false;
-volatile bool motor_ran = 0;
+ // function types for alt inputs...
  
-//TODO
-
-// motor calibration
-//m_cal_array[angle][point][dir]
-#define CALPOINT_SMS   0  //Shoot move shoot
-#define CALPOINT_PULSE 1  //slow speed pulsing
-#define CALPOINT_LOW   2  //cont. speed low
-#define CALPOINT_HIGH  3  //cont. speed high
-
-float m_cal_array[3][4][2] = //TODO sinnvolle Werte voreintragen. 
-{ 
-  {
-		{
-      1.0,1.0                      }
-    ,{
-      0.5,0.5                      }
-    ,{
-      1.0,1.0                      }
-    ,{
-      2.0,2.0                      }
-  }
-  ,
-   {
-		{
-      1.0,1.0                      }
-    ,{
-      0.5,0.5                      }
-    ,{
-      1.0,1.0                      }
-    ,{
-      2.0,2.0                      }
-  }
-  ,
-   {
-		{
-      1.0,1.0                      }
-    ,{
-      0.5,0.5                      }
-    ,{
-      1.0,1.0                      }
-    ,{
-      2.0,2.0                      }
-  }
-};
-
-byte m_angle = 0;
-
-boolean m_cal_done = false;
-
-
-// ramping data //TODO
-byte m_ramp_in=0;
-byte m_ramp_out=0;
+ /* 
+   0 = disabled
+   1 = start
+   2 = stop
+ */
+ 
+byte input_type[2]            = {0,0};
+unsigned long input_trig_last = 0;
 
-// lead-ins
-unsigned int m_lead_in  = 0;
-unsigned int m_lead_out = 0;
 
-// for controlling pulsing and sms movement
-//unsigned long on_pct  = 0; //TODO
-//unsigned long off_pct = 0; //TODO
-unsigned int m_sms_tm = 0;
+boolean merlin_enabled = false;
 
+byte  merlin_dir[2]        = {0,0};
+byte  merlin_wasdir[2]     = {0,0};
+float merlin_speeds[2]     = {0.0,0.0};
+float merlin_man_spd[2]    = {250.0,250.0};
 
-// shots fired
-unsigned long shots = 0;
+ /*
+   
+   0 = axis 0 currently running free (continuous)
+   1 = axis 1 currently running free
+   2 = in merlin manual control
+   3 = displaying merlin config screen
+   
+*/
 
-// function types for alt inputs...
-/* 
- 0 = disabled
- 1 = start
- 2 = stop
- 3 = toggle on/off
- 4 = ext intv.
- 5 = out before
- 6 = out after
- 7 = out booth
- 8 = toggle motor direction
- */
-byte input_type[2]            = {
-  0,0};
-  
-unsigned long input_trig_last = 0;
+byte merlin_flags = 0;
 
-// usb trigger flag
+ // usb trigger flag
 boolean gb_enabled = false;
 
-// default alt I/O rising/falling direction
+ // default alt I/O rising/falling direction
 byte altio_dir = FALLING;
 
- //timer globals
- uint16_t volatile timer3_ms;
-void (*timer1_func)();
-void (*timer2_func)();
-void (*timer3_func)();
- 
-// initialize LCD object
+ // initialize LCD object
 LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);
 
-void setup() { 
 
-  pinModeFast(CAMERA_PIN, OUTPUT);
-  pinModeFast(FOCUS_PIN, OUTPUT);
-  pinModeFast(IR_PIN, OUTPUT);
-  pinModeFast(MOTOR0_P, OUTPUT);
-  pinModeFast(MOTOR0_DIR, OUTPUT);
 
-  Serial.begin(115200);
-  init_user_interface();
 
-  // check firmware version stored in eeprom
-  // will cause eeprom_saved() to return false
-  // if version stored in eeprom does not match
-  // firmware version.  This automatically clears
-  // saved memory after a new firmware load -
-  // saving lots of support questions =)
-
-  eeprom_versioning();
+void setup() { 
 
-  // did we previously save settings to eeprom?
-  if( eeprom_saved() ) {
-    // restore saved memory
-    restore_eeprom_memory();
-  }
-  else {
-    // when memory has been cleared, or nothing has been
-    // saved, make sure eeprom contains default values
-    write_all_eeprom_memory();
-  }
+ pinMode(CAMERA_PIN, OUTPUT);
+ pinMode(FOCUS_PIN, OUTPUT);
+ pinMode(MOTOR0_P, OUTPUT);
+ pinMode(MOTOR1_P, OUTPUT);
+ pinMode(MOTOR1_DIR, OUTPUT);
+ pinMode(MOTOR0_DIR, OUTPUT);
+
+ Serial.begin(9600); 
+
+ init_user_interface();
+ delay(1000);
+
+    // check firmware version stored in eeprom
+    // will cause eeprom_saved() to return false
+    // if version stored in eeprom does not match
+    // firmware version.  This automatically clears
+    // saved memory after a new firmware load -
+    // saving lots of support questions =)
+    
+ eeprom_versioning();
+ 
+   // did we previously save settings to eeprom?
+ if( eeprom_saved() ) {
+     // restore saved memory
+   restore_eeprom_memory();
+ }
+ else {
+     // when memory has been cleared, or nothing has been
+     // saved, make sure eeprom contains default values
+   write_all_eeprom_memory();
+ }
+
+ show_home();
+ 
+ /*
+ for( byte i = 0; i <= 2; i++) {
+   Serial.print(i, DEC);
+   Serial.print(":");
+   for ( byte x = 0; x < 2; x++ ) {
+     Serial.print(m_cal_array[0][0][i][x], 8);
+     Serial.print(":");
+   }
+   Serial.println("");
+ } 
+ */
+ 
+}
 
-  input_last_tm=millis();
-
-  show_home();
-#
-  //Output Calibration Data
-  for( byte i = 0; i <= 3; i++) {
-    Serial.print(i, DEC);
-    Serial.print(":");
-    for ( byte x = 0; x < 2; x++ ) {
-      Serial.print(m_cal_array[0][i][x], 8);
-      Serial.print(":");
-    }
-    Serial.println("");
-  } 
 
-}
 
 void loop() {
 
-  // check for signal from gbtimelapse serial command.
-  // we check here to prevent queuing commands when stopped
-
+      // check for signal from gbtimelapse serial command.
+      // we check here to prevent queuing commands when stopped
+      
   if( gb_enabled == true && gbtl_trigger() == true ) {
-    external_io |= EXT_INTV_OK;
+    external_interval |= B00100000;
   }
 
-  if( S_RUNNING ) { //run_status & B10000000
+  if( run_status & B10000000 ) {
     // program is running
     main_loop_handler();
   } // end if running
-
-
-  // always check the UI for input or
-  // updates
-
+  else {
+      // not running, not in manual, but merlin motors are running?
+    if( ! ( ui_ctrl_flags & B00000100 ) && merlin_flags & B11000000 ) {
+      merlin_stop(0);
+      merlin_stop(1);
+    }
+  }
+  
+    // always check the UI for input or
+    // updates
+    
   check_user_interface();    
-
+ 
 }
 
-void main_loop_handler() {
 
 
+
+void main_loop_handler() {
+  
+  
   static boolean camera_fired   = false;
   static boolean motors_clear   = false;
   static boolean ok_stop        = false;
@@ -630,162 +589,236 @@ void main_loop_handler() {
   static boolean do_fire        = false;
   static boolean ext_trip       = false;
   static byte    cam_repeated   = 0;
-
-
-  if( (cam_max > 0 && shots >= cam_max) && ( ok_stop || (m_speed <= 0.0 ) || m_mode==MODE_SMS ) ) {
-    // stop program if max shots exceeded, and complete cycle completed
-    // if in interleave, ignore complete cycle if in SMS
-    ok_stop = false;
-    stop_executing();
-    // interrupt further processing      
+  
+  
+  if( cam_max > 0 && shots >= cam_max && ( ok_stop || (m_speeds[0] <= 0.0 && m_speeds[1] <= 0.0) || motor_sl_mod ) ) {
+    
+     // stop program if max shots exceeded, and complete cycle completed
+     // if in interleave, ignore ocmplete cycle if in pulse
+   ok_stop = false;
+   stop_executing();
+      // interrupt further processing      
   }
-
-  else  if ( (m_speed > 0) && (m_speed < min_spd ) )  {
-    // if motor needs to be pulsed...
+  else if( pre_focus_clear == 2 ) {  
+        // allow 100ms for focus line to settle before allowing any further
+      MsTimer2::set(100, clear_cam_focus);
+      MsTimer2::start();
+      pre_focus_clear = 3;
+  }
+  else  if( motor_sl_mod &&
+            (( m_speeds[0] > 0 && m_speeds[0] < min_spd[0] ) ||
+             ( m_speeds[1] > 0 && m_speeds[1] < min_spd[1] ) ) ) {
+        
+      // if pulse mode is on and at least
+      // one motor needs to be pulsed...
+    
     motor_run_pulsing();
-
+        
   }
-
-
-
-  // we need to determine if we can shoot the camera
-  // by seeing if it is currently being fired, or 
-  // is blocked in some way.  After making sure we're
-  // not blocked, we check to see if its time to fire the
-  // camera
-
-  if( motor_engaged && motor_ran ) {      
-      // motor has run one
-      // cycle, let the camera fire
-      motor_engaged = false;
-      ok_stop       = true;
-      in_sms_cycle  = false;
-    }// end if motor_engaged && motor_ran
   
+    // run merlin in continuous mode if needed
+    
+  if( motor_sl_mod && merlin_enabled ) {
+    merlin_run_cont();
+    ok_stop = true; // allow max shots stop when
+                    // in continuous mode
+  }
   
-  else if( S_CAM_ENGAGED) {
-    // currently firing the camera
-    // do nothing
+   
+    // we need to deterime if we can shoot the camera
+    // by seeing if it is currently being fired, or 
+    // is blocked in some way.  After making sure we're
+    // not blocked, we check to see if its time to fire the
+    // camera
+
+  if( motor_engaged ) {      
+    // motor currently moving
+    // do not fire camera until motors are
+    // done - we get caught up in here until the
+    // motors have stopped moving
+    
+    if( motor_ran == 1 ) {
+      // check to see if motor #2 needs to be run...
+      if( in_sms_cycle == false && m_sms_tm[0] > 0 && m_sms_tm[1] > 0 ) {
+        in_sms_cycle = true;
+          // motor #2 remains to be run
+        MsTimer2::set(m_sms_tm[1], stop_motor_sms);
+        run_motor_sms(1);
+        MsTimer2::start();
+      } 
+       else if(in_sms_cycle == false) {         
+           // no motors remain
+         motor_engaged = false;
+         ok_stop       = true;
+       }
+    }
+    else if ( motor_ran > 0 ) {
+        // all of our motors have run one
+        // cycle, let the camera fire
+       motor_engaged = false;
+       ok_stop       = true;
+       in_sms_cycle  = false;
+    }
+      
+  } // end if motor_engaged
+  else if( run_status & B01001000 || pre_focus_clear == 3 ) {
+      // currently firing the camera, focus, or triggering an external
+      // control line
+      
+      // do nothing
     ;
   }
-  else if(S_CAM_CYCLE_COMPLETE) { //run_status & B00100000
-    // camera cycle completed
-    // clear exposure cycle complete flag
-   S_CAM_CYCLE_COMPLETE=false;
-   
+  else if( run_status & B00100000 ) {
+      // camera cycle completed
+        // clear exposure cycle complete flag
+    run_status &= B11011111;
     if( camera_fired == true ) {
       // the shot just fired
       camera_fired = false;
       shots++;
-
-
-      // for ramping motor speeds
-      // we change speed in ramps after shots...
-      motor_execute_ramp_changes();
       
-      //  is the external trigger to fire?
-        if( external_io & (EXT_TRIG_2_AFTER | EXT_TRIG_1_AFTER) ) 
-          alt_ext_trigger_engage(false);
-
+      
+        // for ramping motor speeds
+        // we change speed in ramps after shots...
 
+      motor_execute_ramp_changes();
+        // check to see if a post-exposure delay is needed
       
-      // check to see if a post-exposure delay is needed
       if( post_delay_tm > 0 ) {
-        // we block anything from happening while in the
-        // post-exposure cycle by pretending to be an
-        // exposure
-      S_CAM_ENGAGED=true;  
-     //TODO
-       // MsTimer2::set(post_delay_tm, camera_clear);
-       // MsTimer2::start();
+          // we block anything from happening while in the
+          // post-exposure cycle by pretending to be an
+          // exposure
+        run_status |= B01000000;
+        
+        MsTimer2::set(post_delay_tm, camera_clear);
+        MsTimer2::start();
+        
         motors_clear = false;
         ok_stop = false;
       }
       else {
- 
+          // no post-exp delay, is the external trigger to fire?
+        if( external_trigger & B00110000 && ext_trig_pst_delay > 0 )
+          alt_ext_trigger_engage(false);
+       
+
         //no post-exposure delay, motors can run
         motors_clear = true;
       }
-    }//end cam_fired==true 
+        
+    } 
     else {
-      // this was a post-exposure delay cycle completing, not
-      // an actual shot
-  /* //TODO //why? already done?
-      // is the external trigger to fire?
+        // this was a post-exposure delay cycle completing, not
+        // an actual shot
+        
+        // is the external trigger to fire?
       if( external_trigger & B00110000 && ext_trig_pst_delay > 0 )
         alt_ext_trigger_engage(false);
-*/
+      
 
-      // we can set the motors clear to move now
+        // we can set the motors clear to move now
       motors_clear = true;        
     }
-  }//end S_CAM_CYCLE_COMPLETE
-
-  //else if( motors_clear == true && !motor_sl_mod && ( m_sms_tm > 0 ) ) {
-
-    //// if we're set to go to s-m-s and motor is set to move
-    //// start motor moving
-
-    //motor_ran = 0;
-
-    //// set motor to move, and then
-    //// set timer to turn them off  
-
-    //if( m_sms_tm > 0 ) {
-      //// start motor
-      //run_motor_sms(); 
-      //MsTimer2::set(m_sms_tm, stop_motor_sms);
-    //}
-
-
-    //// engage timer
-    //MsTimer2::start();
-
-    //motor_engaged = true;
-    //motors_clear = false;
-    //ok_stop      = false;
+    
+        // is the merlin head set to move?    
+    if( motors_clear == true && merlin_enabled  && ! motor_sl_mod ) {
+        // send merlin head to move sms distances (if desired)             
+  
+      if( merlin_speeds[0] > 0.0 ) {        
+        merlin_send_angle(0, merlin_speeds[0]);
+        ok_stop = false;
+      }
+      if( merlin_speeds[1] > 0.0 ) {
+        merlin_send_angle(1, merlin_speeds[1]);
+        ok_stop = false;
+      }
+      
+    }
 
-  //}   
+  }
+  else if( motors_clear == true && ! motor_sl_mod && 
+            ( merlin_enabled && ( merlin_flags & B11000000 ) ) ) {
+    
+        // merlin motors are currently running!
+        // other actions cannot continue...
+        
+    if( ! merlin.readAxisStatus(1) && ! merlin.readAxisStatus(2) ) {
+        // but not actually running... now remove the flags
+        // indicating so.
+      merlin_flags &= B00111111;
+      ok_stop = true;
+    }  
+    
+  } 
+  else if( motors_clear == true && ! motor_sl_mod &&
+              ( m_sms_tm[0] > 0 || m_sms_tm[1] > 0 ) ) {
+      
+       // if we're set to go to s-m-s and at least one motor is set to move
+      // start DC motor(s) moving
+  
+      motor_ran = 0;
+  
+        // set motors to move, and then
+        // set timer to turn them off  
+        
+      if( m_sms_tm[0] > 0 ) {
+            // start first motor
+        run_motor_sms(0); 
+        MsTimer2::set(m_sms_tm[0], stop_motor_sms);
+      }
+      else if( m_sms_tm[1] > 0 ) {
+          // start second motor (see state
+          // handling above, where motor_engaged is set)
+        run_motor_sms(1); 
+        MsTimer2::set(m_sms_tm[1], stop_motor_sms);
+      }
   
-  else if( gb_enabled == true || external_io & (EXT_INTV_1|EXT_INTV_2) ) {
+        // engage timer
+      MsTimer2::start();
+      
+      motor_engaged = true;
+      motors_clear = false;
+      ok_stop      = false;
+    
+  }   
+  else if( gb_enabled == true || external_interval & B11000000 ) {
     // external intervalometer is engaged
-
-    if( external_io & EXT_INTV_OK ) {
+    
+    if( external_interval & B00100000 ) {
       // external intervalometer has triggered
-
-      // clear out ok to fire flag
-      external_io &= ~EXT_INTV_OK;      
+ 
+          // clear out ok to fire flag
+      external_interval &= B11011111;      
       do_fire = true;
     }
   }
-  
   else if( cam_last_tm < millis() - (cam_interval * 1000) ) {
-    // internal intervalometer triggers
+      // internal intervalometer triggers
     do_fire = true;
   }
-
+  
   if( do_fire == true ) {
-    // we've had a fire camera event
-
-    // is the external trigger to fire? (either as 'before' or 'through')
-    if( (external_io & (EXT_TRIG_1_BEFORE|EXT_TRIG_2_BEFORE))  && ext_trip == false && (cam_repeat == 0 || cam_repeated == 0) ) {
-      alt_ext_trigger_engage(true);
-      ext_trip = true;
+      // we've had a fire camera event
+    
+           // is the external trigger to fire? (either as 'before' or 'through')
+    if( external_trigger & B11000000 && ext_trig_pre_delay > 0 && ext_trip == false && (cam_repeat == 0 || cam_repeated == 0) ) {
+        alt_ext_trigger_engage(true);
+        ext_trip = true;
     }
     else {
 
-      // make sure we handle pre-focus tap timing
-
-      if( ( /*pre_focus_clear == 4 ||*/ focus_tap_tm == 0 || (cam_repeat > 0 && cam_repeated > 0) ) && !(S_EXT_TRIG_ENGAGED) ) { //run_status & B00001000
-
-        // we always set the start mark at the time of the
-        // first exposure in a repeat cycle (or the time of exp
-        // if no repeat cycle is in play
-
+        // make sure we handle pre-focus tap timing
+        
+      if( ( pre_focus_clear == 4 || focus_tap_tm == 0 || (cam_repeat > 0 && cam_repeated > 0) ) && !(run_status & B00001000) ) {
+  
+          // we always set the start mark at the time of the
+          // first exposure in a repeat cycle (or the time of exp
+          // if no repeat cycle is in play
+          
         if( cam_repeat == 0 || cam_repeated == 0 )
           cam_last_tm  = millis();
-
-        // deal with camera repeat actions
+  
+          // deal with camera repeat actions
         if( cam_repeat == 0 || (cam_repeat > 0  && cam_repeated >= cam_repeat) ) {
           camera_fired = true;
           do_fire = false;
@@ -793,66 +826,67 @@ void main_loop_handler() {
           cam_repeated = 0;
         }
         else if( cam_repeat > 0 ) {
-          // only delay ater the first shot
+            // only delay ater the first shot
           if( cam_repeated > 0 )
             delay(cam_rpt_dly); // blocking delay between camera firings (we should fix this later!)
-
+            
           cam_repeated++;
         }
-
+        
         // camera is all clear to fire, and enough
         // time is elapsed
         fire_camera(exp_tm);
-       // pre_focus_clear = 0;
-
+        pre_focus_clear = 0;
+        
       }
-      else if( focus_tap_tm > 0 && /*pre_focus_clear == 0 &&*/ !(S_EXT_TRIG_ENGAGED) ) { //run_status & B00001000
-        // pre-focus tap is set, bring focus line high
-        digitalWriteFast(FOCUS_PIN, HIGH);
-      //  MsTimer2::set(focus_tap_tm, stop_cam_focus);
-      //  MsTimer2::start();
-        //pre_focus_clear = 1;
+      else if( focus_tap_tm > 0 && pre_focus_clear == 0 && !(run_status & B00001000) ) {
+          // pre-focus tap is set, bring focus line high
+        digitalWrite(FOCUS_PIN, HIGH);
+        MsTimer2::set(focus_tap_tm, stop_cam_focus);
+        MsTimer2::start();
+        pre_focus_clear = 1;
       }
     } // end else (not external trigger...
   } // end if(do_fire...
 }
 
+
 void start_executing() {
   // starts program execution
-
-  // clear out external interval flag in case it was
-  // set while stopped.
-  external_io&= ~EXT_INTV_OK;
-
- 
- // turn on motors
-  motor_control(true);
-  S_RUNNING=true; 
-  S_MOT_RUNNING=true; 
-
-  // if ramping is enabled for a motor, start at a zero
-  // speed
-  /*if( m_ramp_set >= 1 )
-    motor_set_speed(0); 
-*/
-
-  // reset shot counter
+  
+    // clear out external interval flag in case it was
+    // set while stopped.
+    
+   external_interval &= B11011111;
+  
+   run_status |= B10010000;
+  
+    // turn on motors
+  motor_control(0,true);
+  motor_control(1,true);
+  
+    // if ramping is enabled for a motor, start at a zero
+    // speed
+  if( m_ramp_set[0] >= 1 )
+      motor_set_speed(0, 0); 
+  if( m_ramp_set[1] >= 1 )
+      motor_set_speed(1, 0); 
+
+    // reset shot counter
   shots = 0;
 }
 
 void stop_executing() {
-  //run_status &= B01100111;
-  S_RUNNING=false;
-  S_MOT_RUNNING=false;
-  S_EXT_TRIG_ENGAGED=false;
+  run_status &= B01100111;
   motor_stop_all();
 }
 
-boolean gbtl_trigger() {
 
+boolean gbtl_trigger() {
+  
   if( Serial.available() > 0 ) {
     char thsChar = Serial.read();
-
+    
     if( thsChar == 'T' ) {
       return true;
     }
@@ -860,7 +894,7 @@ boolean gbtl_trigger() {
       return false;
     }
   }
-
+  
   return false;
 }
 
diff --git a/DollyShield/LICENSE.txt b/DollyShield/LICENSE.txt
index e963df8..92bc3d8 100644
--- a/DollyShield/LICENSE.txt
+++ b/DollyShield/LICENSE.txt
@@ -1,622 +1,622 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
diff --git a/DollyShield/bak/DollyShield.ino b/DollyShield/bak/DollyShield.ino
deleted file mode 100644
index 0050196..0000000
--- a/DollyShield/bak/DollyShield.ino
+++ /dev/null
@@ -1,863 +0,0 @@
-/* 
- 
- MX2 Dolly Engine version
- 
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- 
- Sketch to run the "DollyShield" design, provides control of
- the arduino shield.  A dual 1Amp motor control 
- shield with integrated LCD, 5 buttons, two generic I/O ports,
- and dual opto-coupled input for camera control.  
- 
- This sketch creates a user interface and implements core features
- of the shield, allowing for integrated control of one camera and 
- up to two axes of motion.  Features allow for all of the following
- motion types: shoot-move-shoot, continuous, and slow "pulsing" of 
- the full speed motor to allow for very slow speeds without more
- expensive steppers or even encoders.  
- 
- For more info go to http://openmoco.org
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
-
-
-#include <avr/pgmspace.h>
-#include <EEPROM.h>
-#include <LiquidCrystal.h>
-#include <digitalWriteFast.h>
-#include "MsTimer2.h"
-#include "TimerOne.h"
-
-
-
-#define FIRMWARE_VERSION  92
-
-// motor PWM
-#define MOTOR0_P 3
-#define MOTOR1_P 14
-#define MOTOR0_DIR 4
-#define MOTOR1_DIR 14
-
-// camera pins
-#define CAMERA_PIN 12
-#define FOCUS_PIN 13
-#define IR_PIN 12
-
-#define FREQ 38400
-#define oscd 16 //TODO
-
-#define MAX_MOTORS 1
-
-//#define MP_PERIOD 30
-#define MP_PERIOD 30
-
-
-/* User Interface Values */
-
-// lcd pins
-#define LCD_RS  8
-#define LCD_EN  9
-#define LCD_D4  4
-#define LCD_D5  5
-#define LCD_D6  6
-#define LCD_D7  7
-
-// which input is our button
-#define BUT_PIN A0
-
-// lcd backlight pin
-#define LCD_BKL 10
-
-// max # of LCD characters (including newline)
-#define MAX_LCD_STR 17
-
-
-
-// how many buttons dow we have?
-#define NUM_BUTTONS 5
-
-// button return values
-
-#define BUT0  1
-#define BUT1  2
-#define BUT2  3
-#define BUT3  4
-#define BUT4  5
-
-// which buttons?
-#define BUT_UP BUT1
-#define BUT_DN BUT2
-#define BUT_CT BUT4
-#define BUT_LT BUT3
-#define BUT_RT BUT0
-
-// analog button read values
-#define BUT0_VAL  0
-#define BUT1_VAL  100
-#define BUT2_VAL  255
-#define BUT3_VAL  405
-#define BUT4_VAL  640
-
-// button variance range
-#define BUT_THRESH  40
-
-
-// how many ms does a button have
-// to be held before triggering another
-// action? (for scrolling, etc.)
-
-#define HOLD_BUT_MS 200
-
-// how much to increment for each cycle the button is held?
-
-#define HOLD_BUT_VALINC 10
-
-// ALT input debouncing time
-
-#define ALT_TRIG_THRESH 250
-
-//IR Sequence
-unsigned int seq[] = {
-  16,77,1069,15,61,16,137,15,2427,77,1069,15,61,16,10};
-
-// menu strings
-prog_char menu_1[] PROGMEM = "Movements";
-prog_char menu_2[] PROGMEM = "Motor Setup";
-prog_char menu_4[] PROGMEM = "Camera Setup";
-prog_char menu_5[] PROGMEM = "General Setup";
-
-prog_char manual_menu_1[] PROGMEM = "Manual Move";
-prog_char manual_menu_3[] PROGMEM = "Fast Simulat.";
-
-prog_char axis_menu_1[] PROGMEM = "Ramp Shots";
-prog_char axis_menu_2[] PROGMEM = "RPM";
-prog_char axis_menu_4[] PROGMEM = "Angle";
-prog_char axis_menu_5[] PROGMEM = "Calibrate";
-prog_char axis_menu_6[] PROGMEM = "Slow Mode IPM";
-prog_char axis_menu_7[] PROGMEM = "Dist. per Rev";
-prog_char axis_menu_8[] PROGMEM = "Min Pulse";
-prog_char axis_menu_10[] PROGMEM = "Lead In";
-prog_char axis_menu_11[] PROGMEM = "Lead Out";
-prog_char axis_menu_12[] PROGMEM = "Cal. Constant";
-
-
-prog_char camera_menu_1[] PROGMEM = "Interval sec";
-prog_char camera_menu_2[] PROGMEM = "Max Shots";
-prog_char camera_menu_3[] PROGMEM = "Exp. Time ms";
-prog_char camera_menu_4[] PROGMEM = "Exp. Delay ms";
-prog_char camera_menu_5[] PROGMEM = "Focus Tap ms";
-prog_char camera_menu_6[] PROGMEM = "Nikon IR";
-prog_char camera_menu_7[] PROGMEM = "Shutter+Focus";
-prog_char camera_menu_8[] PROGMEM = "Repeat";
-prog_char camera_menu_9[] PROGMEM = "Repeat Delay";
-
-prog_char set_menu_1[] PROGMEM = "Motor Disp";
-prog_char set_menu_2[] PROGMEM = "Motor Sl.Mod";
-prog_char set_menu_3[] PROGMEM = "Backlight";
-prog_char set_menu_4[] PROGMEM = "AutoDim (sec)";
-prog_char set_menu_5[] PROGMEM = "Blank LCD";
-prog_char set_menu_6[] PROGMEM = "I/O 1";
-prog_char set_menu_7[] PROGMEM = "I/O 2";
-prog_char set_menu_8[] PROGMEM = "Metric Disp.";
-prog_char set_menu_9[] PROGMEM = "Reset Mem";
-prog_char set_menu_11[] PROGMEM = "Cal. Spd Low";
-prog_char set_menu_12[] PROGMEM = "Cal. Spd Hi";
-prog_char set_menu_13[] PROGMEM = "AltOut Pre ms";
-prog_char set_menu_14[] PROGMEM = "AltOut Post ms";
-prog_char set_menu_15[] PROGMEM = "USB Trigger";
-prog_char set_menu_16[] PROGMEM = "Invert Dir";
-prog_char set_menu_17[] PROGMEM = "Invert I/O";
-
-// menu organization
-
-PROGMEM const char *menu_str[]  = { 
-  menu_1, menu_2, menu_4, menu_5};
-
-PROGMEM const char *man_str[]   = { 
-  manual_menu_1,  manual_menu_3 };
-
-PROGMEM const char *axis0_str[] = { 
-  axis_menu_1, axis_menu_10, axis_menu_11, axis_menu_2, axis_menu_4, axis_menu_5, axis_menu_12, axis_menu_6, axis_menu_7, axis_menu_8 };
-PROGMEM const char *axis1_str[] = { 
-  axis_menu_1, axis_menu_10, axis_menu_11, axis_menu_2, axis_menu_4, axis_menu_5, axis_menu_12, axis_menu_6, axis_menu_7, axis_menu_8 };
-PROGMEM const char *cam_str[]   = { 
-  camera_menu_1, camera_menu_2, camera_menu_3, camera_menu_4, camera_menu_5, camera_menu_6, camera_menu_7, camera_menu_8,camera_menu_9 };
-PROGMEM const char *set_str[]   = { 
-  set_menu_1, set_menu_2, set_menu_3, set_menu_4, set_menu_5, set_menu_6,set_menu_7, set_menu_8, set_menu_9, set_menu_11, set_menu_12, set_menu_13, set_menu_14, set_menu_15, set_menu_16, set_menu_17 };
-
-
-// max number of inputs for each menu (in order listed above, starting w/ 0)
-
-byte max_menu[7]  = {
-  3,1,9,8,15};
-
-// support a history of menus visited up to 5 levels deep
-byte hist_menu[5] = {
-  0,0,0,0,0};
-
-char lcd_buf[MAX_LCD_STR];
-
-// what is our currently selected menu?
-// what is our current position?
-byte cur_menu      = 0;
-byte cur_pos       = 0;
-byte cur_pos_sel   = 0;
-
-// which input value position are we in?
-byte cur_inp_pos   = 0;
-
-// input buffers
-unsigned long cur_inp_long  = 0;
-float cur_inp_float         = 0.0;
-boolean cur_inp_bool        = false;
-
-// which input are we on, if on
-// the main screen.
-
-byte main_scr_input         = 0;
-
-// last read button (analog) value
-int last_but_rd = 1013;
-
-// flags for each button
-// use indivial bits to indicate
-// whether a given button was pressed.
-
-byte button_pressed = 0;
-
-// input value multiplier
-
-unsigned int inp_val_mult = 1;
-
-// how long has a button been held for?
-unsigned long hold_but_tm = 0;
-// when was ui last updated on home scr?
-unsigned long ui_update_tm = 0;
-
-// lcd dim control
-byte cur_bkl     = 255;
-boolean blank_lcd   = false;
-
-// for dimming lcd
-unsigned int lcd_dim_tm     = 5;
-unsigned long input_last_tm = 0;
-
-// show cm instead of inch?
-boolean ui_is_metric = false;
-// invert L/R displays?
-boolean ui_invdir = false;
-
-// floats are input in tenths?
-boolean ui_float_tenths = false;
-
-/* user interface control flags
- 
- B0 = update display
- B1 = currently in setup menu
- B2 = in value entry
- B3 = have drawn initial value in value entry
- B4 = have used decimal in current value
- B5 = in manual mode
- B6 = lcd bkl on
- B7 = in calibrate mode
- 
- */
-
-byte ui_ctrl_flags = B00000000;
-
-/* calibration screen flags
- 
- B0 = Currently calibrating
- B1 = Done Calibrating
- 
- */
-
-byte ui_cal_scrn_flags = 0;
-
-// whether to show ipm (true) or pct (false)
-
-boolean ui_motor_display = true;
-
-/* input type flags
- 
- B0 = input value is a float
- B1 = input is a bool (on/off) value
- B2 = input is a bool (up/dn) value
- B3 = input is a bool (lt/rt) value
- B4 = input is a bool (ipm/pct) value
- B5 = input is a bool (pulse/sms) value
- B6 = input is a bool (rotary/linear) value
- B7 = input is list (0,45,90) value
- 
- */
-
-byte ui_type_flags = 0;
-
-/* input type flags vector #2
- 
- B0 = input value is list (Disable/Start/Stop)
- B1 = input value is forced metric
- 
- */
-
-byte ui_type_flags2 = 0;
-
-
-
-/* run status flags
- 
- B0 = running
- B1 = camera currently engaged
- B2 = camera cycle complete
- B3 = motors currently running
- B4 = external trigger engaged
- 
- */
-
-volatile byte run_status = 0;
-
-/* external intervalometer
- 
- B0 = I/O 1 is external intervalometer
- B1 = I/O 2 is external intervalometer
- B2 = interval OK to fire
- 
- */
-
-byte external_interval = 0;
-
-/* external trigger via alt i/o pins
- 
- B0 = I/O 1 external enabled (before)
- B1 = I/O 2 external enabled (before)
- B2 = I/O 1 external enabled (after)
- B3 = I/O 2 external enabled (after)
- 
- */
-
-byte external_trigger  = 0;
-
-// trigger delays
-unsigned long ext_trig_pre_delay = 0;
-unsigned long ext_trig_pst_delay = 0;
-
-// motor slow mode is pulse (true) or sms (false)
-boolean motor_sl_mod = true;
-
-// camera exposure time
-unsigned long exp_tm      = 100;
-// tap focus before exposing
-unsigned int focus_tap_tm = 0;
-// delay after exposing (mS)
-unsigned int post_delay_tm      = 100;
-// brign focus pin high w/ shutter
-boolean focus_shutter   = true;
-//use ir remote
-boolean ir_remote   = true;
-// intervalometer time (seconds)
-float cam_interval = 1.0;
-// max shots
-unsigned int cam_max  = 0;
-// camera repeat shots
-byte cam_repeat = 0;
-// delay between camera repeat cycles
-unsigned int cam_rpt_dly = 250;
-
-byte pre_focus_clear      = 0;
-unsigned long cam_last_tm = 0;
-
-// currently selected motor
-//byte cur_motor = 0;
-// set speed for the current motor
-unsigned int m_speeds[1] = {
-  0};
-// currently set speed (for altering motor speed)
-unsigned int mcur_spds[1] = {
-  0};
-// prev direction for motor
-byte m_wasdir[1] = {
-  0};
-// distance (i) per revolution
-float m_diarev[1] = {
-  3.53};
-// motor RPMs
-float m_rpm[1]    = { 
-  8.75};
-// calculated max ipm
-float max_ipm[1] = {
-  m_diarev[0] * m_rpm[0]};
-// user-configurable min ipm
-float min_ipm[1] = {
-  20.0};
-// minimumspeed (min ipm->255 scale value)
-byte min_spd[1] = { 
-  (min_ipm[0] / max_ipm[0]) * 255};
-// minimum pulse cycles per motor
-byte m_min_pulse[1] = { 
-  125};
-// calibration points
-byte motor_spd_cal[2] = {
-  1,40};
-
-
-// maximum sms distance
-unsigned int m_maxsms[1] = { 
-  max_ipm[0] * 100};
-
-
-// for timer1 pulsing mode control
-boolean timer_used = false;
-volatile  bool timer_engaged      = false;
-volatile bool motor_engaged      = false;
-volatile byte motor_ran = 0;
-
-// motor calibration
-
-float m_cal_constant[1] = {
-  0.69};
-
-float m_cal_array[1][3][3][2] = { 
-  { 
-    {
-      {
-        0.61914329,0.61914329                  }
-      ,{
-        1.0,1.0                  }
-      ,{
-        2.01133251,2.11453032                  }
-    }
-    ,
-    {
-      {
-        0.61914329,0.61914329                  }
-      ,{
-        1.0,1.0                  }
-      ,{
-        2.01133251,2.11453032                  }
-    }
-    ,
-    {
-      {
-        0.61914329,0.61914329                  }
-      ,{
-        1.0,1.0                  }
-      ,{
-        2.01133251,2.11453032                  }
-    } 
-  }
-};
-
-byte m_cur_cal = 0;
-byte m_angle[2] = {
-  0,0};
-
-boolean m_cal_done = false;
-
-// ramping data
-byte m_ramp_set[1]     = {
-  0};
-float m_ramp_shift[1]  = {
-  0.0};
-byte m_ramp_mod[1]     = {
-  0};
-
-// lead-ins for axis movement
-unsigned int m_lead_in[1] = {
-  0};
-unsigned int m_lead_out[1] = {
-  0};
-
-// for controlling pulsing and sms movement
-unsigned long on_pct[1]                = {
-  0};
-unsigned long off_pct[1]               = {
-  0};
-unsigned int m_sms_tm[1]              = {
-  0};
-
-// shots fired
-unsigned long shots = 0;
-
-// function types for alt inputs...
-
-/* 
- 0 = disabled
- 1 = start
- 2 = stop
- */
-
-byte input_type[2]            = {0,0};
-unsigned long input_trig_last = 0;
-/*
- 
- 0 = axis 0 currently running free (continuous)
- 1 = axis 1 currently running free
- 2 = in merlin manual control
- 3 = displaying merlin config screen
- 
- */
-// usb trigger flag
-boolean gb_enabled = false;
-
-// default alt I/O rising/falling direction
-byte altio_dir = FALLING;
-
-// initialize LCD object
-LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);
-
-
-
-
-void setup() { 
-
-  pinModeFast(CAMERA_PIN, OUTPUT);
-  pinModeFast(FOCUS_PIN, OUTPUT);
-  pinModeFast(IR_PIN, OUTPUT);
-  pinModeFast(MOTOR0_P, OUTPUT);
-  pinModeFast(MOTOR0_DIR, OUTPUT);
-
-  Serial.begin(115200);
-
-  init_user_interface();
-  delay(500);
-
-  // check firmware version stored in eeprom
-  // will cause eeprom_saved() to return false
-  // if version stored in eeprom does not match
-  // firmware version.  This automatically clears
-  // saved memory after a new firmware load -
-  // saving lots of support questions =)
-
-  eeprom_versioning();
-
-  // did we previously save settings to eeprom?
-  if( eeprom_saved() ) {
-    // restore saved memory
-    restore_eeprom_memory();
-  }
-  else {
-    // when memory has been cleared, or nothing has been
-    // saved, make sure eeprom contains default values
-    write_all_eeprom_memory();
-  }
-
-  input_last_tm=millis();
-
-  show_home();
-
-  /*
- for( byte i = 0; i <= 2; i++) {
-   Serial.print(i, DEC);
-   Serial.print(":");
-   for ( byte x = 0; x < 2; x++ ) {
-   Serial.print(m_cal_array[0][0][i][x], 8);
-   Serial.print(":");
-   }
-   Serial.println("");
-   } 
-   */
-
-}
-
-
-
-void loop() {
-
-  // check for signal from gbtimelapse serial command.
-  // we check here to prevent queuing commands when stopped
-
-  if( gb_enabled == true && gbtl_trigger() == true ) {
-    external_interval |= B00100000;
-  }
-
-  if( run_status & B10000000 ) {
-    // program is running
-    main_loop_handler();
-  } // end if running
-
-
-  // always check the UI for input or
-  // updates
-
-  check_user_interface();    
-
-}
-
-
-
-
-void main_loop_handler() {
-
-
-  static boolean camera_fired   = false;
-  static boolean motors_clear   = false;
-  static boolean ok_stop        = false;
-  static boolean in_sms_cycle   = false;
-  static boolean do_fire        = false;
-  static boolean ext_trip       = false;
-  static byte    cam_repeated   = 0;
-
-
-  if( cam_max > 0 && shots >= cam_max && ( ok_stop || (m_speeds[0] <= 0.0 ) || motor_sl_mod ) ) {
-
-    // stop program if max shots exceeded, and complete cycle completed
-    // if in interleave, ignore ocmplete cycle if in pulse
-    ok_stop = false;
-    stop_executing();
-    // interrupt further processing      
-  }
-  else if( pre_focus_clear == 2 ) {  
-    // allow 100ms for focus line to settle before allowing any further
-    MsTimer2::set(100, clear_cam_focus);
-    MsTimer2::start();
-    pre_focus_clear = 3;
-  }
-  else  if( motor_sl_mod &&
-    (( m_speeds[0] > 0 && m_speeds[0] < min_spd[0] ) ) ) {
-
-    // if pulse mode is on and at least
-    // one motor needs to be pulsed...
-
-    motor_run_pulsing();
-
-  }
-
-
-
-  // we need to deterime if we can shoot the camera
-  // by seeing if it is currently being fired, or 
-  // is blocked in some way.  After making sure we're
-  // not blocked, we check to see if its time to fire the
-  // camera
-
-  if( motor_engaged ) {      
-       if ( motor_ran > 0 ) {
-      // all of our motors have run one
-      // cycle, let the camera fire
-      motor_engaged = false;
-      ok_stop       = true;
-      in_sms_cycle  = false;
-    }
-
-  } // end if motor_engaged
-  else if( run_status & B01001000 || pre_focus_clear == 3 ) {
-    // currently firing the camera, focus, or triggering an external
-    // control line
-
-    // do nothing
-    ;
-  }
-  else if( run_status & B00100000 ) {
-    // camera cycle completed
-    // clear exposure cycle complete flag
-    run_status &= B11011111;
-    if( camera_fired == true ) {
-      // the shot just fired
-      camera_fired = false;
-      shots++;
-
-
-      // for ramping motor speeds
-      // we change speed in ramps after shots...
-
-      motor_execute_ramp_changes();
-      // check to see if a post-exposure delay is needed
-
-      if( post_delay_tm > 0 ) {
-        // we block anything from happening while in the
-        // post-exposure cycle by pretending to be an
-        // exposure
-        run_status |= B01000000;
-
-        MsTimer2::set(post_delay_tm, camera_clear);
-        MsTimer2::start();
-
-        motors_clear = false;
-        ok_stop = false;
-      }
-      else {
-        // no post-exp delay, is the external trigger to fire?
-        if( external_trigger & B00110000 && ext_trig_pst_delay > 0 )
-          alt_ext_trigger_engage(false);
-
-
-        //no post-exposure delay, motors can run
-        motors_clear = true;
-      }
-
-    } 
-    else {
-      // this was a post-exposure delay cycle completing, not
-      // an actual shot
-
-      // is the external trigger to fire?
-      if( external_trigger & B00110000 && ext_trig_pst_delay > 0 )
-        alt_ext_trigger_engage(false);
-
-
-      // we can set the motors clear to move now
-      motors_clear = true;        
-    }
-
-
-
-  }
-
-  else if( motors_clear == true && ! motor_sl_mod &&
-    ( m_sms_tm[0] > 0 ) ) {
-
-    // if we're set to go to s-m-s and at least one motor is set to move
-    // start DC motor(s) moving
-
-    motor_ran = 0;
-
-    // set motors to move, and then
-    // set timer to turn them off  
-
-    if( m_sms_tm[0] > 0 ) {
-      // start first motor
-      run_motor_sms(); 
-      MsTimer2::set(m_sms_tm[0], stop_motor_sms);
-    }
-
-
-    // engage timer
-    MsTimer2::start();
-
-    motor_engaged = true;
-    motors_clear = false;
-    ok_stop      = false;
-
-  }   
-  else if( gb_enabled == true || external_interval & B11000000 ) {
-    // external intervalometer is engaged
-
-    if( external_interval & B00100000 ) {
-      // external intervalometer has triggered
-
-      // clear out ok to fire flag
-      external_interval &= B11011111;      
-      do_fire = true;
-    }
-  }
-  else if( cam_last_tm < millis() - (cam_interval * 1000) ) {
-    // internal intervalometer triggers
-    do_fire = true;
-  }
-
-  if( do_fire == true ) {
-    // we've had a fire camera event
-
-    // is the external trigger to fire? (either as 'before' or 'through')
-    if( external_trigger & B11000000 && ext_trig_pre_delay > 0 && ext_trip == false && (cam_repeat == 0 || cam_repeated == 0) ) {
-      alt_ext_trigger_engage(true);
-      ext_trip = true;
-    }
-    else {
-
-      // make sure we handle pre-focus tap timing
-
-      if( ( pre_focus_clear == 4 || focus_tap_tm == 0 || (cam_repeat > 0 && cam_repeated > 0) ) && !(run_status & B00001000) ) {
-
-        // we always set the start mark at the time of the
-        // first exposure in a repeat cycle (or the time of exp
-        // if no repeat cycle is in play
-
-        if( cam_repeat == 0 || cam_repeated == 0 )
-          cam_last_tm  = millis();
-
-        // deal with camera repeat actions
-        if( cam_repeat == 0 || (cam_repeat > 0  && cam_repeated >= cam_repeat) ) {
-          camera_fired = true;
-          do_fire = false;
-          ext_trip = false;
-          cam_repeated = 0;
-        }
-        else if( cam_repeat > 0 ) {
-          // only delay ater the first shot
-          if( cam_repeated > 0 )
-            delay(cam_rpt_dly); // blocking delay between camera firings (we should fix this later!)
-
-          cam_repeated++;
-        }
-
-        // camera is all clear to fire, and enough
-        // time is elapsed
-        fire_camera(exp_tm);
-        pre_focus_clear = 0;
-
-      }
-      else if( focus_tap_tm > 0 && pre_focus_clear == 0 && !(run_status & B00001000) ) {
-        // pre-focus tap is set, bring focus line high
-        digitalWriteFast(FOCUS_PIN, HIGH);
-        MsTimer2::set(focus_tap_tm, stop_cam_focus);
-        MsTimer2::start();
-        pre_focus_clear = 1;
-      }
-    } // end else (not external trigger...
-  } // end if(do_fire...
-}
-
-
-void start_executing() {
-  // starts program execution
-
-  // clear out external interval flag in case it was
-  // set while stopped.
-
-  external_interval &= B11011111;
-
-  run_status |= B10010000;
-
-  // turn on motors
-  motor_control(true);
-
-
-  // if ramping is enabled for a motor, start at a zero
-  // speed
-  if( m_ramp_set[0] >= 1 )
-    motor_set_speed(0); 
-
-
-  // reset shot counter
-  shots = 0;
-}
-
-void stop_executing() {
-  run_status &= B01100111;
-  motor_stop_all();
-}
-
-
-boolean gbtl_trigger() {
-
-  if( Serial.available() > 0 ) {
-    char thsChar = Serial.read();
-
-    if( thsChar == 'T' ) {
-      return true;
-    }
-    else {
-      return false;
-    }
-  }
-
-  return false;
-}
-
-
-
-
diff --git a/DollyShield/bak/LICENSE.txt b/DollyShield/bak/LICENSE.txt
deleted file mode 100644
index e963df8..0000000
--- a/DollyShield/bak/LICENSE.txt
+++ /dev/null
@@ -1,622 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
diff --git a/DollyShield/bak/ds_alt_io.ino b/DollyShield/bak/ds_alt_io.ino
deleted file mode 100644
index 6b32d12..0000000
--- a/DollyShield/bak/ds_alt_io.ino
+++ /dev/null
@@ -1,215 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-/*
-
- ========================================
- Alt I/O Handlers
- ========================================
- 
- */
-
-
-//TODO: Remove which
-void altio_isr_handler(byte which) {
-
-  // from internals
-  extern volatile unsigned long timer0_millis;
-
-  if( timer0_millis - input_trig_last > ALT_TRIG_THRESH ) {
-
-    input_trig_last = timer0_millis;
-
-    switch( input_type[which] ) {
-
-    case 1:
-      start_executing();
-      break;
-
-    case 2:
-      stop_executing();
-      break;
-
-    case 3:
-      altio_flip_runstat();
-      break;
-
-    case 4: 
-      // set camera ok to fire
-      external_interval |= B00100000;
-      break;
-
-    case 8:
-      // switch  motor direction
-      motor_dir(!m_wasdir[0]);
-
-      break;
-
-    default:
-      break;
-    } // end switch
-  } //end if timer0...
-}
-
-
-void altio_isr_one() {
-  altio_isr_handler(0);
-}
-
-
-void altio_isr_two() {
-  altio_isr_handler(1);
-}
-
-
-void altio_connect(byte which, byte type) {
-
-  input_type[which] = type;
-
-  // type == 5, 6, 7 changes from input to output, handle this
-  // deviation
-
-  if( type == 5 || type == 6 || type == 7 ) {
-    // output mode
-
-    detachInterrupt(which);
-    if (which==0){
-      pinModeFast(2,OUTPUT);
-    }
-    else{
-      pinModeFast(3,OUTPUT);
-    }
-    // set correct flag, as needed
-    if( type == 5 ) {
-      external_trigger |= B10000000 >> which;
-    }
-    else if( type == 6 ) {
-      external_trigger |= B00100000 >> which;
-    }
-    else {
-      external_trigger |= B10100000 >> which;
-    }
-
-    return;
-  }
-
-  if( type == 0 ) {
-    detachInterrupt(which);
-
-    if (which==0){
-      digitalWriteFast(2, LOW);
-    }
-    else{
-      digitalWriteFast(3, LOW);
-    }
-
-    // disable external interval for this line (just in case it
-    // was ever set)
-    external_interval &= (B11111111 ^ (B10100000 >> which));
-    return;
-  }
-  else if( type == 4 ) {
-    // our external intervalometer functon
-
-    // enable external intervalometer for this line
-    external_interval |= B10000000 >> which;
-  }
-  else {
-    // disable external interval for this line (just in case it
-    // was ever set)
-    external_interval &= (B11111111 ^ (B10100000 >> which));
-  }
-
-
-  if (which==0){
-
-    // set pin as input
-    pinModeFast(2, INPUT);
-    // enable pull-up resistor
-    digitalWriteFast(2, HIGH);
-    attachInterrupt(0, altio_isr_one, altio_dir);
-  }
-  else{
-    pinModeFast(3, INPUT);
-    // enable pull-up resistor
-    digitalWriteFast(3, HIGH);
-    attachInterrupt(1, altio_isr_two, altio_dir);
-  }
-
-
-}    
-
-void altio_flip_runstat() {
-  // if currently running, stop; if not, start
-
-    if( run_status & B10000000 ) {
-    // running
-    stop_executing();
-  }
-  else {
-    start_executing();
-  }
-
-}
-
-void alt_ext_trigger_engage(boolean predel) {
-
-  unsigned long dly = predel == true ? ext_trig_pre_delay : ext_trig_pst_delay;
-  // set flag
-  run_status |= B00001000;
-
-  // we use the interrupt pins, 2&3
-
-  if( predel == true ) {
-    if( external_trigger & B10000000 ) 
-      digitalWriteFast(2, HIGH);
-    if( external_trigger & B01000000 )
-      digitalWriteFast(3, HIGH);
-  }
-  else {
-    if( external_trigger & B00100000 ) 
-      digitalWriteFast(2, HIGH);
-    if( external_trigger & B00010000 )
-      digitalWriteFast(3, HIGH);
-  }        
-
-  MsTimer2::set(dly, alt_ext_trigger_disengage);
-  MsTimer2::start();
-}
-
-void alt_ext_trigger_disengage() {
-
-  if( external_trigger & B10100000 )
-    digitalWriteFast(2, LOW);
-  if( external_trigger & B01010000 )
-    digitalWriteFast(3, LOW);
-
-  MsTimer2::stop();
-
-  // clear flag...
-  run_status &= B11110111;
-}
-
-
-
-
-
diff --git a/DollyShield/bak/ds_camera.ino b/DollyShield/bak/ds_camera.ino
deleted file mode 100644
index 5f6286c..0000000
--- a/DollyShield/bak/ds_camera.ino
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
-
- 
- OpenMoco
- - Time-lapse Core Engine
- 
- - Modified for DollyShield (MX2) 6/2010 changes by cchurch/dynamicperception
- 
- 
- See www.openmoco.org for more information
- 
- 
- 
- (c) 2008-2010 C.A. Church
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-
-/*
-
- ========================================
- Camera control functions
- ========================================
- 
- */
-
-void fire_camera(unsigned long exp_tm) {
-  //TODO IR  
-
-  // determine if focus pin should be brought high
-  // w. the shutter pin (for some nikons, etc.)
-  if (!ir_remote){   
-    if( focus_shutter )
-      digitalWriteFast(FOCUS_PIN, HIGH);
-
-    digitalWriteFast(CAMERA_PIN, HIGH);
-  }
-  else{
-    send_ir();
-  }
-  // start timer to stop camera exposure
-  MsTimer2::set(exp_tm, stop_camera);
-  MsTimer2::start();
-
-  // update camera currently enaged
-  // (turn on bit)
-  run_status |= B01000000;
-
-  return;
-}
-
-
-void stop_camera() {
-
-  digitalWriteFast(CAMERA_PIN, LOW);
-
-  // we do this every time, because
-  // it's possible that the flag
-  // that controls whether or not to
-  // trip focus w. shutter may have
-  // been reset during our exposure,
-  // and failing to do so would keep
-  // the focus pin high for a long
-  // time.
-
-  digitalWriteFast(FOCUS_PIN, LOW);
-
-  // turn off timer - we do this
-  // after the digitalWriteFast() to minimize
-  // over-shooting in case this takes some
-  // unusually-long amount of time
-  if (ir_remote) send_ir();   
-  MsTimer2::stop();
-
-  // are we supposed to delay before allowing
-  // the motors to move?  Register a timer
-  // to clear out status flags, otherwise
-  // just clear them out now.
-
-  // the delay is used to prevent motor movement
-  // when shot timing is controlled by the camera.
-  // the post-delay should be set to an amount greater
-  // than the max possible camera exposure timing
-
-  // update camera currently engaged
-  run_status &= B10111111;
-
-  // update camera cycle complete
-  run_status |= B00100000;
-
-}
-
-
-void camera_clear() {
-  // clears out camera engaged settings
-  // so that motor control and other actions can 
-  // be undertaken.  Used as a timer whenever
-  // a camera post delay is set.
-
-  MsTimer2::stop(); // turn off timer
-
-  // update camera currently engaged
-  run_status &= B10111111;
-
-  // update camera cycle complete
-  run_status |= B00100000;
-
-}  
-
-
-
-void stop_cam_focus() {
-
-  MsTimer2::stop();
-  digitalWriteFast(FOCUS_PIN, LOW);
-  pre_focus_clear = 2;
-
-}
-
-void clear_cam_focus() {
-  MsTimer2::stop();
-  pre_focus_clear = 4;
-}
-
-float calc_total_cam_tm() {
-
-  // calculate total minimum time between exposures 
-
-  byte pf_tm = 0;
-
-  // add 100ms pre-focus tap clear value
-  if( focus_tap_tm > 0 ) 
-    pf_tm = focus_tap_tm + 100;
-
-  float total = (float) ( exp_tm + pf_tm + post_delay_tm  );
-
-  if( ! motor_sl_mod )
-    total += m_sms_tm[0] + m_sms_tm[1];
-
-  total = total / 1000.00;
-
-  return(total);
-}
-
-void send_ir(){
-  for(unsigned int i=1;i<=seq[0];i++){
-    int ir_status=0;
-    int n=seq[i];
-    while(n>0){
-      n--;
-      delayMicroseconds(oscd);
-      ir_status  =  !ir_status; 
-      digitalWriteFast(IR_PIN, ir_status&&(i%2));   
-    }
-  }
-}
-
diff --git a/DollyShield/bak/ds_eeprom.ino b/DollyShield/bak/ds_eeprom.ino
deleted file mode 100644
index c9940d4..0000000
--- a/DollyShield/bak/ds_eeprom.ino
+++ /dev/null
@@ -1,360 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-/*
-
- ========================================
- EEPROM write/read functions
- ========================================
- 
- */
-
-
-/* 
- 
- *******************************
- Mapping of Data Positions in EEPROM memory
- *******************************
- 
- (position count starts at zero)
- 
- flash enabled   = 0
- (was exp_tm)    = 1-2*
- focus_tap_tm    = 3-4
- post_delay_tm   = 5-6
- focus_shutter   = 7
- = 8-9
- cam_max         = 10-11
- m_speeds[0]     = 12-13
- m_speeds[1]     = 14-15
- m_diarev[0]     = 16-19
- m_diarev[1]     = 20-23
- max_ipm[0]      = 24-27
- max_ipm[1]      = 28-31
- m_rpm[0]        = 32-35
- m_rpm[1]        = 36-39
- min_ipm[0]      = 40-43
- min_ipm[1]      = 44-47
- min_spd[0]      = 48
- min_spd[1]      = 49
- m_min_pulse[0]  = 50
- m_min_pulse[0]  = 51
- altio_dir       = 52
- = 53
- = 54
- = 55 
- ui_motor_display = 56
- motor_sl_mod    = 57
- lcd_dim_tm      = 58-59
- blank_lcd       = 60
- m_ramp_set[0]   = 61
- m_ramp_set[0]   = 62
- m_maxsms[0]     = 63-64
- m_maxsms[1]     = 65-66
- cam_interval    = 67-70
- m_cal_array[]   = 71-214
- m_angle[0]      = 215
- m_angle[1]      = 216 
- input_type[0]   = 217
- input_type[1]   = 218
- ui_is_metric    = 219
- merlin_enable   = 220
- merlin_man_spd[0] = 221-224
- merlin_man_spd[1] = 225-228
- m_lead_in[0]    = 229-230
- m_lead_in[1]    = 231-232
- m_lead_out[0]   = 233-234
- m_lead_out[1]   = 235-236
- motor_spd_cal[0] = 237
- motor_spd_cal[1] = 238
- m_cal_constant[0] = 239-242
- m_cal_constant[1] = 243-246
- firmware_version  = 247-248
- cam_repeat     = 249
- cam_rpt_dly    = 250-251
- ext_trig_pre_dly = 252-255
- ext_trig_pst_dly = 256-259
- exp_tm         = 260-263
- gb_enabled     = 264
- ui_invdir      = 265
- cur_bkl        = 266
- use_ir         = 267
- */
-
-
-
-
-boolean eeprom_saved() {
-
-  // read eeprom saved status
-
-  byte saved = EEPROM.read(0);
-
-  // EEPROM memory is by default set to 1, so we
-  // set it to zero if we've written data to eeprom
-  return( ! saved );
-}
-
-void eeprom_saved( boolean saved ) {
-  // set eeprom saved status
-
-  // EEPROM memory is by default set to 1, so we
-  // set it to zero if we've written data to eeprom
-
-  EEPROM.write(0, !saved);
-}
-
-
-
-
-
-// One can ask why I didn't use the templates from http://www.arduino.cc/playground/Code/EEPROMWriteAnything
-// The primary reason here is that we're going to be calling these functions OFTEN, and I _really_ don't 
-// want the templates getting inlined _everywhere_, what a mess!  So, rather than be slick, let's just declare
-// what we mean, and do it once - forget about the overhead of the function call, and worry more about
-// flash and stack abuse 
-
-
-void eeprom_write( int pos, byte& val, byte len ) {
-  byte* p = (byte*)(void*)&val;
-  for( byte i = 0; i < len; i++ )
-    EEPROM.write(pos++, *p++);    
-
-  // indicate that memory has been saved
-  eeprom_saved(true);
-
-}
-
-void eeprom_write( int pos, unsigned int& val ) {
-  byte* p = (byte*)(void*)&val;   
-  eeprom_write(pos, *p, sizeof(int));  
-}
-
-void eeprom_write( int pos, unsigned long& val ) {
-  byte* p = (byte*)(void*)&val;   
-  eeprom_write(pos, *p, sizeof(long));    
-}
-
-void eeprom_write( int pos, float& val ) {
-  byte* p = (byte*)(void*)&val;   
-  eeprom_write(pos, *p, sizeof(float));    
-}
-
-void eeprom_write( int pos, byte& val ) {  
-  EEPROM.write(pos, val);
-  // indicate that memory has been saved
-  eeprom_saved(true);
-}
-
-
-
-
-
-// read functions
-
-void eeprom_read( int pos, byte& val, byte len ) {
-  byte* p = (byte*)(void*)&val;
-  for(byte i = 0; i < len; i++) 
-    *p++ = EEPROM.read(pos++);
-}
-
-void eeprom_read( int pos, byte& val ) {
-  val = EEPROM.read(pos);
-}
-
-
-void eeprom_read( int pos, int& val ) {
-  byte* p = (byte*)(void*)&val;
-  eeprom_read(pos, *p, sizeof(int));
-}
-
-void eeprom_read( int pos, unsigned int& val ) {
-
-  byte* p = (byte*)(void*)&val;
-  eeprom_read(pos, *p, sizeof(int));
-
-}
-
-void eeprom_read( int pos, unsigned long& val ) {
-
-  byte* p = (byte*)(void*)&val;
-  eeprom_read(pos, *p, sizeof(long));
-
-}
-
-void eeprom_read( int pos, float& val ) {
-
-  byte* p = (byte*)(void*)&val;
-  eeprom_read(pos, *p, sizeof(float));
-
-}
-
-void write_all_eeprom_memory() {
-
-  // write default values into eeprom
-  eeprom_write(3, focus_tap_tm);
-  eeprom_write(5, post_delay_tm);
-  eeprom_write(7, focus_shutter);
-
-  eeprom_write(10, cam_max);
-  eeprom_write(16, m_diarev[0]);
-  eeprom_write(24, max_ipm[0]);
-  eeprom_write(32, m_rpm[0]);
-  eeprom_write(40, min_ipm[0]);
-  eeprom_write(48, min_spd[0]);
-  eeprom_write(50, m_min_pulse[0]);
-  eeprom_write(52, altio_dir);
-  eeprom_write(56, ui_motor_display);
-  eeprom_write(57, motor_sl_mod);
-  eeprom_write(58, lcd_dim_tm);
-  eeprom_write(60, blank_lcd);
-  eeprom_write(61, m_ramp_set[0]);
-  eeprom_write(63, m_maxsms[0]);
-  eeprom_write(67, cam_interval);
-
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[1][3][3][2] 
-  // 1 * 3 * 3 * 2 * 4 = 72
-
-  byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_write(71, *p, 72);
-
-  eeprom_write(217, input_type[0]);
-  eeprom_write(218, input_type[1]);
-  eeprom_write(219, ui_is_metric);
-  eeprom_write(229, m_lead_in[0]);
-
-  eeprom_write(233, m_lead_out[0]);
-
-  eeprom_write(237, motor_spd_cal[0]);
-
-  eeprom_write(239, m_cal_constant[0]);
-
-
-  eeprom_write(249, cam_repeat);
-  eeprom_write(250, cam_rpt_dly);
-
-  eeprom_write(252, ext_trig_pre_delay);
-  eeprom_write(256, ext_trig_pst_delay);
-  eeprom_write(260, exp_tm);
-  eeprom_write(264, gb_enabled);
-  eeprom_write(265, ui_invdir);
-  eeprom_write(266, cur_bkl);
-  eeprom_write(267, ir_remote);
-}
-
-
-// restore memory
-
-void restore_eeprom_memory() {
-
-  // read eeprom stored values back into RAM
-
-  eeprom_read(3, focus_tap_tm);
-  eeprom_read(5, post_delay_tm);
-  eeprom_read(7, focus_shutter);
-
-  eeprom_read(10, cam_max);
-  eeprom_read(16, m_diarev[0]);
-  eeprom_read(24, max_ipm[0]);
-  eeprom_read(32, m_rpm[0]);
-  eeprom_read(40, min_ipm[0]);
-  eeprom_read(48, min_spd[0]);
-  eeprom_read(50, m_min_pulse[0]);
-  eeprom_read(52, altio_dir);
-
-  eeprom_read(56, ui_motor_display);
-  eeprom_read(57, motor_sl_mod);
-  eeprom_read(58, lcd_dim_tm);
-  eeprom_read(60, blank_lcd);
-  eeprom_read(61, m_ramp_set[0]);
-  eeprom_read(63, m_maxsms[0]);
-  eeprom_read(67, cam_interval);
-
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[1][3][3][2] 
-  // 1 * 3 * 3 * 2 * 4 = 72
-
-  byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_read(71, *p, 72);
-
-  eeprom_read(217, input_type[0]);
-  eeprom_read(218, input_type[1]);
-
-  eeprom_read(219, ui_is_metric);
-
-  eeprom_read(229, m_lead_in[0]);
-  eeprom_read(233, m_lead_out[0]);
-
-  eeprom_read(237, motor_spd_cal[0]);
-
-  eeprom_read(239, m_cal_constant[0]);
-
-  eeprom_read(249, cam_repeat);
-  eeprom_read(250, cam_rpt_dly);
-
-  eeprom_read(252, ext_trig_pre_delay);
-  eeprom_read(256, ext_trig_pst_delay);
-
-  eeprom_read(260, exp_tm); // moved from position 1
-
-  eeprom_read(264, gb_enabled);
-  eeprom_read(265, ui_invdir);
-  eeprom_read(266, cur_bkl);
-  eeprom_read(267, ir_remote);
-  // handle restoring alt input states
-
-  if( input_type[0] != 0 )
-    altio_connect(0,input_type[0]);
-
-  if( input_type[1] != 0 )
-    altio_connect(1,input_type[1]);
-
-  // set lcd backlight to saved value
-  ui_set_backlight(cur_bkl);
-
-}
-
-
-
-void eeprom_versioning() {
-  // determine if eeprom version is correct 
-  // so we can automatically flush saved memory 
-  // when a new firmware is loaded 
-
-  unsigned int eeprom_ver = 0;
-  eeprom_read(247, eeprom_ver);
-
-  // wipe out any saved eeprom settings
-  if( eeprom_ver != FIRMWARE_VERSION ) {
-    eeprom_ver = FIRMWARE_VERSION;
-    eeprom_write(247, eeprom_ver);
-    // order of operations is important, this must line
-    // must happen after the eeprom_write function call, as
-    // it automatically updates the eeprom saved status
-    eeprom_saved(false);
-  }  
-
-
-}
-
-
diff --git a/DollyShield/bak/ds_motor.ino b/DollyShield/bak/ds_motor.ino
deleted file mode 100644
index b11ba3b..0000000
--- a/DollyShield/bak/ds_motor.ino
+++ /dev/null
@@ -1,528 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-/*
-
- ========================================
- Motor control functions
- ========================================
- 
- */
-
-
-void motor_speed_adjust(int val, boolean spd_floor ) {
-
-  byte c_speed = 0;
-  // val is expected to be between -255 and 255;
-
-  if( (int) m_speeds[0] + val >= 255 ) {
-    c_speed = 255;
-  }
-  else {
-    c_speed = (int) m_speeds[0] + val >= 0 ? m_speeds[0] + val : 0;
-    // do we need to floor the value at the min speed setting? (man control)
-    if( spd_floor ) 
-      c_speed = c_speed < min_spd[0] ? min_spd[0] : c_speed;
-  }
-
-  motor_set_speed(c_speed );   
-
-}
-
-void motor_control(boolean state) {
-
-  // turn motors on or off
-
-  if( ! state ) {
-    // set motors as not running
-
-    unsigned int ths_spd = m_speeds[0];
-
-    motor_set_speed( 0 );
-
-    m_speeds[0] = ths_spd;
-    mcur_spds[0] = ths_spd;
-
-    run_status &= B11101111;
-
-  }
-  else {
-    // set motors as running...
-    run_status |= B00010000;
-    if( mcur_spds[0] > 0 )
-      motor_set_speed(mcur_spds[0]);
-  }
-}
-
-
-
-void motor_set_speed( unsigned int m_speed ) {
-
-
-
-  m_speeds[0] = m_speed;
-  m_sms_tm[0] = 0;
-
-
-
-  if( ! motor_sl_mod && ! (ui_ctrl_flags & B00000100) ) {
-
-    // handle when in interleaved mode and not on
-    // manual control screen
-
-    float m_pct = ( (float) m_speed / (float) m_maxsms[0] );  
-
-    m_sms_tm[0] = 60000.0 * m_pct;
-
-    // calibrate
-    m_sms_tm[0] *= motor_cal_adjust(0,0,m_wasdir[0]);
-
-  }
-  else {
-
-    // normalize to max pwm speed
-    m_speed = m_speed > 255 ? 255 : m_speed;
-
-    m_speeds[0] = m_speed;
-  }
-
-
-  // do we need to go into pulsing mode?
-
-  if( m_speed > 0 && m_speed < min_spd[0]  ) {
-
-    motor_calc_pulse_len(m_speed, false);
-
-  } //      
-  else {
-    on_pct[0] = 0;
-  }
-
-
-
-
-  if( ! (run_status & B00010000)  ) {
-    // if disabled, do not move motor, but
-    // instead adjust stored speed
-    mcur_spds[0] = m_speed;
-    return;
-  }
-  else if( ! (ui_ctrl_flags & B00000100) && m_sms_tm[0] > 0 ) {
-    // just in case
-    digitalWriteFast(MOTOR0_P, LOW);
-    // return if we're in an SMS condition
-    // and not in manual mode
-    return;
-  }
-
-  // if we've made it this far, set motor pin
-  // to given analog speed
-
-  // only set analog speed if it exceeds min speed
-
-  if( m_speed >= min_spd[0] ) {
-    analogWrite(MOTOR0_P, m_speed);
-  }
-  else {
-    // just in case... switching down from 
-    // pwm to pulsed...
-    digitalWriteFast(MOTOR0_P,LOW);
-  }
-
-}
-
-void motor_calc_pulse_len(unsigned int m_speed, boolean ignore_cal) {
-  // for how many periods should the motor be on and
-  // off? (pulsing mode)     
-
-  float m_pct   = ( (float) m_speed / 255.0 );
-  float periods = 1333.0; // 25 times a second 
-
-  on_pct[0] = periods * m_pct; 
-  off_pct[0] = (float) (periods - on_pct[0]);
-
-  float cal_amt = motor_cal_adjust(1,m_speed, m_wasdir[0]);
-
-  // calibrate, if desired
-  if( ! ignore_cal && cal_amt != 1.0 )
-    off_pct[0] = ( (double) off_pct[0] * ( cal_amt * m_cal_constant[0] )  ); 
-
-  if(on_pct[0] < 1)
-    on_pct[0] = 1;
-
-  // make sure that we're on for a minimum amount of time
-
-  if ( on_pct[0] != 0 && on_pct[0] < m_min_pulse[0] ) {
-    // adjust so that off time is increased relative to on time
-    float diff = (float) m_min_pulse[0] / (float) on_pct[0];       
-    off_pct[0] = ((float) off_pct[0] * diff);
-    on_pct[0] = m_min_pulse[0];
-  }
-
-}
-
-void motor_dir(byte dir ) {
-
-  if( m_wasdir[0] == dir )
-    return;
-
-  // get current speed for the motor
-  byte ths_speed = m_speeds[0];
-
-
-
-  if( ths_speed > 0 ) {
-    // motor was already moving, need to stop
-    // and let motor settle before moving
-    // stop motor
-    motor_set_speed( 0 );
-    delay(100);    
-  }
-
-
-  digitalWriteFast(MOTOR0_DIR, dir);  
-  m_wasdir[0] = dir;
-  motor_set_speed( ths_speed );
-}
-
-
-float motor_calc_ipm(unsigned int spd, boolean ths_mode) {
-  // calculate ipm for a given speed and mode
-
-    // get max speed for either pulse or sms mode
-  // on calibration screen, always ch
-
-  float maxspd = ( ! ths_mode ) ? (float) m_maxsms[0] : 255.0;
-
-  // in manual mode, we're always in 0-255 mode
-  if( ui_ctrl_flags & B00000100 ) 
-    maxspd = 255.0;
-
-  float cur_ipm = (float) max_ipm[0] * ( (float) spd / (float) maxspd );      
-
-  return(cur_ipm);
-}
-
-
-void motor_update_dist(float rpm, float diarev ) {
-  // set distance settings when rpm or diarev change
-
-  max_ipm[0] = rpm * diarev;
-  min_spd[0] = 255 * ( min_ipm[0] / max_ipm[0] );
-  m_maxsms[0] = max_ipm[0] * 100;
-
-  eeprom_write(24, max_ipm[0]);
-  eeprom_write(48, min_spd[0]);
-  eeprom_write(63, m_maxsms[0]);
-
-}
-
-void motor_pulse() { //TODO
-
-  // this function is called by timer1 to pulse motors
-  // on and off in pulsing mode
-
-    if( ! timer_engaged )
-    return;
-
-  volatile static byte mstate[2] = {
-    0,0  };
-  volatile static unsigned long pulses[2]  = {
-    1,1  };
-
-  volatile static byte pos = 0;
-
-  pos++;
-
-
-  for( byte i = 0; i < MAX_MOTORS; i++ ) {
-    if( on_pct[i] > 0 ) {
-      // speed is below min cont. speed
-
-      if( ! mstate[i] ) {
-        if( pulses[i] < off_pct[i] ) {
-          pulses[i]++;
-          continue;
-        }
-        else {            
-          // set port value high for given motor
-          PORTD |= (B00100000 << i);  
-          //analogWrite(5, 165);
-          mstate[i] = 1;
-          pulses[i] = 1;
-        }
-      }
-      else {
-        if( pulses[i] < on_pct[i] ) {
-          pulses[i]++;
-          continue;
-        }
-        else {
-
-          // set port value low for given motor
-          //analogWrite(5, 0);
-          PORTD &= ( B11111111 ^ ( B00100000 << i ) ); 
-          mstate[i] = 0;
-          pulses[i] = 1;
-        }
-      } // end else not mstate...
-    }  // end if on_pct...
-  }  // end for
-
-}
-
-
-
-void run_motor_sms() {
-
-  analogWrite(MOTOR0_P, 255);
-
-} 
-
-void stop_motor_sms() {
-
-  MsTimer2::stop();
-
-  analogWrite(MOTOR0_P, 0);
-
-  motor_ran++;
-
-} 
-
-void motor_set_ramp( byte ramp) {
-  // set motor ramp value, adjust
-  // associated values
-
-
-
-
-  m_ramp_set[0]   = ramp > 255 ? 255 : ramp; //TODO: immer [0]
-
-  // calculate speed change per shot  
-  if( ramp > 0 ) {
-    m_ramp_shift[0] = (float) m_speeds[0] / ramp;
-
-    // if there's less than one step per jump,
-    // we need to skip shots between increases
-    // so determine how many shots to skip
-
-      if( m_ramp_shift[0] < 1 ) {
-      m_ramp_mod[0] = ramp / m_speeds[0];
-      m_ramp_mod[0] = m_ramp_mod[0] < 2 ? 2 : m_ramp_mod[0];
-      m_ramp_shift[0] = 1.0;
-    }
-    else {
-      m_ramp_mod[0] = 0;
-    }
-
-  }
-  else {
-    m_ramp_shift[0] = 0;
-    m_ramp_mod[0]   = 0;
-  }
-
-
-}  
-
-
-void motor_stop_all() {
-  // stop all motors
-
-  // disable pulsing interrupt if engaged
-  if( timer_engaged ) {
-    Timer1.detachInterrupt();
-    timer_engaged = false;
-  }
-
-  digitalWriteFast(MOTOR0_P, LOW);
-
-  motor_control(false);
-
-
-
-}
-
-
-float motor_cal_adjust(byte type, byte m_spd, byte dir) {
-
-
-
-  // simplistic for sms mode
-  if( type == 0 ) 
-    return(m_cal_array[0][m_angle[0]][0][dir]);
-
-  // determine which calibration position we fall
-  // into
-
-  byte pos = 0;
-
-  // if between two cal points, get position between them
-  byte cal_diff = motor_spd_cal[1] - motor_spd_cal[0];
-  byte hi_diff  = 255 - motor_spd_cal[1];
-
-  if ( m_spd > motor_spd_cal[0] && m_spd < motor_spd_cal[1] ) {
-    unsigned int diff = m_spd - motor_spd_cal[0];
-    float diff_pct = (float) diff / (float) cal_diff;
-    float ret = ( m_cal_array[0][m_angle[0]][2][dir] * diff_pct ) + ( m_cal_array[0][m_angle[0]][1][dir] * ( 1.0 - diff_pct ) );
-    return(ret);
-  }
-  else if( m_spd > motor_spd_cal[1] ) {
-    // between last cal point and max speed
-    unsigned int diff = m_spd - motor_spd_cal[1];
-    float diff_pct = (float) diff / (float) hi_diff;
-    float ret = m_cal_array[0][m_angle[0]][2][dir] - (m_cal_array[0][m_angle[0]][2][dir] * diff_pct);
-    return(ret);
-  }
-  else if( m_spd <= motor_spd_cal[0] ) {
-    pos = 1;
-  }
-  else if( m_spd == motor_spd_cal[1] ) {
-    pos = 2;
-  }
-  else {
-    return(1.0);
-  }
-
-  return(m_cal_array[0][m_angle[0]][pos][dir]);
-}
-
-
-void motor_run_pulsing() {
-
-  // start pulsing motor movement
-
-  if( ! timer_engaged ) {
-
-    // we use timer1, which disables pwm on
-    // lcd bkl pin
-    if( cur_bkl > 0 ) {
-      digitalWriteFast(LCD_BKL, HIGH);
-    }
-    else {
-      digitalWriteFast(LCD_BKL, LOW);
-    }
-
-    digitalWriteFast(MOTOR0_P, LOW);
-
-
-    Timer1.initialize(MP_PERIOD);
-    Timer1.attachInterrupt(motor_pulse);
-    timer_engaged = true;
-    timer_used = true;
-
-  }
-}
-
-void motor_execute_ramp_changes() {
-
-  // check for ramping, and ramp up or down as needed
-
-  // no ramp, go to next motor
-  if( m_ramp_set[0] == 0 )
-    return;
-
-  // handle lead-in
-  if( shots <= m_lead_in[0] ) {
-    motor_set_speed(0); 
-    return;  
-  }
-
-  // ramp up?
-  if( m_ramp_set[0] >= ( shots - m_lead_in[0]) ) {
-    // if ramping less than once per shot 
-    if( m_ramp_mod[0] > 0 && ( shots - m_lead_in[0] ) % m_ramp_mod[0] == 0 ) {
-      motor_set_speed(m_speeds[0] + 1);
-    }
-    else if( m_ramp_mod[0] == 0 ) {  
-      motor_set_speed((m_ramp_shift[0] * (shots - m_lead_in[0]) ) );
-    }
-  }
-  else if( (cam_max - shots - m_lead_out[0]) <= m_ramp_set[0] ) {
-    // ramping down, it seems
-    if( m_ramp_mod[0] > 0 && (cam_max - shots - m_lead_out[0]) % m_ramp_mod[0] == 0 ) {
-      byte m_spd = m_speeds[0] > 0 ? m_speeds[0] - 1 : 0;
-      motor_set_speed(m_spd);
-    }
-    else if( m_ramp_mod[0] == 0 ) {  
-      motor_set_speed(m_ramp_shift[0] * (cam_max - shots - m_lead_out[0]) );
-    }
-  }
-
-
-}
-
-
-void motor_run_calibrate(byte which, unsigned int mspd, byte dir) {
-
-
-  byte cur_dir = m_wasdir[0];
-  motor_dir(dir);
-
-  if( which == 1 ) {
-    float m_pct = ( (float) mspd / (float) m_maxsms[0] );  
-    unsigned int run_tm = 60000.0 * m_pct;
-
-    motor_ran = 0;
-
-    run_motor_sms();
-    MsTimer2::set(run_tm, stop_motor_sms);
-    MsTimer2::start();
-
-    while( ! motor_ran )
-      continue;
-
-    return;
-  }
-  else {
-
-    byte was_on_pct = on_pct[0];
-    byte was_off_pct = off_pct[0];     
-
-    motor_calc_pulse_len(mspd, true);
-
-    unsigned long run_tm = millis();
-
-    motor_run_pulsing();
-
-    // main loop is ~ 10% slower than calibration loop
-    while( millis() - run_tm < 58000 ) {
-      // introduce timing block delay similar to main loop
-      int foo = analogRead(BUT_PIN);
-    }
-
-    motor_stop_all();
-
-    on_pct[0]  = was_on_pct;
-    off_pct[0] = was_off_pct;
-
-  }
-
-  motor_dir(cur_dir);
-
-}
-
-
-
-
-
-
-
diff --git a/DollyShield/bak/ds_ui.ino b/DollyShield/bak/ds_ui.ino
deleted file mode 100644
index 38cd4a3..0000000
--- a/DollyShield/bak/ds_ui.ino
+++ /dev/null
@@ -1,953 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-
-/*
-
- ========================================
- Core UI functions
- ========================================
- 
- */
-
-
-void init_user_interface() {
-
-  pinMode(LCD_BKL, OUTPUT);
-
-  // turn on lcd backlight
-  analogWrite(LCD_BKL, 255);
-
-  // init lcd to 16x2 display
-  lcd.begin(16, 2);
-  lcd.setCursor(0,0);
-
-  // clear and turn on autoscroll
-  lcd.clear();
-  //lcd.autoscroll();
-
-  // banner
-
-    lcd.print("(c) 2012 DP");
-
-  lcd.setCursor(5,1);
-  lcd.print("mod. by FZ");
-
-  delay(750);
-
-  lcd.clear(); 
-
-  lcd.setCursor(0,0); 
-  lcd.print("MX2 El Cheapo");
-  lcd.setCursor(3,1);
-  lcd.print("Ver 0.92.01");
-
-  // setup button input
-
-    pinMode(BUT_PIN, INPUT);   
-  // enable internal pull-up
-  digitalWriteFast(BUT_PIN, HIGH);
-
-
-  // set the update screen flag (draw main
-  // screen)
-  ui_ctrl_flags |= B10000000;
-
-  delay(3000);
-
-}
-
-
-void check_user_interface() {
-
-
-  // turn off/on lcd backlight if needed
-  if( (ui_ctrl_flags & B00000010) && (input_last_tm < (millis() - (lcd_dim_tm * 1000))) ) {
-
-    ui_ctrl_flags &= B11111101;
-
-    if( blank_lcd ) 
-      lcd.noDisplay();
-
-    digitalWrite(LCD_BKL, 0);
-  }
-  else if( (! (ui_ctrl_flags & B00000010)) && (input_last_tm > millis() - (lcd_dim_tm * 1000)) ) {
-    ui_ctrl_flags |= B00000010;
-
-    lcd.display();
-    analogWrite(LCD_BKL, cur_bkl);
-  }
-
-  // if we're set to update the display
-  // (on-demand or once a second when not
-  // in a menu)
-  if( ui_ctrl_flags & B10000000 ||
-    ( (ui_update_tm < millis() - 1000) && ! (ui_ctrl_flags & B01000000) ) ) {
-
-    // determine whether to show home or manual screen      
-    if( ! ( ui_ctrl_flags & B00000100 ) ) {
-      show_home();
-    }
-
-
-    else {
-      show_manual();
-    }
-
-    ui_ctrl_flags &= B01111111;
-    ui_update_tm = millis();
-  }
-
-  byte held = ui_button_check();
-
-  // make sure to turn off motor if in manual
-  // control and no button is held
-  if( ui_ctrl_flags & B00000100 && held == false && run_status & B00010000 )
-    motor_control( false);
-
-
-}
-
-
-byte ui_button_check() {
-
-  static byte hold_but_cnt = 0;
-
-  get_button_pressed();
-
-  boolean held = false;
-
-  for( byte i = BUT0; i <= BUT4; i++) {
-    byte bt_press = is_button_press( i );
-
-    if( bt_press == 0 )
-      continue;
-
-    if(  bt_press == 1 && millis() - input_last_tm > HOLD_BUT_MS ) {
-      // button is pressed        
-
-      hold_but_cnt  = 0;
-      inp_val_mult  = 1;
-      input_last_tm = millis();
-      handle_input(i, false);
-
-    }
-    else if( bt_press == 2 ) {
-      held = true;
-      // button being held
-      if( hold_but_tm <= millis() - HOLD_BUT_MS) {
-        hold_but_tm   = millis();
-        input_last_tm = millis();
-
-        handle_input(i, true);
-
-        hold_but_cnt++;
-
-        if( hold_but_cnt >= 8 ) {
-          inp_val_mult = inp_val_mult >= 1000 ? 1000 : inp_val_mult * HOLD_BUT_VALINC;
-          hold_but_cnt = 0;
-        }
-
-      }
-
-    } // end else if button press state == 2
-
-  } // end for loop
-
-  return(held);
-
-}
-
-
-void get_button_pressed() {
-  // see which buttons are pressed
-  // buttons are on one analog pin, the value
-  // determines which button, if any is pressed
-
-    // read analog input
-  int val_read = analogRead(BUT_PIN - 14);
-
-  // don't let it flip in a single read
-  if( abs(last_but_rd - val_read) > BUT_THRESH ) {
-    last_but_rd = val_read; 
-    button_pressed = 0;
-    return;
-  }
-
-  if( val_read > (BUT0_VAL - BUT_THRESH) && val_read < (BUT0_VAL + BUT_THRESH) ) {
-    button_pressed = BUT0;
-  }
-  else if( val_read > (BUT1_VAL - BUT_THRESH) && val_read < (BUT1_VAL + BUT_THRESH) ) {
-    button_pressed = BUT1;
-  }
-  else if( val_read > (BUT2_VAL - BUT_THRESH) && val_read < (BUT2_VAL + BUT_THRESH) ) {
-    button_pressed = BUT2;
-  }
-  else if( val_read > (BUT3_VAL - BUT_THRESH) && val_read < (BUT3_VAL + BUT_THRESH) ) {
-    button_pressed = BUT3;
-  }
-  else if( val_read > (BUT4_VAL - BUT_THRESH) && val_read < (BUT4_VAL + BUT_THRESH) ) {
-    button_pressed = BUT4;
-  }
-  else {
-    button_pressed = 0;
-  }
-
-
-}
-
-
-byte is_button_press(byte button) {
-
-  // determine if the given button was
-  // pressed, held, or is neither
-
-  static byte button_was = 0;
-
-  // if the button is set as 'active'
-  if( button_pressed == button ) {
-    // if we have already registered a press without
-    // registering a non-press
-    if( button_was ) {
-      // increase 'skip hold count'
-      return(2);
-    }
-    // button was not previous pressed...
-    button_was = button;
-    hold_but_tm = millis();
-    return(1);
-  }
-
-  // if button set as inactive
-
-  // if button was previously set as active,
-  // register previous state as inactive
-  if( button_was == button ) {
-    button_was = 0;
-    // set button as not currently pressed
-    button_pressed = 0;
-  }
-
-  return(0);
-}
-
-
-byte get_menu( byte mnu, byte pos ) {
-
-  // where is our target menu when 
-  // mnu.pos is pressed?
-
-
-  switch(mnu) {
-  case 0:
-
-    if( pos <= 5 )
-      return( pos + 1 );
-
-    break;
-
-  case 1:
-    // manual control is special return code
-    return(254);
-
-  default:
-    break;        
-  }
-
-
-
-  // default is 'no target', an input value
-  return(255);
-
-}
-
-/*
-   handle user input
- */
-
-void handle_input( byte button, boolean held ) {
-
-  // do what needs to be done when whatever
-  // button is hit
-
-  if( button == BUT_CT ) {
-    // call center button function
-    ui_button_center(held);    
-  }
-
-  else if( button == BUT_DN ) {
-    ui_button_down(held);
-  }
-
-  else if( button == BUT_UP ) {
-    ui_button_up(held);
-  }
-
-  else if( button == BUT_RT ) {
-    ui_button_rt(held);
-  }  
-  else if( button == BUT_LT ) {
-    ui_button_lt(held);
-  }
-
-
-  return;
-
-
-}
-
-
-// button handlers
-
-
-void ui_button_center( boolean held ) {
-  // center button
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B01000000 ) {
-      // completed calibrating
-      ui_cal_scrn_flags &= B00111111;
-      show_calibrate();
-      return;
-    }  
-    else if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating input
-
-      if( held == true )
-        return;
-
-      m_cal_done = true;
-      return;
-    }
-
-    execute_calibrate();
-    return;
-  }
-
-
-  if( main_scr_input > 0 ) {
-    // make sure to abort main screen input
-    lcd.noBlink();
-    main_scr_input = 0;
-  }
-
-
-  // if in manual control
-  if( ui_ctrl_flags & B00000100  ) {
-    // clear out manual ctrl flag
-    ui_ctrl_flags &= B11111011;
-
-    // resume back to setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 1; // show manual menu again
-    draw_menu(0, false);
-    return;
-  }
-
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // not in any setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 0;
-    draw_menu(0,false);
-  }
-  else {
-
-
-    // in a setup menu, find
-    // the next menu to go to
-
-    // calibration, don't do anything else
-    if (cur_menu == 2 && cur_pos == 5 ) {
-      get_value(cur_menu, cur_pos, false);
-      return;
-    }
-
-
-    byte new_menu = get_menu(cur_menu, cur_pos);
-
-    // if drawing motor manual screen...
-
-    if( new_menu == 254 ) {
-      get_value(cur_menu, cur_pos, false);
-      return;
-    }
-
-
-    if( new_menu == 255 && ! (ui_ctrl_flags & B00100000) )  {
-      // this is not a menu, but an input of some
-      // sort
-
-      draw_menu(3,true);
-      return;
-    }
-    else if( ui_ctrl_flags & B00100000 ) {
-      // exiting out of value entry (save...)
-      // go to previous menu
-
-      // clear the cursor position
-      cur_inp_pos = 0;
-
-      // read value back from input
-      get_value(cur_menu, cur_pos, true);
-
-      // reset the float tenths (vs 100ths) parameter
-      ui_float_tenths = false;
-
-      // clear in value setting flag
-      // and the flag indicating that
-      // we've already displayed this value
-      ui_ctrl_flags &= B11001111;
-      draw_menu(0,false);
-    }
-    else {
-
-      // entering another menu
-
-      // record the last menu we were at
-      push_menu(cur_menu);
-
-      // clear in value setting flag
-      ui_ctrl_flags &= B11011111;
-
-      // set menu to new menu
-      cur_menu = new_menu;
-      draw_menu(0,false);
-    }
-
-
-  }
-}
-
-
-void ui_button_down( boolean held ) {
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(false);
-      update_cal_screen();
-      return;
-    }
-
-    m_cur_cal = m_cur_cal > 0 ? m_cur_cal - 1 : 0;
-    show_calibrate();
-
-    return;
-  }
-
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust( -1 * inp_val_mult, true);
-    show_manual();
-    return;
-  }
-
-  // if not currently in setup menus, or
-  // modifying a main screen value
-  if( ! (ui_ctrl_flags & B01000000) & main_scr_input == 0 )
-    return;
-
-  if( main_scr_input > 0 ) {
-    move_val(false);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(false);
-    draw_menu(3,true);
-  }
-  else {
-    // moving to next menu item
-    draw_menu(2,false);
-  }
-
-}
-
-void ui_button_up( boolean held ) {
-
-  // on calibration screen
-  if( ui_ctrl_flags & B00000001 ) {
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(true);
-      update_cal_screen();
-      return;
-    }
-
-    m_cur_cal = m_cur_cal > 1 ? 2 : m_cur_cal + 1;
-    show_calibrate();    
-    return;
-  }
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust(1 + inp_val_mult, true);
-    show_manual();
-    return;
-  }
-  
-  // if not currently in setup menus, or
-  // modifying a main screen value
-  if( ! (ui_ctrl_flags & B01000000) & main_scr_input == 0 )
-    return;
-
-  if( main_scr_input > 0 ) {
-    move_val(true);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(true);
-    draw_menu(3,true);
-  }
-  else {
-    draw_menu(1,false);
-  }
-
-}
-
-void ui_button_rt( boolean held ) {
-
-  // clear out calibration screen value, if
-  // set
-  if( ui_ctrl_flags & B00000001 )
-    ui_ctrl_flags &= B11111110;
-
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {
-      // change motor direction
-      motor_dir(false);
-      if( ! (run_status & B00010000) )
-        motor_control(true);
-    }
-    show_manual();
-
-
-    return;
-  }  
-
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, rt switches value we can
-    // adjust
-    main_screen_select(true);
-    return;
-  } 
-
-}
-
-
-void ui_button_lt(boolean held) {
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {        
-      // change motor direction
-      motor_dir(true);
-      // get motor moving (if not already)
-      if( ! (run_status & B00010000) )
-        motor_control(true);
-      show_manual();
-    }
-    return;
-  }  
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, lt switches value we can
-    // adjust
-    main_screen_select(false);
-    return;
-  }
-
-  // left button
-  if( ! (ui_ctrl_flags & B01000000 || ui_ctrl_flags & B00100000 ))
-    return;
-
-  if( ui_ctrl_flags & B00100000 ) {
-    // we're in a value entry mode.  Exit
-    // entry without saving the value
-
-    // clear in value setting flag
-    // and the flag indicating that
-    // we've already displayed this value
-    ui_ctrl_flags &= B11001111;        
-    // reset the float tenths (vs 100ths) parameter
-    ui_float_tenths = false;
-
-    draw_menu(0,false);
-    return;
-  }
-
-  // draw previous menu
-
-  if( cur_menu == 0 ) { 
-    // we're at the highest menu, back to main screen 
-    cur_pos = 0;  
-    // clear setup flag
-    // indicate display needs updating
-    ui_ctrl_flags &= B10111111;
-    ui_ctrl_flags |= B10000000;
-    // clear out list of menus
-    flush_menu();
-  }
-  else {
-    // a parent menu can be drawn
-    cur_menu = pop_menu();
-    draw_menu(0,false);
-  }
-
-}
-
-
-/* 
- Draw screens
- */
-
-
-void draw_menu(byte dir, boolean value_only) {
-
-
-  // turn off blinking, if on...
-  lcd.noBlink();
-
-  boolean draw_all = false;
-
-  // determine the direction we are going, up/down (1/2),
-  // draw all (but don't move position) (3), and draw
-  // new menu from top (0)
-
-  if( dir == 2 ) {
-    // down
-    cur_pos++;
-    if( cur_pos > cur_pos_sel ) {
-      lcd.clear();
-      draw_all = true;
-    }
-  }    
-  else if( dir == 1 ) {
-    // up
-    cur_pos = cur_pos == 0 ? 0 : cur_pos - 1;
-
-    if( cur_pos < cur_pos_sel ) {
-      lcd.clear();
-      draw_all = true;
-    }
-  }
-  else if( dir == 3 ) {
-    // draw all (no move)
-    draw_all = true;
-  }
-  else {
-    // draw new menu (from top)
-    cur_pos = 0;
-    draw_all = true;
-  }
-
-  // don't overrun the memory locations for this menu
-
-  cur_pos = cur_pos > max_menu[cur_menu] ? max_menu[cur_menu] : cur_pos;
-
-  switch( cur_menu ) {
-
-  case 0:
-
-    draw_values(menu_str, draw_all, value_only);
-    break;
-
-  case 1:
-
-    draw_values(man_str, draw_all, value_only);
-    break;
-
-  case 2:
-
-    draw_values(axis0_str, draw_all, value_only);
-    break;
-
-  case 3:
-
-    draw_values(cam_str, draw_all, value_only);
-    break;
-
-  case 4:
-
-    draw_values(set_str, draw_all, value_only);
-    break;
-
-  default: 
-    return;  
-  }
-
-
-}
-
-
-void draw_values(const char *these[], boolean draw_all, boolean value_only) {
-
-  if( draw_all == true ) {
-
-    // must draw the whole display
-    lcd.clear();
-    // clear out lcd buffer
-
-      memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
-
-    // draw first option
-    lcd.noCursor();
-    lcd.setCursor(0,0);
-    cur_pos_sel = cur_pos;
-
-    strcpy_P(lcd_buf, (char*) pgm_read_word(&(these[cur_pos])));
-    lcd.print("> ");
-    lcd.print(lcd_buf);
-    lcd.setCursor(0,1);
-
-    // if we're not displaying only a value, and there's
-    // another menu entry to display -- display it on the 
-    // second line..
-
-    if( ! value_only ) {
-      if( cur_pos + 1 <= max_menu[cur_menu] ) {
-        cur_pos_sel = cur_pos + 1;
-        memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
-        strcpy_P(lcd_buf, (char*)pgm_read_word(&(these[cur_pos + 1])));
-        lcd.print("  ");
-        lcd.print(lcd_buf);
-      }
-      // clear out in value entry setting, if set
-      ui_ctrl_flags &= B11011111;
-
-    }
-    else {
-
-      // display the value of the current entry
-      ui_ctrl_flags |= B00100000;
-
-
-      if(! ( ui_ctrl_flags & B00010000 ) ) {
-        // have just drawn this value
-
-        // place value from variable into
-        // temporary buffer
-        get_value(cur_menu, cur_pos, false);
-
-        ui_ctrl_flags |= B00010000;
-      }
-
-
-
-      // display the correct current
-      // temporary input value
-
-      if( ui_type_flags2 & B10000000 ) {
-        // for alt i/o inputs
-
-        if( cur_inp_long == 0 ) {
-          lcd.print("Disabled");
-        }
-        else if( cur_inp_long == 1 ) {
-          lcd.print("Start");
-        }
-        else if( cur_inp_long == 2 ) {
-          lcd.print("Stop");
-        }
-        else if( cur_inp_long == 3 ) {
-          lcd.print("Toggle");
-        }
-        else if( cur_inp_long == 4 ) {
-          lcd.print("Ext. Interval.");
-        }
-        else if( cur_inp_long == 5 ) {
-          lcd.print("Out Before");
-        }
-        else if( cur_inp_long == 6 ){
-          lcd.print("Out After");
-        }
-        else if(cur_inp_long == 7 ) {
-          lcd.print("Out Both");
-        }
-        else {
-          lcd.print("Change Dir");
-        }
-        return;
-      }
-      else if( ui_type_flags2 & B01000000 ) {
-        // cal speed inputs in gobal set menu
-        display_spd_ipm(cur_inp_long);
-        return;
-      }
-
-      switch(ui_type_flags) {
-      case B10000000:
-        lcd.print(cur_inp_float, (byte) 2);
-        break;
-      case B01000000:
-        if (cur_inp_bool == true) {
-          lcd.print("On");
-        } 
-        else {
-          lcd.print("Off");
-        }
-        break;
-      case B00100000:
-        if (cur_inp_bool == true) {
-          lcd.print("Up");
-        } 
-        else {
-          lcd.print("Dn");
-        }
-        break;
-      case B00010000:
-        if (cur_inp_bool == true) {
-          lcd.print("Rt");
-        } 
-        else {
-          lcd.print("Lt");
-        }
-        break;
-      case B00001000:
-        if (cur_inp_bool == true) {
-          lcd.print("IPM");
-        } 
-        else {
-          lcd.print("PCT");
-        }
-        break;
-      case B00000100:
-        if (cur_inp_bool == true) {
-          lcd.print("Pulse");
-        } 
-        else {
-          lcd.print("Interleave");
-        }
-        break;
-      case B00000010:
-        if (cur_inp_bool == true) {
-          lcd.print("Rotary");
-        } 
-        else {
-          lcd.print("Linear");
-        }
-        break;
-      case B00000001:
-        if( cur_inp_long == 0 ) {
-          lcd.print(0,DEC);
-        }
-        else if( cur_inp_long == 1 ) {
-          lcd.print(45,DEC);
-        }
-        else {
-          lcd.print(90,DEC);
-        }
-        break;
-      default:
-        lcd.print((unsigned long)cur_inp_long);
-        return;
-      }
-
-
-
-    }
-
-  } // end if( draw_all == true
-
-  else {
-
-    // do not need to re-draw the whole screen
-
-    // move cursor down if we're not in
-    // a value input screen
-    if( ! (ui_ctrl_flags & B00100000) ) {
-      lcd.setCursor(0,0);
-      lcd.print(' ');
-      lcd.setCursor(0,1);
-      lcd.print('>');
-    }
-
-  }
-}
-
-
-void ui_set_backlight(byte value) {
-
-  // make sure to not use pwm on lcd bkl pin
-  // if timer1 has been used at some point
-  if( ! timer_used ) {
-    analogWrite(LCD_BKL, cur_bkl);
-  }
-  else {
-    if( cur_bkl > 0 ) {
-      digitalWriteFast(LCD_BKL, HIGH);
-    }
-    else {
-      digitalWriteFast(LCD_BKL, LOW);
-    }
-  }
-}
-
-/* 
- 
- Menu history functions
- 
- */
-
-void push_menu(byte this_menu) { 
-  // push the given entry to the end of the list
-  for( byte i = 0; i < sizeof(hist_menu) / sizeof(hist_menu[0]); i++) {
-    if( hist_menu[i] == 0 ) {
-      hist_menu[i] = this_menu;
-    }
-  }
-}
-
-byte pop_menu() {
-  byte bk_menu = 0;
-  for( byte i = sizeof(hist_menu) / sizeof(hist_menu[0]); i > 0 ; i--) {
-    if( hist_menu[i-1] != 0 ) {
-      bk_menu = hist_menu[i-1];
-      hist_menu[i-1] = 0;
-    }
-  }
-  return(bk_menu);
-}
-
-void flush_menu() {
-  memset(hist_menu, 0, sizeof(hist_menu) / sizeof(hist_menu[0]));
-}
-
-
-
diff --git a/DollyShield/bak/ds_ui.ino6442346302586743093.tmp b/DollyShield/bak/ds_ui.ino6442346302586743093.tmp
deleted file mode 100644
index 6f92570..0000000
--- a/DollyShield/bak/ds_ui.ino6442346302586743093.tmp
+++ /dev/null
@@ -1,956 +0,0 @@
-
-
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-
-/*
-
- ========================================
- Core UI functions
- ========================================
- 
- */
-
-
-void init_user_interface() {
-
-  pinMode(LCD_BKL, OUTPUT);
-
-  // turn on lcd backlight
-  analogWrite(LCD_BKL, 255);
-
-  // init lcd to 16x2 display
-  lcd.begin(16, 2);
-  lcd.setCursor(0,0);
-
-  // clear and turn on autoscroll
-  lcd.clear();
-  //lcd.autoscroll();
-
-  // banner
-
-    lcd.print("(c) 2012 DP");
-
-  lcd.setCursor(5,1);
-  lcd.print("mod. by FZ");
-
-  delay(750);
-
-  lcd.clear(); 
-
-  lcd.setCursor(0,0); 
-  lcd.print("MX2 El Cheapo");
-  lcd.setCursor(3,1);
-  lcd.print("Ver 0.92.01");
-
-  // setup button input
-
-    pinMode(BUT_PIN, INPUT);   
-  // enable internal pull-up
-  digitalWriteFast(BUT_PIN, HIGH);
-
-
-  // set the update screen flag (draw main
-  // screen)
-  ui_ctrl_flags |= B10000000;
-
-  delay(3000);
-
-}
-
-
-void check_user_interface() {
-
-
-  // turn off/on lcd backlight if needed
-  if( ui_ctrl_flags & B00000010 && input_last_tm < millis() - (lcd_dim_tm * 1000) ) {
-
-    ui_ctrl_flags &= B11111101;
-
-    if( blank_lcd ) 
-      lcd.noDisplay();
-
-    digitalWriteFast(LCD_BKL, LOW);
-  }
-  else if( ! (ui_ctrl_flags & B00000010) && input_last_tm > millis() - (lcd_dim_tm * 1000) ) {
-    ui_ctrl_flags |= B00000010;
-
-    lcd.display();
-
-    analogWrite(LCD_BKL, cur_bkl);
-  }
-
-  // if we're set to update the display
-  // (on-demand or once a second when not
-  // in a menu)
-  if( ui_ctrl_flags & B10000000 ||
-    ( (ui_update_tm < millis() - 1000) && ! (ui_ctrl_flags & B01000000) ) ) {
-
-    // determine whether to show home or manual screen      
-    if( ! ( ui_ctrl_flags & B00000100 ) ) {
-      show_home();
-    }
-
-
-    else {
-      show_manual();
-    }
-
-    ui_ctrl_flags &= B01111111;
-    ui_update_tm = millis();
-  }
-
-  byte held = ui_button_check();
-
-  // make sure to turn off motor if in manual
-  // control and no button is held
-  if( ui_ctrl_flags & B00000100 && held == false && run_status & B00010000 )
-    motor_control( false);
-
-
-}
-
-
-byte ui_button_check() {
-
-  static byte hold_but_cnt = 0;
-
-  get_button_pressed();
-
-  boolean held = false;
-
-  for( byte i = BUT0; i <= BUT4; i++) {
-    byte bt_press = is_button_press( i );
-
-    if( bt_press == 0 )
-      continue;
-
-    if(  bt_press == 1 && millis() - input_last_tm > HOLD_BUT_MS ) {
-      // button is pressed        
-
-      hold_but_cnt  = 0;
-      inp_val_mult  = 1;
-      input_last_tm = millis();
-      handle_input(i, false);
-
-    }
-    else if( bt_press == 2 ) {
-      held = true;
-      // button being held
-      if( hold_but_tm <= millis() - HOLD_BUT_MS) {
-        hold_but_tm   = millis();
-        input_last_tm = millis();
-
-        handle_input(i, true);
-
-        hold_but_cnt++;
-
-        if( hold_but_cnt >= 8 ) {
-          inp_val_mult = inp_val_mult >= 1000 ? 1000 : inp_val_mult * HOLD_BUT_VALINC;
-          hold_but_cnt = 0;
-        }
-
-      }
-
-    } // end else if button press state == 2
-
-  } // end for loop
-
-  return(held);
-
-}
-
-
-void get_button_pressed() {
-  // see which buttons are pressed
-  // buttons are on one analog pin, the value
-  // determines which button, if any is pressed
-
-    // read analog input
-  int val_read = analogRead(BUT_PIN - 14);
-
-  // don't let it flip in a single read
-  if( abs(last_but_rd - val_read) > BUT_THRESH ) {
-    last_but_rd = val_read; 
-    button_pressed = 0;
-    return;
-  }
-
-  if( val_read > (BUT0_VAL - BUT_THRESH) && val_read < (BUT0_VAL + BUT_THRESH) ) {
-    button_pressed = BUT0;
-  }
-  else if( val_read > (BUT1_VAL - BUT_THRESH) && val_read < (BUT1_VAL + BUT_THRESH) ) {
-    button_pressed = BUT1;
-  }
-  else if( val_read > (BUT2_VAL - BUT_THRESH) && val_read < (BUT2_VAL + BUT_THRESH) ) {
-    button_pressed = BUT2;
-  }
-  else if( val_read > (BUT3_VAL - BUT_THRESH) && val_read < (BUT3_VAL + BUT_THRESH) ) {
-    button_pressed = BUT3;
-  }
-  else if( val_read > (BUT4_VAL - BUT_THRESH) && val_read < (BUT4_VAL + BUT_THRESH) ) {
-    button_pressed = BUT4;
-  }
-  else {
-    button_pressed = 0;
-  }
-
-
-}
-
-
-byte is_button_press(byte button) {
-
-  // determine if the given button was
-  // pressed, held, or is neither
-
-  static byte button_was = 0;
-
-  // if the button is set as 'active'
-  if( button_pressed == button ) {
-    // if we have already registered a press without
-    // registering a non-press
-    if( button_was ) {
-      // increase 'skip hold count'
-      return(2);
-    }
-    // button was not previous pressed...
-    button_was = button;
-    hold_but_tm = millis();
-    return(1);
-  }
-
-  // if button set as inactive
-
-  // if button was previously set as active,
-  // register previous state as inactive
-  if( button_was == button ) {
-    button_was = 0;
-    // set button as not currently pressed
-    button_pressed = 0;
-  }
-
-  return(0);
-}
-
-
-byte get_menu( byte mnu, byte pos ) {
-
-  // where is our target menu when 
-  // mnu.pos is pressed?
-
-
-  switch(mnu) {
-  case 0:
-
-    if( pos <= 5 )
-      return( pos + 1 );
-
-    break;
-
-  case 1:
-    // manual control is special return code
-    return(254);
-
-  default:
-    break;        
-  }
-
-
-
-  // default is 'no target', an input value
-  return(255);
-
-}
-
-/*
-   handle user input
- */
-
-void handle_input( byte button, boolean held ) {
-
-  // do what needs to be done when whatever
-  // button is hit
-
-  if( button == BUT_CT ) {
-    // call center button function
-    ui_button_center(held);    
-  }
-
-  else if( button == BUT_DN ) {
-    ui_button_down(held);
-  }
-
-  else if( button == BUT_UP ) {
-    ui_button_up(held);
-  }
-
-  else if( button == BUT_RT ) {
-    ui_button_rt(held);
-  }  
-  else if( button == BUT_LT ) {
-    ui_button_lt(held);
-  }
-
-
-  return;
-
-
-}
-
-
-// button handlers
-
-
-void ui_button_center( boolean held ) {
-  // center button
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B01000000 ) {
-      // completed calibrating
-      ui_cal_scrn_flags &= B00111111;
-      show_calibrate();
-      return;
-    }  
-    else if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating input
-
-      if( held == true )
-        return;
-
-      m_cal_done = true;
-      return;
-    }
-
-    execute_calibrate();
-    return;
-  }
-
-
-  if( main_scr_input > 0 ) {
-    // make sure to abort main screen input
-    lcd.noBlink();
-    main_scr_input = 0;
-  }
-
-
-  // if in manual control
-  if( ui_ctrl_flags & B00000100  ) {
-    // clear out manual ctrl flag
-    ui_ctrl_flags &= B11111011;
-
-    // resume back to setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 1; // show manual menu again
-    draw_menu(0, false);
-    return;
-  }
-
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // not in any setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 0;
-    draw_menu(0,false);
-  }
-  else {
-
-
-    // in a setup menu, find
-    // the next menu to go to
-
-    // calibration, don't do anything else
-    if (cur_menu == 2 && cur_pos == 5 ) {
-      get_value(cur_menu, cur_pos, false);
-      return;
-    }
-
-
-    byte new_menu = get_menu(cur_menu, cur_pos);
-
-    // if drawing motor manual screen...
-
-    if( new_menu == 254 ) {
-      get_value(cur_menu, cur_pos, false);
-      return;
-    }
-
-
-    if( new_menu == 255 && ! (ui_ctrl_flags & B00100000) )  {
-      // this is not a menu, but an input of some
-      // sort
-
-      draw_menu(3,true);
-      return;
-    }
-    else if( ui_ctrl_flags & B00100000 ) {
-      // exiting out of value entry (save...)
-      // go to previous menu
-
-      // clear the cursor position
-      cur_inp_pos = 0;
-
-      // read value back from input
-      get_value(cur_menu, cur_pos, true);
-
-      // reset the float tenths (vs 100ths) parameter
-      ui_float_tenths = false;
-
-      // clear in value setting flag
-      // and the flag indicating that
-      // we've already displayed this value
-      ui_ctrl_flags &= B11001111;
-      draw_menu(0,false);
-    }
-    else {
-
-      // entering another menu
-
-      // record the last menu we were at
-      push_menu(cur_menu);
-
-      // clear in value setting flag
-      ui_ctrl_flags &= B11011111;
-
-      // set menu to new menu
-      cur_menu = new_menu;
-      draw_menu(0,false);
-    }
-
-
-  }
-}
-
-
-void ui_button_down( boolean held ) {
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(false);
-      update_cal_screen();
-      return;
-    }
-
-    m_cur_cal = m_cur_cal > 0 ? m_cur_cal - 1 : 0;
-    show_calibrate();
-
-    return;
-  }
-
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust( -1 * inp_val_mult, true);
-    show_manual();
-    return;
-  }
-
-  // if not currently in setup menus, or
-  // modifying a main screen value
-  if( ! (ui_ctrl_flags & B01000000) & main_scr_input == 0 )
-    return;
-
-  if( main_scr_input > 0 ) {
-    move_val(false);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(false);
-    draw_menu(3,true);
-  }
-  else {
-    // moving to next menu item
-    draw_menu(2,false);
-  }
-
-}
-
-void ui_button_up( boolean held ) {
-
-  // on calibration screen
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(true);
-      update_cal_screen();
-      return;
-    }
-
-    m_cur_cal = m_cur_cal > 1 ? 2 : m_cur_cal + 1;
-    show_calibrate();
-
-    return;
-  }
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust(1 + inp_val_mult, true);
-    show_manual();
-    return;
-  }
-
-
-
-  if( main_scr_input > 0 ) {
-
-    move_val(true);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(true);
-    draw_menu(3,true);
-  }
-  else {
-    draw_menu(1,false);
-  }
-
-}
-
-void ui_button_rt( boolean held ) {
-
-  // clear out calibration screen value, if
-  // set
-  if( ui_ctrl_flags & B00000001 )
-    ui_ctrl_flags &= B11111110;
-
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {
-      // change motor direction
-      motor_dir(false);
-      if( ! (run_status & B00010000) )
-        motor_control(true);
-    }
-    show_manual();
-
-
-    return;
-  }  
-
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, rt switches value we can
-    // adjust
-    main_screen_select(true);
-    return;
-  } 
-
-}
-
-
-void ui_button_lt(boolean held) {
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {        
-      // change motor direction
-      motor_dir(true);
-      // get motor moving (if not already)
-      if( ! (run_status & B00010000) )
-        motor_control(true);
-      show_manual();
-    }
-    return;
-  }  
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, lt switches value we can
-    // adjust
-    main_screen_select(false);
-    return;
-  }
-
-  // left button
-  if( ! (ui_ctrl_flags & B01000000 || ui_ctrl_flags & B00100000 ))
-    return;
-
-  if( ui_ctrl_flags & B00100000 ) {
-    // we're in a value entry mode.  Exit
-    // entry without saving the value
-
-    // clear in value setting flag
-    // and the flag indicating that
-    // we've already displayed this value
-    ui_ctrl_flags &= B11001111;        
-    // reset the float tenths (vs 100ths) parameter
-    ui_float_tenths = false;
-
-    draw_menu(0,false);
-    return;
-  }
-
-  // draw previous menu
-
-  if( cur_menu == 0 ) { 
-    // we're at the highest menu, back to main screen 
-    cur_pos = 0;  
-    // clear setup flag
-    // indicate display needs updating
-    ui_ctrl_flags &= B10111111;
-    ui_ctrl_flags |= B10000000;
-    // clear out list of menus
-    flush_menu();
-  }
-  else {
-    // a parent menu can be drawn
-    cur_menu = pop_menu();
-    draw_menu(0,false);
-  }
-
-}
-
-
-/* 
- Draw screens
- */
-
-
-void draw_menu(byte dir, boolean value_only) {
-
-
-  // turn off blinking, if on...
-  lcd.noBlink();
-
-  boolean draw_all = false;
-
-  // determine the direction we are going, up/down (1/2),
-  // draw all (but don't move position) (3), and draw
-  // new menu from top (0)
-
-  if( dir == 2 ) {
-    // down
-    cur_pos++;
-    if( cur_pos > cur_pos_sel ) {
-      lcd.clear();
-      draw_all = true;
-    }
-  }    
-  else if( dir == 1 ) {
-    // up
-    cur_pos = cur_pos == 0 ? 0 : cur_pos - 1;
-
-    if( cur_pos < cur_pos_sel ) {
-      lcd.clear();
-      draw_all = true;
-    }
-  }
-  else if( dir == 3 ) {
-    // draw all (no move)
-    draw_all = true;
-  }
-  else {
-    // draw new menu (from top)
-    cur_pos = 0;
-    draw_all = true;
-  }
-
-  // don't overrun the memory locations for this menu
-
-  cur_pos = cur_pos > max_menu[cur_menu] ? max_menu[cur_menu] : cur_pos;
-
-  switch( cur_menu ) {
-
-  case 0:
-
-    draw_values(menu_str, draw_all, value_only);
-    break;
-
-  case 1:
-
-    draw_values(man_str, draw_all, value_only);
-    break;
-
-  case 2:
-
-    draw_values(axis0_str, draw_all, value_only);
-    break;
-
-  case 3:
-
-    draw_values(cam_str, draw_all, value_only);
-    break;
-
-  case 4:
-
-    draw_values(set_str, draw_all, value_only);
-    break;
-
-  default: 
-    return;  
-  }
-
-
-}
-
-
-void draw_values(const char *these[], boolean draw_all, boolean value_only) {
-
-  if( draw_all == true ) {
-
-    // must draw the whole display
-    lcd.clear();
-    // clear out lcd buffer
-
-      memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
-
-    // draw first option
-    lcd.noCursor();
-    lcd.setCursor(0,0);
-    cur_pos_sel = cur_pos;
-
-    strcpy_P(lcd_buf, (char*) pgm_read_word(&(these[cur_pos])));
-    lcd.print("> ");
-    lcd.print(lcd_buf);
-    lcd.setCursor(0,1);
-
-    // if we're not displaying only a value, and there's
-    // another menu entry to display -- display it on the 
-    // second line..
-
-    if( ! value_only ) {
-      if( cur_pos + 1 <= max_menu[cur_menu] ) {
-        cur_pos_sel = cur_pos + 1;
-        memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
-        strcpy_P(lcd_buf, (char*)pgm_read_word(&(these[cur_pos + 1])));
-        lcd.print("  ");
-        lcd.print(lcd_buf);
-      }
-      // clear out in value entry setting, if set
-      ui_ctrl_flags &= B11011111;
-
-    }
-    else {
-
-      // display the value of the current entry
-      ui_ctrl_flags |= B00100000;
-
-
-      if(! ( ui_ctrl_flags & B00010000 ) ) {
-        // have just drawn this value
-
-        // place value from variable into
-        // temporary buffer
-        get_value(cur_menu, cur_pos, false);
-
-        ui_ctrl_flags |= B00010000;
-      }
-
-
-
-      // display the correct current
-      // temporary input value
-
-      if( ui_type_flags2 & B10000000 ) {
-        // for alt i/o inputs
-
-        if( cur_inp_long == 0 ) {
-          lcd.print("Disabled");
-        }
-        else if( cur_inp_long == 1 ) {
-          lcd.print("Start");
-        }
-        else if( cur_inp_long == 2 ) {
-          lcd.print("Stop");
-        }
-        else if( cur_inp_long == 3 ) {
-          lcd.print("Toggle");
-        }
-        else if( cur_inp_long == 4 ) {
-          lcd.print("Ext. Interval.");
-        }
-        else if( cur_inp_long == 5 ) {
-          lcd.print("Out Before");
-        }
-        else if( cur_inp_long == 6 ){
-          lcd.print("Out After");
-        }
-        else if(cur_inp_long == 7 ) {
-          lcd.print("Out Both");
-        }
-        else {
-          lcd.print("Change Dir");
-        }
-        return;
-      }
-      else if( ui_type_flags2 & B01000000 ) {
-        // cal speed inputs in gobal set menu
-        display_spd_ipm(cur_inp_long);
-        return;
-      }
-
-      switch(ui_type_flags) {
-      case B10000000:
-        lcd.print(cur_inp_float, (byte) 2);
-        break;
-      case B01000000:
-        if (cur_inp_bool == true) {
-          lcd.print("On");
-        } 
-        else {
-          lcd.print("Off");
-        }
-        break;
-      case B00100000:
-        if (cur_inp_bool == true) {
-          lcd.print("Up");
-        } 
-        else {
-          lcd.print("Dn");
-        }
-        break;
-      case B00010000:
-        if (cur_inp_bool == true) {
-          lcd.print("Rt");
-        } 
-        else {
-          lcd.print("Lt");
-        }
-        break;
-      case B00001000:
-        if (cur_inp_bool == true) {
-          lcd.print("IPM");
-        } 
-        else {
-          lcd.print("PCT");
-        }
-        break;
-      case B00000100:
-        if (cur_inp_bool == true) {
-          lcd.print("Pulse");
-        } 
-        else {
-          lcd.print("Interleave");
-        }
-        break;
-      case B00000010:
-        if (cur_inp_bool == true) {
-          lcd.print("Rotary");
-        } 
-        else {
-          lcd.print("Linear");
-        }
-        break;
-      case B00000001:
-        if( cur_inp_long == 0 ) {
-          lcd.print(0,DEC);
-        }
-        else if( cur_inp_long == 1 ) {
-          lcd.print(45,DEC);
-        }
-        else {
-          lcd.print(90,DEC);
-        }
-        break;
-      default:
-        lcd.print((unsigned long)cur_inp_long);
-        return;
-      }
-
-
-
-    }
-
-  } // end if( draw_all == true
-
-  else {
-
-    // do not need to re-draw the whole screen
-
-    // move cursor down if we're not in
-    // a value input screen
-    if( ! (ui_ctrl_flags & B00100000) ) {
-      lcd.setCursor(0,0);
-      lcd.print(' ');
-      lcd.setCursor(0,1);
-      lcd.print('>');
-    }
-
-  }
-}
-
-
-void ui_set_backlight(byte value) {
-
-  // make sure to not use pwm on lcd bkl pin
-  // if timer1 has been used at some point
-  if( ! timer_used ) {
-    analogWrite(LCD_BKL, cur_bkl);
-  }
-  else {
-    if( cur_bkl > 0 ) {
-      digitalWriteFast(LCD_BKL, HIGH);
-    }
-    else {
-      digitalWriteFast(LCD_BKL, LOW);
-    }
-  }
-}
-
-/* 
- 
- Menu history functions
- 
- */
-
-void push_menu(byte this_menu) { 
-  // push the given entry to the end of the list
-  for( byte i = 0; i < sizeof(hist_menu) / sizeof(hist_menu[0]); i++) {
-    if( hist_menu[i] == 0 ) {
-      hist_menu[i] = this_menu;
-    }
-  }
-}
-
-byte pop_menu() {
-  byte bk_menu = 0;
-  for( byte i = sizeof(hist_menu) / sizeof(hist_menu[0]); i > 0 ; i--) {
-    if( hist_menu[i-1] != 0 ) {
-      bk_menu = hist_menu[i-1];
-      hist_menu[i-1] = 0;
-    }
-  }
-  return(bk_menu);
-}
-
-void flush_menu() {
-  memset(hist_menu, 0, sizeof(hist_menu) / sizeof(hist_menu[0]));
-}
-
-
-
diff --git a/DollyShield/bak/ds_ui_screens.ino b/DollyShield/bak/ds_ui_screens.ino
deleted file mode 100644
index 83ce422..0000000
--- a/DollyShield/bak/ds_ui_screens.ino
+++ /dev/null
@@ -1,303 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-
-/*
-
- ========================================
- UI Screen-drawing functions
- ========================================
- 
- */
-
-
-void prep_home_screen() {
-  lcd.clear();
-  lcd.setCursor(0,0);
-
-  if( run_status & B10000000 ) {
-    // in 'external intervalometer' mode, show 'ext' inseatd of 'on'
-    if( external_interval & B11000000 || gb_enabled == true ) {
-      lcd.print("Ext");
-    }
-    else {
-      lcd.print("On");
-    }
-  }
-  else {
-    lcd.print("Off");
-  }
-
-  lcd.setCursor(4, 0);
-}
-
-
-void show_home() {
-
-  prep_home_screen();  
-
-  // deal with interval times that are less than total time
-  // required between shots
-  float i_total = calc_total_cam_tm();
-
-  if( cam_interval < i_total ) {
-    lcd.print(i_total, 1);
-  }
-  else {
-    lcd.print((float) cam_interval, 1);
-  }
-
-  lcd.print("s ");
-
-
-  if( shots > 999 ) {
-    lcd.setCursor(10,0);
-  }
-  else if( shots > 99 ) {
-    lcd.setCursor(11, 0);
-  }
-  else if( shots > 9 ) {
-    lcd.setCursor(12, 0);
-  }
-  else {
-    lcd.setCursor(13,0);
-  }
-
-  lcd.print('[');
-  lcd.print(shots, DEC);
-  lcd.print(']');
-
-  lcd.setCursor(0,1);
-
-  // dir displays
-  char lt = ui_invdir == true ? 'R' : 'L';
-  char rt = ui_invdir == true ? 'L' : 'R';
-
-  if( m_wasdir[0] == 1 ) {
-    lcd.print(lt);
-  }
-  else {
-    lcd.print(rt);
-  }
-
-
-  if( ui_motor_display ) {
-    // display pct 
-    display_spd_ipm(m_speeds[0]);
-  }
-  else {
-    display_spd_pct(m_speeds[0]);
-  }
-
-
-  lcd.setCursor(8,1);
-
-
-
-  // we call this here mainly to reset the
-  // cursor position when in an input
-  if( main_scr_input ) 
-    get_mainscr_set(main_scr_input, false);
-}
-
-
-void main_screen_select(boolean dir) {
-
-  byte max_inputs = 4;
-  if( main_scr_input == 0) {
-    lcd.blink();
-  }
-
-  if( dir ) {
-    main_scr_input++;
-  }
-  else {
-    main_scr_input+=max_inputs;
-  }
-
-  main_scr_input=main_scr_input%(max_inputs+1);
-
-  // exit main scr setup
-
-  if(main_scr_input == 0 ) {
-    lcd.noBlink();
-    main_scr_input = 0;
-    return;
-  }
-
-  get_mainscr_set(main_scr_input, false);
-}
-
-
-void show_manual() {
-
-  ui_ctrl_flags |= B00000100;
-
-  lcd.clear();
-  lcd.noBlink();
-
-  lcd.setCursor(0, 0);
-
-
-  lcd.print("[Sel] to exit");
-
-
-  lcd.setCursor(0, 1);
-  lcd.print("Speed: ");
-
-  if( ui_motor_display ) {
-    // display ipm 
-    display_spd_ipm(m_speeds[0]);
-  }
-  else {
-    display_spd_pct(m_speeds[0]);
-  }
-
-
-}
-
-
-void show_calibrate() {
-
-  // show the motor calibrate screen
-
-  ui_ctrl_flags |= B00000001;
-
-  lcd.clear();
-  lcd.noBlink();
-
-  lcd.setCursor(0,0);
-
-  lcd.print("Cal M");
-  lcd.print(" [");
-
-  byte angle = m_cur_cal * 45;
-
-  lcd.print(angle, DEC);
-  lcd.print(" Deg]");
-
-}
-
-
-
-void execute_calibrate() {
-
-  // in calibration  
-  ui_cal_scrn_flags |= B10000000;
-  // floating point input
-  ui_type_flags |= B10000000;
-
-  ui_float_tenths = false;
-
-
-  byte was_cur_pos = 0;
-  byte completed = 0;   
-
-  // sms calibration
-  for( byte i = 0; i <= 1; i++ ) {
-    float traveled = 0.01 * (max_ipm[0]);
-    unsigned int runspd = 0.01 * m_maxsms[0];
-    cur_inp_float = traveled;
-
-    completed++;
-
-    lcd.clear();
-    lcd.setCursor(0,0);
-    lcd.print("Running ");  
-    lcd.print('[');
-    lcd.print(completed, DEC);
-    lcd.print(" of 6]");
-
-    // sms moving in i dir
-    // at 6% of total distance
-    motor_run_calibrate(1, runspd, i);
-
-    update_cal_screen();
-
-    m_cal_done = false;
-
-    while( m_cal_done == false ) {
-      byte held = ui_button_check();
-    }
-
-    m_cal_array[0][m_cur_cal][0][i] = traveled / cur_inp_float;
-
-  }
-
-
-  // pulse calibration  
-  for( byte c = 1; c <= 2; c++ ) {
-    byte ths_spd = c == 1 ? motor_spd_cal[0] : motor_spd_cal[1];
-
-    for( byte i = 0; i <= 1; i++ ) {
-      float des_ipm = motor_calc_ipm(ths_spd, true);
-      cur_inp_float = des_ipm;
-
-      completed++;
-
-      lcd.clear();
-      lcd.setCursor(0,0);
-      lcd.print("Running ");  
-      lcd.print('[');
-      lcd.print(completed, DEC);
-      lcd.print(" of 6]");
-
-      // pulse moving in i dir
-      motor_run_calibrate(2, ths_spd, i);
-
-      update_cal_screen();
-
-      m_cal_done = false;
-
-      while(  m_cal_done == false ) {
-        byte held = ui_button_check();
-      }
-
-      m_cal_array[0][m_cur_cal][c][i] = ( cur_inp_float / des_ipm );
-    }
-  }
-
-
-  ui_cal_scrn_flags &= B01111111;
-  ui_cal_scrn_flags |= B01000000;
-
-  // save values to memory
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[2][3][3][2] 
-  // 2 * 3 * 3 * 2 * 4 = 144
-
-  byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_write(71, *p, 144);
-
-}
-
-
-void update_cal_screen() {
-
-  lcd.clear();
-  lcd.setCursor(0,0);
-  lcd.print("Dist Moved:");
-  lcd.setCursor(0,1);
-
-  lcd.print(cur_inp_float, 2);
-}
-
diff --git a/DollyShield/bak/ds_ui_values.ino b/DollyShield/bak/ds_ui_values.ino
deleted file mode 100644
index e0d0f44..0000000
--- a/DollyShield/bak/ds_ui_values.ino
+++ /dev/null
@@ -1,717 +0,0 @@
-/* 
- 
- "DollyShield" MX2
- 
- (c) 2010 C.A. Church / Dynamic Perception LLC
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- 
- */
-
-
-/*
-
- ========================================
- UI Value Handling/Lookup functions
- ========================================
- 
- */
-
-
-void get_value( byte menu, byte pos, boolean read_save ) {
-
-  // find the correct value to display for the current menu item
-  // calls the necessary related function to handle value display/setting
-  if( pos > max_menu[menu] )
-    return;
-
-  //set as non-floating point/bool by default
-  ui_type_flags = 0;
-
-  switch(menu) {
-  case 1:
-    get_manual_select(pos);
-    break;
-  case 2:    
-    get_m_axis_set(pos, read_save);
-    break;
-  case 3:    
-    get_m_cam_set(pos, read_save);
-    break;
-  case 4:
-    get_global_set(pos, read_save);
-    break;
-
-  }
-
-
-
-}
-
-
-void move_val(boolean dir) {
-
-  // increase or decrease input value
-
-  if( ui_type_flags & B10000000 ) {
-    // float type
-
-
-    // how much to add/remove each time?
-
-    float mod = ui_float_tenths ? 0.1 : 0.01;
-    mod *= (float) inp_val_mult;
-
-    // floating point input
-    if( dir == true ) {
-      // increase value
-      cur_inp_float += mod;
-    }
-    else {
-      if( cur_inp_float < mod ) {
-        cur_inp_float = 0.0;
-      }
-      else {
-        cur_inp_float -= mod;
-      }
-
-    }
-
-  }
-  else if( ui_type_flags & B01111110 ) {
-    // any boolean type
-
-    cur_inp_bool = ! cur_inp_bool;
-  }
-  else {
-
-    // unsigned long type
-    unsigned long mod = (1 * inp_val_mult);
-    // long input
-    if( dir == true ) {
-      cur_inp_long += mod;
-    }
-    else {
-      if( cur_inp_long < mod ) {
-        cur_inp_long = 0;
-      }
-      else {
-        cur_inp_long -= mod;
-      }
-    } // end if dir not true
-
-    if( ui_type_flags & B00000001 ) {
-      // ceiling on certain values
-      cur_inp_long = cur_inp_long > 2 ? 2 : cur_inp_long;
-    }
-    else if( ui_type_flags2 & B10000000 ) {
-      // ceiling for alt i/o types
-      cur_inp_long = cur_inp_long > 8 ? 8 : cur_inp_long;
-    }
-
-  } // end else long type...
-
-}
-
-
-
-
-void get_m_axis_set( byte pos, boolean read_save) {
-
-  ui_type_flags = 0;
-  ui_type_flags2 = 0;
-
-  // set axis configurable values
-
-  switch(pos) { 
-  case 0:
-    // set ramp value
-    if( read_save == true ) {
-      motor_set_ramp(cur_inp_long);         
-      eeprom_write(61, m_ramp_set[0]);
-    }
-
-    cur_inp_long = m_ramp_set[0];
-    break;
-
-  case 1:
-    // set lead-in value
-    if( read_save == true ) {
-      m_lead_in[0] = cur_inp_long;
-      eeprom_write(229 , m_lead_in[0]);
-    }
-
-    cur_inp_long = m_lead_in[0];
-    break;
-
-  case 2:
-    // set lead-out value
-    if( read_save == true ) {
-      m_lead_out[0] = cur_inp_long;
-      eeprom_write(233, m_lead_out[0]);
-    }
-
-    cur_inp_long = m_lead_out[0];
-    break;
-
-  case 3:
-    ui_type_flags |= B10000000;
-    // set rpm
-    if( read_save == true ) {
-      m_rpm[0] = cur_inp_float;
-      motor_update_dist(m_rpm[0], m_diarev[0]);
-      eeprom_write(32, m_rpm[0]);
-    }
-
-    cur_inp_float = m_rpm[0];
-    break;
-
-
-  case 4: 
-
-    // doly angle (for calibration)
-    ui_type_flags |= B00000001;
-
-    if( read_save == true ) {
-      m_angle[0] = cur_inp_long;
-      eeprom_write(215, m_angle[0]);
-    }
-
-    cur_inp_long = m_angle[0];
-    break;
-
-
-  case 5:
-    // calibrate motor
-    get_calibrate_select(0);
-    break;
-
-  case 6:
-    // calibration constant
-
-    ui_type_flags |= B10000000;
-
-    if( read_save == true ) {
-      m_cal_constant[0] = cur_inp_float;
-      eeprom_write(239, m_cal_constant[0]);
-    }
-
-    cur_inp_float = m_cal_constant[0];
-    break;
-
-  case 7:
-    // min ipm setting
-    ui_type_flags |= B10000000;
-    if( read_save == true ) {
-
-      min_ipm[0] = cur_inp_float;
-      min_spd[0] = 255 * ( min_ipm[0] / max_ipm[0] );
-      eeprom_write(40, min_ipm[0]);
-      eeprom_write(48 , min_spd[0]);
-    } 
-    cur_inp_float = min_ipm[0];
-
-    break;
-
-  case 8:
-    // distance per revolution
-    ui_type_flags |= B10000000;
-
-    if( read_save == true ) {
-      m_diarev[0] = cur_inp_float;
-      motor_update_dist(m_rpm[0], m_diarev[0]);
-      eeprom_write(16, m_diarev[0]);
-    }
-
-    cur_inp_float = m_diarev[0];
-
-    break;
-
-  case 9:
-    // motor min pulse
-    if( read_save == true ) {
-
-      if(cur_inp_long > 255)
-        cur_inp_long = 255;
-
-      m_min_pulse[0] = cur_inp_long;          
-      eeprom_write(50, m_min_pulse[0]);
-    }
-    cur_inp_long = m_min_pulse[0];
-    break;
-
-
-  }
-
-}
-
-
-
-
-void get_m_cam_set( byte pos, boolean read_save ) {
-
-  // reset this flag
-  ui_float_tenths = false;
-
-
-  switch(pos) {
-  case 0:
-    // interval timer
-    ui_type_flags |= B10000000;
-    ui_float_tenths = true;
-
-    if( read_save == true ) { 
-      cam_interval = cur_inp_float;
-      eeprom_write(67, cam_interval);
-    }
-    cur_inp_float = cam_interval;
-    break;
-
-  case 1:
-    // max shots
-    if( read_save == true ) {
-      cam_max = cur_inp_long;
-      eeprom_write(10, cam_max);
-    }
-    cur_inp_long = cam_max;
-    break;
-
-  case 2:
-    // exposure time
-    if( read_save == true ) { 
-      exp_tm = cur_inp_long;
-      eeprom_write(260, exp_tm);
-    }
-    cur_inp_long = exp_tm;
-    break;    
-
-  case 3:
-    // post exp delay
-    if( read_save == true ) { 
-      post_delay_tm = cur_inp_long;
-      eeprom_write(5, post_delay_tm);
-    }
-    cur_inp_long = post_delay_tm;
-    break;
-
-  case 4:
-    // focus tap tm
-    if( read_save == true ) {
-      focus_tap_tm = cur_inp_long;
-      eeprom_write(3, focus_tap_tm);
-    }
-    cur_inp_long = focus_tap_tm;
-    break;
-
-  case 5:
-    //ir remote
-    ui_type_flags |= B01000000;
-    if( read_save == true ) {
-      ir_remote= cur_inp_bool;
-      eeprom_write(267, ir_remote); //TODO
-    }
-    cur_inp_bool = ir_remote;
-    break;
-
-  case 6:
-    // focus w/ shutter
-    ui_type_flags |= B01000000;
-    if( read_save == true ) {
-      focus_shutter = cur_inp_bool;
-      eeprom_write(7, focus_shutter);
-    }
-    cur_inp_bool = focus_shutter;
-    break;
-
-  case 7:
-    // camera repeat value
-    if( read_save == true ) {
-      cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
-      cam_repeat = cur_inp_long;
-      eeprom_write(249, cam_repeat);
-    }
-    cur_inp_long = cam_repeat;
-    break;
-
-  case 8:
-    // camera repeat delay
-    if( read_save == true) {
-      cam_rpt_dly = cur_inp_long;
-      eeprom_write(250, cam_rpt_dly);
-    }
-    cur_inp_long = cam_rpt_dly;
-    break;
-  }
-}
-
-
-
-void get_global_set(byte pos, boolean read_save) {
-
-  ui_type_flags  = 0;
-  ui_type_flags2 = 0;
-
-  switch(pos) {
-
-  case 0:
-    // motor display type
-    ui_type_flags |= B00001000;      
-
-    if( read_save == true ) {
-      ui_motor_display = cur_inp_bool;
-      eeprom_write(56, ui_motor_display);
-    }
-
-    cur_inp_bool = ui_motor_display;
-    break;
-
-  case 1:
-    // motor slow type
-    ui_type_flags |= B00000100;      
-
-    if( read_save == true ) {
-      motor_sl_mod = cur_inp_bool;
-      eeprom_write(57, motor_sl_mod);
-    }        
-
-    cur_inp_bool = motor_sl_mod;
-    break;
-
-  case 2:
-
-    // backlight level    
-    if(read_save == true) {
-      cur_bkl = cur_inp_long > 255 ? 255 : cur_inp_long;
-      ui_set_backlight(cur_bkl);
-      eeprom_write(266, cur_bkl);
-    }
-
-    cur_inp_long = cur_bkl;
-    break;
-
-  case 3:
-    // lcd dim time
-    if( read_save == true ) {
-      lcd_dim_tm = cur_inp_long;
-      eeprom_write(58, lcd_dim_tm);
-    }
-
-    cur_inp_long = lcd_dim_tm;
-    break;
-
-  case 4:
-    // blank lcd   
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      blank_lcd = cur_inp_bool;
-      eeprom_write(60, blank_lcd);
-    }
-
-    cur_inp_bool = blank_lcd;
-    break;
-
-  case 5: 
-    // input 1
-    ui_type_flags2 |= B10000000;
-
-    if( read_save == true ) {
-      altio_connect(0, cur_inp_long);
-      eeprom_write(217,input_type[0]);
-    }
-
-    cur_inp_long = input_type[0];
-    break;
-
-  case 6: 
-    // input 2 
-    ui_type_flags2 |= B10000000;
-
-    if( read_save == true ) {
-      altio_connect(1, cur_inp_long);
-      eeprom_write(218,input_type[1]);
-    }
-
-    cur_inp_long = input_type[1];
-    break;
-
-  case 7:
-    // metric display
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      if ( cur_inp_bool != ui_is_metric ) {
-        // only convert values when the 
-        // UI metric type changes
-
-        if( ui_is_metric ) {
-          // going to imperial
-          m_diarev[0] = m_diarev[0] / 2.54;
-          min_ipm[0]  = min_ipm[0] / 2.54;
-          m_diarev[1] = m_diarev[1] / 2.54;
-          min_ipm[1]  = min_ipm[1] / 2.54;
-        }
-        else {
-          // going to metric
-          m_diarev[0] *= 2.54;
-          min_ipm[0]  *= 2.54;
-          m_diarev[1] *= 2.54;
-          min_ipm[1]  *= 2.54;
-        }
-        ui_is_metric = cur_inp_bool;
-
-        // write values to memory
-        eeprom_write(219, ui_is_metric);
-        eeprom_write(16, m_diarev[0]);
-        eeprom_write(20, m_diarev[1]);  
-        eeprom_write(40, min_ipm[0]);
-        eeprom_write(44, min_ipm[1]);
-
-        motor_update_dist(m_rpm[0], m_diarev[0]);
-      }
-    }
-    cur_inp_bool = ui_is_metric;
-    break;
-
-  case 8:
-    // reset memory
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      if( cur_inp_bool )
-        eeprom_saved(false);
-    }
-
-    cur_inp_bool = false;
-    break;
-
-  case 9:
-    // low calibration spd
-    ui_type_flags2 |= B01000000;
-
-    if( read_save == true ) {
-      motor_spd_cal[0] = cur_inp_long;
-      eeprom_write(237, motor_spd_cal[0]);
-    }
-
-    cur_inp_long = motor_spd_cal[0];
-    break;
-
-  case 10:
-    // high calibration spd
-    ui_type_flags2 |= B01000000;
-
-    if( read_save == true ) {
-      motor_spd_cal[1] = cur_inp_long;
-      eeprom_write(238, motor_spd_cal[1]);
-    }
-
-    cur_inp_long = motor_spd_cal[1];
-    break;
-
-  case 11: 
-    // alt output pre time
-
-    if( read_save == true ) {
-      ext_trig_pre_delay = cur_inp_long;
-      eeprom_write(252, ext_trig_pre_delay);
-    }
-
-    cur_inp_long = ext_trig_pre_delay;
-    break;
-
-  case 12:
-    // alt output post time
-
-    if( read_save == true ) {
-      ext_trig_pst_delay = cur_inp_long;
-      eeprom_write(256, ext_trig_pst_delay);
-    }
-
-    cur_inp_long = ext_trig_pst_delay;
-    break;
-
-  case 13:
-    // GB enable
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      gb_enabled = cur_inp_bool;
-      eeprom_write(264, gb_enabled);
-    }
-
-    cur_inp_bool = gb_enabled;
-    break;
-
-  case 14:
-    // invert dir display
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      ui_invdir = cur_inp_bool;
-      eeprom_write(265, ui_invdir);
-    }
-
-    cur_inp_bool = ui_invdir;
-    break;
-
-  case 15:
-    // flip I/O trigger type
-
-    ui_type_flags |= B01000000;
-
-    if( read_save == true ) {
-      altio_dir = (cur_inp_bool == false) ? FALLING : RISING;
-      eeprom_write(52, altio_dir);
-    }
-
-    cur_inp_bool = (altio_dir == FALLING) ? false : true;
-    break;
-
-  }
-
-}
-
-
-void get_mainscr_set(byte pos, boolean read_save) {
-
-  // clear out previous on/off select
-
-  ui_type_flags   = 0;
-  ui_type_flags2  = 0;
-  ui_float_tenths = false;
-
-
-
-  switch(pos) {
-  case 1:
-    // on/off
-    lcd.setCursor(0,0);
-
-    if( read_save ) {
-      if( cur_inp_bool > 0 ) {   
-        // if set to positive value
-        start_executing();
-      }
-      else {
-        stop_executing();
-      }
-    }
-
-    ui_type_flags |= B01000000;
-
-    cur_inp_bool = run_status >> 7;
-    break;
-
-  case 2:
-    // set interval time
-    lcd.setCursor(4, 0);
-
-    ui_type_flags |= B10000000;
-    ui_float_tenths = true;
-
-    if( read_save ) {
-      cam_interval = cur_inp_float;
-      eeprom_write(67, cam_interval);
-    }
-
-    cur_inp_float = cam_interval;
-    break;
-
-  case 3:
-    // dir for m1
-    lcd.setCursor(0,1);
-
-    if( read_save )
-      motor_dir(cur_inp_bool);
-
-    ui_type_flags |= B00010000;
-    cur_inp_bool = m_wasdir[0];
-    break;
-
-  case 4:
-    // spd for m1
-    lcd.setCursor(1,1);
-
-    if( ! motor_sl_mod ) {
-      // shoot-move-shoot?
-      cur_inp_long = cur_inp_long > m_maxsms[0] ? m_maxsms[0] : cur_inp_long;
-    } 
-    else {       
-      cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
-    }
-
-    if( read_save ) {
-      motor_set_speed((unsigned int) cur_inp_long); 
-      // calculate speed change per shot for ramping
-      // if needed - use function to update values
-      motor_set_ramp(m_ramp_set[0]);
-    }
-
-    cur_inp_long = m_speeds[0];
-
-    break; 
-  }
-}
-
-
-
-void get_manual_select(byte pos) {
-
-
-  // set in manual mode
-  ui_ctrl_flags |= B00000100;
-
-  if( pos == 1 ) {
-    //TODO
-    return;
-  }
-  // show manual motor screen
-  show_manual();
-}
-
-
-void get_calibrate_select(byte pos) {
-  // display calibrate screen  
-  show_calibrate();
-}
-
-void display_spd_ipm(unsigned int spd) {
-
-  float cur_ipm = motor_calc_ipm(spd, motor_sl_mod);
-  lcd.print(cur_ipm, 2);
-
-  // handle metric conversion
-  if( ui_is_metric ) {
-    lcd.print('c');
-  }
-  else {
-    lcd.print('i');
-  }
-}
-
-void display_spd_pct(byte spd) {
-  float cur_pct =  (float) spd / (float) 255;
-  cur_pct *= 100;
-
-  if( cur_pct < 100 ) {
-    lcd.print(cur_pct,1);
-  }
-  else {
-    lcd.print((int) cur_pct, DEC);
-  }
-  lcd.print('%');
-}
-
diff --git a/DollyShield/bak/notes.txt b/DollyShield/bak/notes.txt
deleted file mode 100644
index 743d309..0000000
--- a/DollyShield/bak/notes.txt
+++ /dev/null
@@ -1,66 +0,0 @@
- enum  __attribute__((packed)) INPUTS {
-     INPUT_FLOAT, INPUT_ONOF, INPUT_SHUTTER, INPUT_LTRT, INPUT_CMPCT,INPUT_CONTSMS,INPUT_ANGEL,INPUT_IO,INPUT_SPEED,INPUT_PREPOST
- };
-
-
-
- /* input type flags
- 
-   B0 = input value is a float
-   B1 = input is a bool (on/off) value
-   B2 = input is a bool (up/dn) value
-   B3 = input is a bool (lt/rt) value
-   B4 = input is a bool (ipm/pct) value
-   B5 = input is a bool (pulse/sms) value
-   B6 = input is a bool (rotary/linear) value
-   B7 = input is list (0,45,90) value
-   
- */
- 
-
-
-
-  #define 3 EEPROM_POS_focus_tap_tm 3   //uint16
-  #define 5 EEPROM_POS_post_delay_tm 5  //
-  #define 7 EEPROM_POS_shutter_mode 7
-
-  #define 10 EEPROM_POS_cam_max
-  #define 16 EEPROM_POS_m_diarev
-  #define 24 EEPROM_POS_max_ipm
-  #define 32 EEPROM_POS_m_rpm
-  #define 40 EEPROM_POS_min_ipm
-  #define 48 EEPROM_POS_min_spd
-  #define 50 EEPROM_POS_m_min_pulse
-  #define 52 EEPROM_POS_altio_dir
-  #define 56 EEPROM_POS_ui_motor_display
-  #define 57 EEPROM_POS_motor_sl_mod
-  #define 58 EEPROM_POS_lcd_dim_tm
-  #define 60 EEPROM_POS_blank_lcd
-  #define 61 EEPROM_POS_m_ramp_set
-  #define 63 EEPROM_POS_m_maxsms
-  #define 67 EEPROM_POS_cam_interval
-
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[1][3][3][2] 
-  // 1 * 3 * 3 * 2 * 4 = 72
-
-  byte* p = (byte*)(void*)&m_cal_array;
-  #define 71 EEPROM_POS_*p EEPROM_POS_(1*3*3*2*4)
-
-  #define 217 EEPROM_POS_input_type[0]
-  #define 218 EEPROM_POS_input_type[1]
-  #define 219 EEPROM_POS_ui_is_metric
-  #define 229 EEPROM_POS_m_lead_in
-  #define 233 EEPROM_POS_m_lead_out
-  #define 237 EEPROM_POS_motor_spd_cal
-  #define 239 EEPROM_POS_m_cal_constant
-  #define 249 EEPROM_POS_cam_repeat
-  #define 250 EEPROM_POS_cam_rpt_dly
-
-  #define 252 EEPROM_POS_ext_trig_pre_delay
-  #define 256 EEPROM_POS_ext_trig_pst_delay
-  #define 260 EEPROM_POS_exp_tm
-  #define 264 EEPROM_POS_gb_enabled
-  #define 265 EEPROM_POS_ui_invdir
-  #define 266 EEPROM_POS_cur_bkl
-  #define 267 EEPROM_POS_ir_remote
diff --git a/DollyShield/digitalWriteFast.h b/DollyShield/digitalWriteFast.h
deleted file mode 100644
index 415d85a..0000000
--- a/DollyShield/digitalWriteFast.h
+++ /dev/null
@@ -1,171 +0,0 @@
-  #include "Arduino.h" 
-
-#define BIT_READ(value, bit) (((value) >> (bit)) & 0x01)
-#define BIT_SET(value, bit) ((value) |= (1UL << (bit)))
-#define BIT_CLEAR(value, bit) ((value) &= ~(1UL << (bit)))
-#define BIT_WRITE(value, bit, bitvalue) (bitvalue ? BIT_SET(value, bit) : BIT_CLEAR(value, bit))
-
-#if !defined(digitalPinToPortReg)
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-// Arduino Mega Pins
-#define digitalPinToPortReg(P) \
-(((P) >= 22 && (P) <= 29) ? &PORTA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \
-(((P) >= 30 && (P) <= 37) ? &PORTC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PORTD : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &PORTE : \
-(((P) >= 54 && (P) <= 61) ? &PORTF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PORTG : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PORTH : \
-(((P) == 14 || (P) == 15) ? &PORTJ : \
-(((P) >= 62 && (P) <= 69) ? &PORTK : &PORTL))))))))))
-
-#define digitalPinToDDRReg(P) \
-(((P) >= 22 && (P) <= 29) ? &DDRA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \
-(((P) >= 30 && (P) <= 37) ? &DDRC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &DDRD : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &DDRE : \
-(((P) >= 54 && (P) <= 61) ? &DDRF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &DDRG : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &DDRH : \
-(((P) == 14 || (P) == 15) ? &DDRJ : \
-(((P) >= 62 && (P) <= 69) ? &DDRK : &DDRL))))))))))
-
-#define digitalPinToPINReg(P) \
-(((P) >= 22 && (P) <= 29) ? &PINA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \
-(((P) >= 30 && (P) <= 37) ? &PINC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PIND : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &PINE : \
-(((P) >= 54 && (P) <= 61) ? &PINF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PING : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PINH : \
-(((P) == 14 || (P) == 15) ? &PINJ : \
-(((P) >= 62 && (P) <= 69) ? &PINK : &PINL))))))))))
-
-#define __digitalPinToBit(P) \
-(((P) >=  7 && (P) <=  9) ? (P) - 3 : \
-(((P) >= 10 && (P) <= 13) ? (P) - 6 : \
-(((P) >= 22 && (P) <= 29) ? (P) - 22 : \
-(((P) >= 30 && (P) <= 37) ? 37 - (P) : \
-(((P) >= 39 && (P) <= 41) ? 41 - (P) : \
-(((P) >= 42 && (P) <= 49) ? 49 - (P) : \
-(((P) >= 50 && (P) <= 53) ? 53 - (P) : \
-(((P) >= 54 && (P) <= 61) ? (P) - 54 : \
-(((P) >= 62 && (P) <= 69) ? (P) - 62 : \
-(((P) == 0 || (P) == 15 || (P) == 17 || (P) == 21) ? 0 : \
-(((P) == 1 || (P) == 14 || (P) == 16 || (P) == 20) ? 1 : \
-(((P) == 19) ? 2 : \
-(((P) == 5 || (P) == 6 || (P) == 18) ? 3 : \
-(((P) == 2) ? 4 : \
-(((P) == 3 || (P) == 4) ? 5 : 7)))))))))))))))
-
-// 15 PWM
-#define __digitalPinToTimer(P) \
-(((P) == 13 || (P) ==  4) ? &TCCR0A : \
-(((P) == 11 || (P) == 12) ? &TCCR1A : \
-(((P) == 10 || (P) ==  9) ? &TCCR2A : \
-(((P) ==  5 || (P) ==  2 || (P) ==  3) ? &TCCR3A : \
-(((P) ==  6 || (P) ==  7 || (P) ==  8) ? &TCCR4A : \
-(((P) == 46 || (P) == 45 || (P) == 44) ? &TCCR5A : 0))))))
-#define __digitalPinToTimerBit(P) \
-(((P) == 13) ? COM0A1 : (((P) ==  4) ? COM0B1 : \
-(((P) == 11) ? COM1A1 : (((P) == 12) ? COM1B1 : \
-(((P) == 10) ? COM2A1 : (((P) ==  9) ? COM2B1 : \
-(((P) ==  5) ? COM3A1 : (((P) ==  2) ? COM3B1 : (((P) ==  3) ? COM3C1 : \
-(((P) ==  6) ? COM4A1 : (((P) ==  7) ? COM4B1 : (((P) ==  8) ? COM4C1 : \
-(((P) == 46) ? COM5A1 : (((P) == 45) ? COM5B1 : COM5C1))))))))))))))
-
-#else
-
-// Standard Arduino Pins
-#define digitalPinToPortReg(P) \
-(((P) >= 0 && (P) <= 7) ? &PORTD : (((P) >= 8 && (P) <= 13) ? &PORTB : &PORTC))
-#define digitalPinToDDRReg(P) \
-(((P) >= 0 && (P) <= 7) ? &DDRD : (((P) >= 8 && (P) <= 13) ? &DDRB : &DDRC))
-#define digitalPinToPINReg(P) \
-(((P) >= 0 && (P) <= 7) ? &PIND : (((P) >= 8 && (P) <= 13) ? &PINB : &PINC))
-#define __digitalPinToBit(P) \
-(((P) >= 0 && (P) <= 7) ? (P) : (((P) >= 8 && (P) <= 13) ? (P) - 8 : (P) - 14))
-
-#if defined(__AVR_ATmega8__)
-// 3 PWM
-#define __digitalPinToTimer(P) \
-(((P) ==  9 || (P) == 10) ? &TCCR1A : (((P) == 11) ? &TCCR2 : 0))
-#define __digitalPinToTimerBit(P) \
-(((P) ==  9) ? COM1A1 : (((P) == 10) ? COM1B1 : COM21))
-#else  //168,328
-
-// 6 PWM
-#define __digitalPinToTimer(P) \
-(((P) ==  6 || (P) ==  5) ? &TCCR0A : \
-(((P) ==  9 || (P) == 10) ? &TCCR1A : \
-(((P) == 11 || (P) ==  3) ? &TCCR2A : 0)))
-#define __digitalPinToTimerBit(P) \
-(((P) ==  6) ? COM0A1 : (((P) ==  5) ? COM0B1 : \
-(((P) ==  9) ? COM1A1 : (((P) == 10) ? COM1B1 : \
-(((P) == 11) ? COM2A1 : COM2B1)))))
-#endif  //defined(__AVR_ATmega8__)
-
-
-#endif  //mega
-#endif  //#if !defined(digitalPinToPortReg)
-
-
-
-
-#define __atomicWrite__(A,P,V) \
-if ( (int)(A) < 0x40) { bitWrite(*(A), __digitalPinToBit(P), (V) );}  \
-else {                                                         \
-uint8_t register saveSreg = SREG;                          \
-cli();                                                     \
-bitWrite(*(A), __digitalPinToBit(P), (V) );                   \
-SREG=saveSreg;                                             \
-} 
-
-// && __builtin_constant_p(V)
-#ifndef digitalWriteFast
-#define digitalWriteFast(P, V) \
-do {                       \
-if (__builtin_constant_p(P)) {\
-	if(V)   __atomicWrite__((uint8_t*) digitalPinToPortReg(P),P,HIGH) \
-	else     __atomicWrite__((uint8_t*) digitalPinToPortReg(P),P,LOW)\
-}\
-else  digitalWrite((P), (V));         \
-}while (0)
-#endif  //#ifndef digitalWriteFast2
-
-#if !defined(pinModeFast)
-#define pinModeFast(P, V) \
-do {if (__builtin_constant_p(P) && __builtin_constant_p(V)) __atomicWrite__((uint8_t*) digitalPinToDDRReg(P),P,V) \
-else pinMode((P), (V)); \
-} while (0)
-#endif
-
-
-#ifndef noAnalogWrite
-#define noAnalogWrite(P) \
-	do {if (__builtin_constant_p(P) )  __atomicWrite((uint8_t*) __digitalPinToTimer(P),P,0) \
-		else turnOffPWM((P));   \
-} while (0)
-#endif		
-
-
-#ifndef digitalToggleFast
-	#define digitalToggleFast(P)\
-        do{\
-        if (__builtin_constant_p(P))\
-        {*(digitalPinToPINReg(P))= (1UL << __digitalPinToBit(P));\
-	}else (digitalWrite((P),!digitalRead((P))));\
-        }while(0)
-#endif
-
-
-#ifndef digitalReadFast
-	#define digitalReadFast(P) ( (int) _digitalReadFast_((P)) )
-	#define _digitalReadFast_(P ) \
-	if (__builtin_constant_p(P) ) ? ( \
-	( BIT_READ(*digitalPinToPINReg(P), __digitalPinToBit(P))) ) : \
-	digitalRead((P))
-#endif
diff --git a/DollyShield/ds_alt_io.ino b/DollyShield/ds_alt_io.ino
index fa76f07..3a4ec52 100644
--- a/DollyShield/ds_alt_io.ino
+++ b/DollyShield/ds_alt_io.ino
@@ -1,76 +1,76 @@
 /* 
- 
- El Cheapo Dollyshield - IO Functions and Interrupts
- modified Version of Dynamic Perception LLC's DollyShield ds_alt_io.ino
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
 
-/*
-
- ========================================
- Alt I/O Handlers
- ========================================
- 
- */
-
-
-void altio_isr_handler(byte which) {
-
-  // from internals
-  extern volatile unsigned long timer0_millis;
-
-  if( timer0_millis - input_trig_last > ALT_TRIG_THRESH ) {
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
 
-    input_trig_last = timer0_millis;
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
-    switch( input_type[which] ) {
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-    case 1:
-      start_executing();
-      break;
 
-    case 2:
-      stop_executing();
-      break;
+*/
 
-    case 3:
-      altio_flip_runstat();
-      break;
+/*
 
-    case 4: 
-      // set camera ok to fire
-      external_io|= EXT_INTV_OK;
-      break;
+  ========================================
+  Alt I/O Handlers
+  ========================================
+  
+*/
 
-    case 8:
-      // switch  motor direction
-      motor_dir(!m_dir);
 
-      break;
 
-    default:
-      break;
+void altio_isr_handler(byte which) {
+  
+    // from internals
+  extern volatile unsigned long timer0_millis;
+  
+  if( timer0_millis - input_trig_last > ALT_TRIG_THRESH ) {
+    
+    input_trig_last = timer0_millis;
+    
+    switch( input_type[which] ) {
+      
+      case 1:
+        start_executing();
+        break;
+        
+      case 2:
+        stop_executing();
+        break;
+        
+      case 3:
+        altio_flip_runstat();
+        break;
+        
+      case 4: 
+          // set camera ok to fire
+        external_interval |= B00100000;
+        break;
+        
+      case 8:
+          // switch all motor directions!
+        motor_dir(0, !m_wasdir[0]);
+        motor_dir(1, !m_wasdir[1]);
+        break;
+        
+      default:
+        break;
     } // end switch
   } //end if timer0...
 }
 
-
+      
 void altio_isr_one() {
   altio_isr_handler(0);
 }
@@ -82,252 +82,113 @@ void altio_isr_two() {
 
 
 void altio_connect(byte which, byte type) {
-
-  input_type[which] = type;
-  //disable every flag for this line
-  external_io &= ~ ((EXT_TRIG_1_BEFORE|EXT_TRIG_1_AFTER|EXT_INTV_1)  << which);
-
-// disabled
-  if( type == 0 ) {
-    detachInterrupt(which);
-    if (which==0){
-      digitalWriteFast(2, LOW);
-    }
-    else{
-      digitalWriteFast(3, LOW);
-    }
-    return;
-  }
   
+  input_type[which] = type;
 
+    // type == 5, 6, 7 changes from input to output, handle this
+    // deviation
+    
   if( type == 5 || type == 6 || type == 7 ) {
-    // output mode
-
+          // output mode
     detachInterrupt(which);
-    if (which==0){
-      pinModeFast(2,OUTPUT);
-    }
-    else{
-      pinModeFast(3,OUTPUT);
-    }
-    // set correct flag, as needed
+    pinMode(2+which,OUTPUT);
+      // set correct flag, as needed
     if( type == 5 ) {
-      external_io |= (EXT_TRIG_1_BEFORE << which) ;
+      external_trigger |= B10000000 >> which;
     }
     else if( type == 6 ) {
-      external_io |= (EXT_TRIG_1_AFTER << which);
+      external_trigger |= B00100000 >> which;
     }
     else {
-      external_io |= ((EXT_TRIG_1_BEFORE|EXT_TRIG_1_AFTER) << which);
+      external_trigger |= B10100000 >> which;
     }
+    
+    return;
   }
 
-else {
-  //input mode
-  if( type == 4 ) {
-    // external intervalometer function
-    external_io |= EXT_INTV_1 << which;
+  if( type == 0 ) {
+      detachInterrupt(which);
+      digitalWrite(2+which, LOW);
+        // disable external interval for this line (just in case it
+        // was ever set)
+      external_interval &= (B11111111 ^ (B10100000 >> which));
+      return;
   }
-
-  if (which==0){
-    // set pin as input
-    pinModeFast(2, INPUT);
-    // enable pull-up resistor
-    digitalWriteFast(2, HIGH);
-    attachInterrupt(0, altio_isr_one, altio_dir);
+  else if( type == 4 ) {
+    // our external intervalometer functon
+    
+      // enable external intervalometer for this line
+    external_interval |= B10000000 >> which;
+  }
+  else {
+        // disable external interval for this line (just in case it
+        // was ever set)
+      external_interval &= (B11111111 ^ (B10100000 >> which));
   }
-  else{
-  // set pin as input
-    pinModeFast(3, INPUT);
+  
+    // set pin as input
+  pinMode(2+which, INPUT);
     // enable pull-up resistor
-    digitalWriteFast(3, HIGH);
+  digitalWrite(2+which, HIGH);
+  
+  if( which ) {
     attachInterrupt(1, altio_isr_two, altio_dir);
   }
- }    
-}
+  else {
+    attachInterrupt(0, altio_isr_one, altio_dir);
+  }
+  
+}    
+  
 void altio_flip_runstat() {
-  // if currently running, stop; if not, start
-
-    if(S_RUNNING) { // run_status & B10000000
+    // if currently running, stop; if not, start
+    
+  if( run_status & B10000000 ) {
     // running
     stop_executing();
   }
   else {
     start_executing();
   }
-
-}
-
-void alt_ext_trigger_engage(unsigned long length) {
-  // set flag
-  S_EXT_TRIG_ENGAGED=true;
-
-  // we use the interrupt pins, 2&3
-
-    if( external_io & (EXT_TRIG_1_AFTER|EXT_TRIG_1_BEFORE) ) 
-      digitalWriteFast(2, !altio_dir);
-    if( external_io & (EXT_TRIG_2_AFTER|EXT_TRIG_2_BEFORE) ) 
-      digitalWriteFast(3, !altio_dir);
- 
-  //MsTimer2::set(length, alt_ext_trigger_disengage); //TODO
-  //MsTimer2::start();
-}
-
-void alt_ext_trigger_disengage() {
-
-    if( external_io & (EXT_TRIG_1_AFTER|EXT_TRIG_1_BEFORE) ) 
-      digitalWriteFast(2, altio_dir);
-    if( external_io & (EXT_TRIG_2_AFTER|EXT_TRIG_2_BEFORE) )
-      digitalWriteFast(3, altio_dir);
-  //MsTimer2::stop();   //TODO
- 
-
-  // clear flag...
-  S_EXT_TRIG_ENGAGED=false;//run_status &= B11110111;
-}
-
-/*
-
- ========================================
- Timer Functions
- ========================================
- 
- */
- 
-
-void initialize_alt_timers() {
-
-  cli();                //disable interrupts
-  //timer 2
-  TCCR2A = 0x00;        //Timer2 Control Reg A: Wave Gen Mode normal
-  TCCR2B = 0x04;        //set Prescaler to 64
-  TIMSK2 |= (1<<OCIE2A);//enable Compare Interrupts
-  TIMSK2 |= (1<<OCIE2B);  
-  TIMSK2 |= (1<<TOIE2); //enable timer  
   
-  //timer1
-  TCCR1A = 0x00;        //Timer1 Control Reg A: Wave Gen Mode normal
-  TCCR1B = 0x04;        //set Prescaler to 256
-  TIMSK1 &= ~(1<<OCIE1A);//disable Compare Interrupts until needed
-  TIMSK1 &= ~(1<<OCIE1B);  
-  TIMSK1 |= (1<<TOIE1); //enable timer  
-
-
-
-  sei();               //enable interrupts
 }
 
+void alt_ext_trigger_engage(boolean predel) {
 
-
-void alt_io_motor_set(uint8_t value){
-  if (value==0)  TIMSK2 &= ~(1<<OCIE2A); //disable motor-on interrupt
-  else  TIMSK2 |= (1<<OCIE2A);           //enable motor-on interrupt
-  S_SLOW_MODE=false;
-  OCR2A=value;
-}
-
-
-void alt_io_motor_set_slow(uint8_t value){
-  m_counter_max_on=m_pulse_length*value;
-  m_counter_max_off=m_pulse_length*(255-value);
-  m_counter_cur=m_counter_max_on;
-  S_SLOW_MODE=true;
-  S_SLOW_MODE_MON=true;
-  OCR2A=255; //TODO anpassbar machen? kalibrierbar?
-}
-
-
-void alt_io_display_set(uint8_t value){
-   if (value==0)  TIMSK2 &= ~(1<<OCIE2B); //disable display-on interrupt
-  else  TIMSK2 |= (1<<OCIE2B);           //enable display-on interrupt
-  OCR2B=value;
-}
-
-ISR(TIMER2_COMPA_vect) {
-  //motor off
- digitalWriteFast(MOTOR0_P, LOW); 
-}
-
-ISR(TIMER2_COMPB_vect) {
-  //display off
- digitalWriteFast(LCD_BKL, LOW);  
-}
-
-ISR(TIMER2_OVF_vect){
- if (S_SLOW_MODE){
-   m_counter_cur--;
-   if (m_counter_cur==0){
-     //time to switch
-     
-      if (S_SLOW_MODE_MON){
-      //currently on, switch to off
-      digitalWriteFast(MOTOR0_P, LOW);
-      //set counter to value when motor should be turned on
-      S_SLOW_MODE_MON=false;
-      m_counter_cur=m_counter_max_on;
-      
-        }
-      else{
-       //currently off, switch to on
-     digitalWriteFast(MOTOR0_P, HIGH);
-     //set counter to value when motor should be turned off
-     S_SLOW_MODE_MON=true;
-     m_counter_cur=m_counter_max_off;
-        }  
-     }
- }
- if (S_TIMER3_SET){
-  if (timer3_ms==0){
-  (*timer3_func)();
-  S_TIMER3_SET=false;
+  unsigned long dly = predel == true ? ext_trig_pre_delay : ext_trig_pst_delay;
+    // set flag
+  run_status |= B00001000;
+  
+    // we use the interrupt pins, 2&3
+    
+  if( predel == true ) {
+    if( external_trigger & B10000000 ) 
+      digitalWrite(2, HIGH);
+    if( external_trigger & B01000000 )
+      digitalWrite(3, HIGH);
   }
-  else timer3_ms--;
- }
- 
-  if (OCR2A>0) digitalWriteFast(MOTOR0_P, HIGH); //motor on
-  if (OCR2B>0) digitalWriteFast(LCD_BKL, HIGH);  //display on
-
-}
-void timer1_set(uint16_t ms,void (*f)()){
-  timer1_func=f;
-  S_TIMER1_SET=true;
-  TIMSK1 &= ~(1<<TOIE1); //disable timer while calculating compare value
-  //divide ms by 63 (should be 62.5) and add it to the current timer
-  //value to set new interrupt compare value
-  OCR1A=TCNT1+((ms<<6)-ms);
-  TIMSK1 |= (1<<TOIE1); //re-enable timer
-  TIMSK1 |= (1<<OCIE1A); //enable Compare Interrupt
-}
-
-void timer2_set(uint16_t ms,void (*f)()){
-  timer2_func=f;
-  S_TIMER2_SET=true;
-  TIMSK1 &= ~(1<<TOIE1); //disable timer while calculating compare value
-  //divide ms by 63 (should be 62.5) and add it to the current timer
-  //value to set new interrupt compare value
-  OCR1B=TCNT1+((ms<<6)-ms);
-  TIMSK1 |= (1<<TOIE1); //re-enable timer
-  TIMSK1 |= (1<<OCIE1B); //enable Compare Interrupt
+  else {
+    if( external_trigger & B00100000 ) 
+      digitalWrite(2, HIGH);
+    if( external_trigger & B00010000 )
+      digitalWrite(3, HIGH);
+  }        
+  
+  MsTimer2::set(dly, alt_ext_trigger_disengage);
+  MsTimer2::start();
 }
 
-void timer3_set(uint16_t ms,void (*f)()){
-  timer3_ms=ms;
-  timer3_func=f;
-  S_TIMER3_SET=true;
-}
-ISR(TIMER1_COMPA_vect) {
-  //timer 1
-    TIMSK1 &= ~(1<<OCIE1A);
-    (*timer1_func)();
-    S_TIMER1_SET=false;
-}
+void alt_ext_trigger_disengage() {
+  
+  if( external_trigger & B10100000 )
+    digitalWrite(2, LOW);
+    
+  if( external_trigger & B01010000 )
+    digitalWrite(3, LOW);
 
-ISR(TIMER1_COMPB_vect) {
-  //timer 2
-    TIMSK1 &= ~(1<<OCIE1B);
-    (*timer2_func)();
-    S_TIMER2_SET=false;
-   
+  MsTimer2::stop();
+  
+    // clear flag...
+  run_status &= B11110111;
 }
 
-
diff --git a/DollyShield/ds_camera.ino b/DollyShield/ds_camera.ino
index 4e9610b..f6c91a8 100644
--- a/DollyShield/ds_camera.ino
+++ b/DollyShield/ds_camera.ino
@@ -1,89 +1,104 @@
-/* 
- 
- El Cheapo Dollyshield - Camera Control Functions
- modified Version of Dynamic Perception LLC's DollyShield ds_camera.ino
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
+/*
+
+
+OpenMoco
+ - Time-lapse Core Engine
+
+ - Modified for DollyShield (MX2) 6/2010 changes by cchurch/dynamicperception
  
- */
+  
+  See www.openmoco.org for more information
+
+
+
+    (c) 2008-2010 C.A. Church
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+*/
+
 
 /*
 
- ========================================
- Camera control functions
- ========================================
- 
- */
+  ========================================
+  Camera control functions
+  ========================================
+  
+*/
 
 void fire_camera(unsigned long exp_tm) {
-  //Fires the camera by using the selected method.
- switch (shutter_mode){
-  case SHUTTER_MODE_IR_NIKON:
-   send_ir(IR_NIKON);
-   break;
-  case SHUTTER_MODE_IR_CANON:
-   send_ir(IR_CANON);
-   break;
-  case SHUTTER_MODE_CABLE_FOCUS:
-   digitalWriteFast(FOCUS_PIN, HIGH);
-   //Fall through
-  case SHUTTER_MODE_CABLE_NO_FOCUS:
-   digitalWriteFast(CAMERA_PIN, HIGH);
-   break;
- }
-   S_CAM_ENGAGED=true; //Set Status flag
 
+   
+    // determine if focus pin should be brought high
+    // w. the shutter pin (for some nikons, etc.)
+    
+  if( focus_shutter )
+    digitalWrite(FOCUS_PIN, HIGH);
+    
+  digitalWrite(CAMERA_PIN, HIGH);
+    // start timer to stop camera exposure
+  MsTimer2::set(exp_tm, stop_camera);
+  MsTimer2::start();
+
+    // update camera currently enaged
+    // (turn on bit)
+  run_status |= B01000000;
+  
+  return;
 }
 
 
 void stop_camera() {
- if ((shutter_mode==SHUTTER_MODE_IR_NIKON) && bulb_mode){
-   //in Nikon IR-bulb mode send command again  
-   send_ir(IR_NIKON);
-   } 
- else if ((shutter_mode==SHUTTER_MODE_IR_CANON) && bulb_mode){
-   //in Canon Nikon IR-bulb mode send command again
-     send_ir(IR_CANON);
-     }  
- else{
-  //in both cable modes
-  //we bring down both lines, just in case.. it doesnt hurt.
-    digitalWriteFast(FOCUS_PIN, LOW);
-    digitalWriteFast(CAMERA_PIN, LOW);
-   }   
-
-  //TODO
-  // are we supposed to delay before allowing
-  // the motors to move?  Register a timer
-  // to clear out status flags, otherwise
-  // just clear them out now.
-
-  // the delay is used to prevent motor movement
-  // when shot timing is controlled by the camera.
-  // the post-delay should be set to an amount greater
-  // than the max possible camera exposure timing
-
-  // update camera currently engaged
- S_CAM_ENGAGED=false;
-
-  // update camera cycle complete
- S_CAM_CYCLE_COMPLETE=true;
-
- }
+  
+  digitalWrite(CAMERA_PIN, LOW);
+ 
+    // we do this every time, because
+    // it's possible that the flag
+    // that controls whether or not to
+    // trip focus w. shutter may have
+    // been reset during our exposure,
+    // and failing to do so would keep
+    // the focus pin high for a long
+    // time.
+    
+  digitalWrite(FOCUS_PIN, LOW);
+ 
+    // turn off timer - we do this
+    // after the digitalWrite() to minimize
+    // over-shooting in case this takes some
+    // unusually-long amount of time
+    
+  MsTimer2::stop();
+
+    // are we supposed to delay before allowing
+    // the motors to move?  Register a timer
+    // to clear out status flags, otherwise
+    // just clear them out now.
+    
+    // the delay is used to prevent motor movement
+    // when shot timing is controlled by the camera.
+    // the post-delay should be set to an amount greater
+    // than the max possible camera exposure timing
+    
+      // update camera currently engaged
+  run_status &= B10111111;
+
+      // update camera cycle complete
+  run_status |= B00100000;
+   
+}
 
 
 void camera_clear() {
@@ -91,53 +106,48 @@ void camera_clear() {
   // so that motor control and other actions can 
   // be undertaken.  Used as a timer whenever
   // a camera post delay is set.
+  
+ MsTimer2::stop(); // turn off timer
+ 
+      // update camera currently engaged
+ run_status &= B10111111;
 
- S_CAM_ENGAGED=false; 
- S_CAM_CYCLE_COMPLETE=true;
-
+      // update camera cycle complete
+ run_status |= B00100000;
+ 
 }  
 
 
 
 void stop_cam_focus() {
-
-  digitalWriteFast(FOCUS_PIN, LOW);
-  //pre_focus_clear = 2;
+  
+  MsTimer2::stop();
+  digitalWrite(FOCUS_PIN, LOW);
+  pre_focus_clear = 2;
+  
 }
 
-void clear_cam_focus() {/* 
+void clear_cam_focus() {
   MsTimer2::stop();
   pre_focus_clear = 4;
- */}
-
-uint16_t calc_total_cam_tm() {
-  // calculate total minimum time between exposures 
-  // add 100ms pre-focus tap clear value
-  uint16_t pf_tm = focus_tap_tm>0?focus_tap_tm + 100:0;
-  //TODO: use all the times.
-  uint16_t total = (exp_tm + pf_tm + post_delay_tm  );
-
-  if( !m_mode==MODE_SMS ) total += m_sms_tm;
-  return(total);
-
 }
 
-void send_ir(uint8_t brand){
-  //Sends IR sequence defined in seqs at position "brand".
+float calc_total_cam_tm() {
+ 
+     // calculate total minimum time between exposures 
+     
+  byte pf_tm = 0;
   
-  //go through the sequence. length is given in position 0.
-  for(unsigned int i=1;i<=*(seqs[brand]);i++){
-    int n=*(seqs[brand] + i);
-    //make sure IR_PIN is low, necessary because of odd n
-    digitalWriteFast(IR_PIN,LOW);
-    while(n>0){
-      n--;
-      delayMicroseconds(oscd);
-      //toggle if in "on" cycle
-      if (i%2)
-      {digitalToggleFast(IR_PIN); 
-      }  
-    }
-  }
-}
+    // add 100ms pre-focus tap clear value
+  if( focus_tap_tm > 0 ) 
+    pf_tm = focus_tap_tm + 100;
+    
+  float total = (float) ( exp_tm + pf_tm + post_delay_tm  );
+  
+  if( ! motor_sl_mod )
+    total += m_sms_tm[0] + m_sms_tm[1];
+    
+  total = total / 1000.00;
 
+  return(total);
+}
diff --git a/DollyShield/ds_eeprom.ino b/DollyShield/ds_eeprom.ino
index 287be6c..db8debe 100644
--- a/DollyShield/ds_eeprom.ino
+++ b/DollyShield/ds_eeprom.ino
@@ -1,68 +1,68 @@
 /* 
- 
- El Cheapo Dollyshield -  EEPROM Functions
- modified Version of Dynamic Perception LLC's DollyShield
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC ds_eeprom.ino
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
+
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+*/
+
 /*
 
- ========================================
- EEPROM write/read functions
- ========================================
- 
- */
+  ========================================
+  EEPROM write/read functions
+  ========================================
+  
+*/
 
 
 /* 
- 
+
  *******************************
  Mapping of Data Positions in EEPROM memory
  *******************************
- 
+
  (position count starts at zero)
- //TODO
+ 
  flash enabled   = 0
  (was exp_tm)    = 1-2*
  focus_tap_tm    = 3-4
  post_delay_tm   = 5-6
  focus_shutter   = 7
- = 8-9
+                 = 8-9
  cam_max         = 10-11
- m_speeds	     = 12-13
-				 = 14-15
- m_diarev	     = 16-19
-				 = 20-23
- max_cpm	     = 24-27
-				 = 28-31
- m_rpm        	 = 32-35
-				 = 36-39
- min_cpm	     = 40-43
-				 = 44-47
- min_spd      	 = 48
-				 = 49
+ m_speeds[0]     = 12-13
+ m_speeds[1]     = 14-15
+ m_diarev[0]     = 16-19
+ m_diarev[1]     = 20-23
+ max_ipm[0]      = 24-27
+ max_ipm[1]      = 28-31
+ m_rpm[0]        = 32-35
+ m_rpm[1]        = 36-39
+ min_ipm[0]      = 40-43
+ min_ipm[1]      = 44-47
+ min_spd[0]      = 48
+ min_spd[1]      = 49
  m_min_pulse[0]  = 50
  m_min_pulse[0]  = 51
  altio_dir       = 52
-				 = 53
-				 = 54
-				 = 55 
- ui_motor_display= 56
+                 = 53
+                 = 54
+                 = 55 
+ ui_motor_display = 56
  motor_sl_mod    = 57
  lcd_dim_tm      = 58-59
  blank_lcd       = 60
@@ -97,29 +97,29 @@
  gb_enabled     = 264
  ui_invdir      = 265
  cur_bkl        = 266
- use_ir         = 267
- */
+ 
+*/
 
 
 
 
 boolean eeprom_saved() {
-
-  // read eeprom saved status
-
+  
+    // read eeprom saved status
+    
   byte saved = EEPROM.read(0);
-
-  // EEPROM memory is by default set to 1, so we
-  // set it to zero if we've written data to eeprom
+ 
+   // EEPROM memory is by default set to 1, so we
+   // set it to zero if we've written data to eeprom
   return( ! saved );
 }
 
 void eeprom_saved( boolean saved ) {
   // set eeprom saved status
-
-  // EEPROM memory is by default set to 1, so we
-  // set it to zero if we've written data to eeprom
-
+  
+   // EEPROM memory is by default set to 1, so we
+   // set it to zero if we've written data to eeprom
+  
   EEPROM.write(0, !saved);
 }
 
@@ -139,29 +139,29 @@ void eeprom_write( int pos, byte& val, byte len ) {
   for( byte i = 0; i < len; i++ )
     EEPROM.write(pos++, *p++);    
 
-  // indicate that memory has been saved
+    // indicate that memory has been saved
   eeprom_saved(true);
 
 }
-
+    
 void eeprom_write( int pos, unsigned int& val ) {
   byte* p = (byte*)(void*)&val;   
-  eeprom_write(EEPROM_TODO, *p, sizeof(int));  
+  eeprom_write(pos, *p, sizeof(int));  
 }
 
 void eeprom_write( int pos, unsigned long& val ) {
   byte* p = (byte*)(void*)&val;   
-  eeprom_write(EEPROM_TODO, *p, sizeof(long));    
+  eeprom_write(pos, *p, sizeof(long));    
 }
 
 void eeprom_write( int pos, float& val ) {
   byte* p = (byte*)(void*)&val;   
-  eeprom_write(EEPROM_TODO, *p, sizeof(float));    
+  eeprom_write(pos, *p, sizeof(float));    
 }
 
 void eeprom_write( int pos, byte& val ) {  
   EEPROM.write(pos, val);
-  // indicate that memory has been saved
+    // indicate that memory has been saved
   eeprom_saved(true);
 }
 
@@ -169,7 +169,7 @@ void eeprom_write( int pos, byte& val ) {
 
 
 
-// read functions
+ // read functions
 
 void eeprom_read( int pos, byte& val, byte len ) {
   byte* p = (byte*)(void*)&val;
@@ -191,121 +191,153 @@ void eeprom_read( int pos, unsigned int& val ) {
 
   byte* p = (byte*)(void*)&val;
   eeprom_read(pos, *p, sizeof(int));
-
+  
 }
 
 void eeprom_read( int pos, unsigned long& val ) {
 
   byte* p = (byte*)(void*)&val;
   eeprom_read(pos, *p, sizeof(long));
-
+  
 }
 
 void eeprom_read( int pos, float& val ) {
 
   byte* p = (byte*)(void*)&val;
   eeprom_read(pos, *p, sizeof(float));
-
+  
 }
-
+    
 void write_all_eeprom_memory() {
-/*
-  // write default values into eeprom
-  eeprom_write(EEPROM_TODO, focus_tap_tm);
-  eeprom_write(EEPROM_TODO, post_delay_tm);
-  eeprom_write(EEPROM_TODO, focus_shutter);
-
-  eeprom_write(EEPROM_TODO, cam_max);
-  eeprom_write(EEPROM_TODO, m_diarev);
-  eeprom_write(EEPROM_TODO, max_cpm);
-  eeprom_write(EEPROM_TODO, m_rpm);
-  eeprom_write(EEPROM_TODO, min_cpm);
-  eeprom_write(EEPROM_TODO, min_spd);
-  eeprom_write(EEPROM_TODO, m_min_pulse);
-  eeprom_write(EEPROM_TODO, altio_dir);
-  eeprom_write(EEPROM_TODO, ui_motor_display);
-  eeprom_write(EEPROM_TODO, motor_sl_mod);
-  eeprom_write(EEPROM_TODO, lcd_dim_tm);
-  eeprom_write(EEPROM_TODO, blank_lcd);
-  eeprom_write(EEPROM_TODO, m_ramp_set);
-  eeprom_write(EEPROM_TODO, m_maxsms);
-  eeprom_write(EEPROM_TODO, cam_interval);
-
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[3][4][2] 
-  // 3 * 4 * 2 * 4 = 96
 
+    // write default values into eeprom
+  eeprom_write(3, focus_tap_tm);
+  eeprom_write(5, post_delay_tm);
+  eeprom_write(7, focus_shutter);
+
+  eeprom_write(10, cam_max);
+  eeprom_write(16, m_diarev[0]);
+  eeprom_write(20, m_diarev[1]);
+  eeprom_write(24, max_ipm[0]);
+  eeprom_write(28, max_ipm[1]);
+  eeprom_write(32, m_rpm[0]);
+  eeprom_write(36, m_rpm[1]);
+  eeprom_write(40, min_ipm[0]);
+  eeprom_write(44, min_ipm[1]);
+  eeprom_write(48, min_spd[0]);
+  eeprom_write(49, min_spd[1]);
+  eeprom_write(50, m_min_pulse[0]);
+  eeprom_write(51, m_min_pulse[1]);
+  eeprom_write(52, altio_dir);
+
+  eeprom_write(56, ui_motor_display);
+  eeprom_write(57, motor_sl_mod);
+  eeprom_write(58, lcd_dim_tm);
+  eeprom_write(60, blank_lcd);
+  eeprom_write(61, m_ramp_set[0]);
+  eeprom_write(62, m_ramp_set[1]);
+  eeprom_write(63, m_maxsms[0]);
+  eeprom_write(65, m_maxsms[1]);
+  eeprom_write(67, cam_interval);
+  
+   // handle m_cal_array in a sane manner
+   // float m_cal_array[2][3][3][2] 
+   // 2 * 3 * 3 * 2 * 4 = 144
+   
   byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_write(EEPROM_TODO, *p, (3*4*2*4));
-
-  eeprom_write(EEPROM_TODO, input_type[0]);
-  eeprom_write(EEPROM_TODO, input_type[1]);
-  eeprom_write(EEPROM_TODO, ui_is_metric);
-  eeprom_write(EEPROM_TODO, m_lead_in);
-  eeprom_write(EEPROM_TODO, m_lead_out);
-  eeprom_write(EEPROM_TODO, motor_spd_cal);
-  eeprom_write(EEPROM_TODO, m_cal_constant);
-  eeprom_write(EEPROM_TODO, cam_repeat);
-  eeprom_write(EEPROM_TODO, cam_rpt_dly);
-
-  eeprom_write(EEPROM_TODO, ext_trig_pre_delay);
-  eeprom_write(EEPROM_TODO, ext_trig_pst_delay);
-  eeprom_write(EEPROM_TODO, exp_tm);
-  eeprom_write(EEPROM_TODO, gb_enabled);
-  eeprom_write(EEPROM_TODO, ui_invdir);
-  eeprom_write(EEPROM_TODO, cur_bkl);
-  eeprom_write(EEPROM_TODO, ir_remote);
-  */
+  eeprom_write(71, *p, 144);
+ 
+  eeprom_write(217, input_type[0]);
+  eeprom_write(218, input_type[1]);
+  eeprom_write(219, ui_is_metric);
+  eeprom_write(220, merlin_enabled);
+  eeprom_write(221, merlin_man_spd[0]);
+  eeprom_write(225, merlin_man_spd[1]);
+  eeprom_write(229, m_lead_in[0]);
+  eeprom_write(231, m_lead_in[1]);
+  eeprom_write(233, m_lead_out[0]);
+  eeprom_write(235, m_lead_out[1]);
+  eeprom_write(237, motor_spd_cal[0]);
+  eeprom_write(238, motor_spd_cal[1]);
+  eeprom_write(239, m_cal_constant[0]);
+  eeprom_write(243, m_cal_constant[1]);
+
+  eeprom_write(249, cam_repeat);
+  eeprom_write(250, cam_rpt_dly);
+
+  eeprom_write(252, ext_trig_pre_delay);
+  eeprom_write(256, ext_trig_pst_delay);
+  eeprom_write(260, exp_tm);
+  eeprom_write(264, gb_enabled);
+  eeprom_write(265, ui_invdir);
+  eeprom_write(266, cur_bkl);
+  
 }
 
 
-// restore memory
-
+ // restore memory
+ 
 void restore_eeprom_memory() {
-/*
-  // read eeprom stored values back into RAM
 
+    // read eeprom stored values back into RAM
+    
   eeprom_read(3, focus_tap_tm);
   eeprom_read(5, post_delay_tm);
   eeprom_read(7, focus_shutter);
 
   eeprom_read(10, cam_max);
   eeprom_read(16, m_diarev[0]);
-  eeprom_read(24, max_cpm);
+  eeprom_read(20, m_diarev[1]);
+  eeprom_read(24, max_ipm[0]);
+  eeprom_read(28, max_ipm[1]);
   eeprom_read(32, m_rpm[0]);
-  eeprom_read(40, min_cpm[0]);
+  eeprom_read(36, m_rpm[1]);
+  eeprom_read(40, min_ipm[0]);
+  eeprom_read(44, min_ipm[1]);
   eeprom_read(48, min_spd[0]);
+  eeprom_read(49, min_spd[1]);
   eeprom_read(50, m_min_pulse[0]);
+  eeprom_read(51, m_min_pulse[1]);
   eeprom_read(52, altio_dir);
-
+  
   eeprom_read(56, ui_motor_display);
   eeprom_read(57, motor_sl_mod);
   eeprom_read(58, lcd_dim_tm);
   eeprom_read(60, blank_lcd);
   eeprom_read(61, m_ramp_set[0]);
+  eeprom_read(62, m_ramp_set[1]);
   eeprom_read(63, m_maxsms[0]);
+  eeprom_read(65, m_maxsms[1]);
   eeprom_read(67, cam_interval);
-
   
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[3][4][2] 
-  // 3 * 4 * 2 * 4 = 96
-
+   // handle m_cal_array in a sane manner
+   // float m_cal_array[2][3][3][2] 
+   // 2 * 3 * 3 * 2 * 4 = 144
+   
   byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_read(71, *p, (3*4*2*4));
-
+  eeprom_read(71, *p, 144);
+ 
   eeprom_read(217, input_type[0]);
   eeprom_read(218, input_type[1]);
-
+  
   eeprom_read(219, ui_is_metric);
+  
+  eeprom_read(220, merlin_enabled);
+
+  eeprom_read(221, merlin_man_spd[0]);
+  eeprom_read(225, merlin_man_spd[1]);
 
   eeprom_read(229, m_lead_in[0]);
+  eeprom_read(231, m_lead_in[1]);
   eeprom_read(233, m_lead_out[0]);
+  eeprom_read(235, m_lead_out[1]);
 
   eeprom_read(237, motor_spd_cal[0]);
+  eeprom_read(238, motor_spd_cal[1]);
 
   eeprom_read(239, m_cal_constant[0]);
-
+  eeprom_read(243, m_cal_constant[1]);
+  
   eeprom_read(249, cam_repeat);
   eeprom_read(250, cam_rpt_dly);
 
@@ -317,41 +349,40 @@ void restore_eeprom_memory() {
   eeprom_read(264, gb_enabled);
   eeprom_read(265, ui_invdir);
   eeprom_read(266, cur_bkl);
-  eeprom_read(267, ir_remote);
-  // handle restoring alt input states
-
+  
+    // handle restoring alt input states
+    
   if( input_type[0] != 0 )
     altio_connect(0,input_type[0]);
 
   if( input_type[1] != 0 )
     altio_connect(1,input_type[1]);
-
+    
   // set lcd backlight to saved value
   ui_set_backlight(cur_bkl);
-*/
+  
 }
 
 
 
 void eeprom_versioning() {
-  // determine if eeprom version is correct 
-  // so we can automatically flush saved memory 
-  // when a new firmware is loaded 
-
-  unsigned int eeprom_ver = 0;
-  eeprom_read(247, eeprom_ver);
-
-  // wipe out any saved eeprom settings
-  if( eeprom_ver != FIRMWARE_VERSION ) {
-    eeprom_ver = FIRMWARE_VERSION;
-    eeprom_write(EEPROM_TODO, eeprom_ver);
+   // determine if eeprom version is correct 
+   // so we can automatically flush saved memory 
+   // when a new firmware is loaded 
+   
+ unsigned int eeprom_ver = 0;
+ eeprom_read(247, eeprom_ver);
+
+   // wipe out any saved eeprom settings
+ if( eeprom_ver != FIRMWARE_VERSION ) {
+  eeprom_ver = FIRMWARE_VERSION;
+  eeprom_write(247, eeprom_ver);
     // order of operations is important, this must line
-    // must happen after the eeprom_write(EEPROM_TODO, as
+    // must happen after the eeprom_write function call, as
     // it automatically updates the eeprom saved status
-    eeprom_saved(false);
-  }  
-
+  eeprom_saved(false);
+ }  
 
+   
 }
 
-
diff --git a/DollyShield/ds_merlin.ino b/DollyShield/ds_merlin.ino
new file mode 100644
index 0000000..6124435
--- /dev/null
+++ b/DollyShield/ds_merlin.ino
@@ -0,0 +1,165 @@
+/* 
+
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+*/
+
+/*
+
+  ========================================
+  Merlin mount control functions
+  ========================================
+  
+*/
+
+
+//#ifdef MERLIN_ENABLED
+
+
+void merlin_set_speed(byte axis, float spd) {
+    // set speed for axis (axes starting at zero, not 1)
+  merlin.init();  
+    
+    // TODO: convert displayed degrees to values 
+    // absolute in merlin
+    
+ // char resp[16]; - AC:20120114: not needed anymore
+
+
+  merlin_speeds[axis] = spd;
+  // AC:20120115: Set Ratio to 1 before setting speed to ensure correct calculations
+  // Ratio 3 is only used in manual move
+  merlin.setRatio(axis+1, 1);
+  merlin.setSpeed(axis+1, spd);
+}
+
+void merlin_send_angle(byte axis, float angle) {
+  
+  merlin.init();
+
+    // set motor free-running flag
+  merlin_flags |= (B10000000 >> axis);
+  
+   // AC:20120115: Switching to custom drive mode
+  // merlin.driveToPosition(axis+1, merlin_dir[axis], angle);
+  merlin.moveAngle(axis+1, merlin_dir[axis], angle);
+}
+
+byte merlin_running(byte axis) {
+  
+  merlin.init();
+  return merlin.readAxisStatus(axis+1);
+}
+
+void merlin_stop(byte axis) {
+  merlin.init();
+  
+    // disable running bit flag
+    
+  merlin_flags &= (B11111111 ^ (B10000000 >> axis));
+  
+  merlin.stopMoving(axis+1);
+  
+}
+
+void merlin_run(byte axis) {
+  merlin.init();
+  
+    // already running
+  if( merlin_flags & (B10000000 >> axis) ) 
+    return;
+
+    // enable running flag
+  merlin_flags |= (B10000000 >> axis);
+
+    // for continuous motion, our speeds are based
+    // on 1x ratio
+    
+    // AC:20120114: removed as ratio is set in set_speed()
+ // merlin.setRatio(axis+1, 1); 
+  
+  merlin.startMoving(axis+1, merlin_dir[axis]);
+}
+
+// AC:20120114: added function for manual move in the menu
+void merlin_move_manual(byte axis, byte dir) {
+  
+  // moving at ratio 3 as it works better with higher load (does not slip)
+  merlin.init();
+  merlin.setRatio(axis+1, 3);
+  merlin.setSpeed(axis+1, merlin_man_spd[axis]);
+  merlin_set_dir(axis,dir);
+  merlin_run(axis);
+}
+
+
+void merlin_set_dir(byte axis, byte dir) {
+ 
+  merlin_wasdir[axis] = merlin_dir[axis];
+  merlin_dir[axis]    = dir;
+  // AC:20120115: melrin library will call setDirection internally
+  // inside startMoving or moveAngle
+  // merlin.setDirection(axis+1,dir);
+  
+}
+  
+
+
+
+void show_merlin() {
+  
+ merlin_flags |= B00100000;
+
+ lcd.clear();
+ lcd.noBlink();
+
+ lcd.setCursor(0, 0);
+
+ lcd.print("Scope Manual");
+ 
+ lcd.setCursor(0,1);
+ 
+ lcd.print("Enter to Exit");
+ 
+  
+}  
+
+void merlin_init() {
+    merlin.init();
+}
+
+
+void merlin_run_cont() {
+
+  // run in continuous mode
+
+  if( ! (merlin_flags & B10000000) && merlin_speeds[0] > 0.0 ) {
+    merlin_set_dir(0, merlin_dir[0]);
+    merlin_run(0);
+  }
+  
+  if( ! (merlin_flags & B01000000) && merlin_speeds[1] > 0.0 ) {
+    merlin_set_dir(1, merlin_dir[1]); // dir may not have been set on
+                                      // first run if dir not modified in UI
+    merlin_run(1);
+  }
+
+}
+
+//#endif
diff --git a/DollyShield/ds_motor.ino b/DollyShield/ds_motor.ino
index e0e6309..b259904 100644
--- a/DollyShield/ds_motor.ino
+++ b/DollyShield/ds_motor.ino
@@ -1,391 +1,557 @@
-/*
+/* 
+
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+*/
 
- El Cheapo Dollyshield - Motor control functions
- modified Version of Dynamic Perception LLC's DollyShield
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC ds_motor.ino
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
 /*
 
- ========================================
- Motor control functions
- ========================================
- 
- */
+  ========================================
+  Motor control functions
+  ========================================
+  
+*/
 
 
-void motor_speed_adjust(int val, boolean spd_floor ) {
+void motor_speed_adjust( byte motor, int val, boolean spd_floor ) {
 
-  byte c_speed = 0;
-  // val is expected to be between -255 and 255;
+   byte c_speed = 0;
+    // val is expected to be between -255 and 255;
 
-  if( (int) m_speed+ val >= 255 ) {
+   if( (int) m_speeds[motor] + val >= 255 ) {
     c_speed = 255;
+   }
+   else {
+     c_speed = (int) m_speeds[motor] + val >= 0 ? m_speeds[motor] + val : 0;
+       // do we need to floor the value at the min speed setting? (man control)
+     if( spd_floor ) 
+       c_speed = c_speed < min_spd[motor] ? min_spd[motor] : c_speed;
+   }
+
+   motor_set_speed( motor, c_speed );   
+   
+}
+
+void motor_control(byte motor, boolean state) {
+
+   // turn motors on or off
+ 
+  if( ! state ) {
+      // set motors as not running
+
+    unsigned int ths_spd = m_speeds[motor];
+           
+    motor_set_speed( motor, 0 );
+ 
+    m_speeds[motor] = ths_spd;
+    mcur_spds[motor] = ths_spd;
+
+    run_status &= B11101111;
+    
   }
   else {
-    c_speed = (int) m_speed + val >= 0 ? m_speed + val : 0;
-    // do we need to floor the value at the min speed setting? (man control)
-    if( spd_floor )
-      c_speed = c_speed < min_spd ? min_spd : c_speed;
+      // set motors as running...
+    run_status |= B00010000;
+    if( mcur_spds[motor] > 0 )
+      motor_set_speed(motor, mcur_spds[motor]);
   }
+}
 
-  motor_set_speed(c_speed );
 
-}
 
-void motor_control(boolean state) {
+void motor_set_speed( byte motor, unsigned int m_speed ) {
+
+  
+  if( motor >= MAX_MOTORS )
+    return;
+    
+  m_speeds[motor] = m_speed;
+  m_sms_tm[motor] = 0;
+  
+        
+
+  if( ! motor_sl_mod && ! (ui_ctrl_flags & B00000100) ) {
 
-  // turn motor on or off
+      // handle when in interleaved mode and not on
+      // manual control screen
+      
+    float m_pct = ( (float) m_speed / (float) m_maxsms[motor] );  
+
+    m_sms_tm[motor] = 60000.0 * m_pct;
+    
+    // calibrate
+    m_sms_tm[motor] *= motor_cal_adjust(0,motor,0,m_wasdir[motor]);
 
-  if( ! state ) {
-    //turn off
-    motor_set_speed( 0 );
-    m_cur_speed = 0;
-    S_MOT_RUNNING=false;
   }
   else {
-    // set motors as running...
-    S_MOT_RUNNING=true;
-    if( m_cur_speed > 0 ) motor_set_speed(m_cur_speed);
+    
+      // normalize to max pwm speed
+    m_speed = m_speed > 255 ? 255 : m_speed;
+      
+    m_speeds[motor] = m_speed;
   }
+  
 
-}
+    // do we need to go into pulsing mode?
+    
+  if( m_speed > 0 && m_speed < min_spd[motor]  ) {
+      
+    motor_calc_pulse_len(motor, m_speed, false);
+    
+  } //      
+  else {
+    on_pct[motor] = 0;
+  }
+  
+  
 
-void motor_set_speed( unsigned int speed ) { //TODO datatype of m_speed.
-//TODO: Calibration
-  if (speed==0)
-    //called to disable motor.
-    S_MOT_RUNNING=false;
-  m_sms_tm=0; //disables if in sms-mode
-  m_cur_speed=0; //disables if in cont.-mode
-  alt_io_motor_set(0); //disables slow mode too.
-  return;
-  if (!(ui_ctrl_flags&UI_MANUAL_MODE)){ 
-    //not in manual mode and motors running
-    if (m_mode==MODE_SMS){
-      //SMS mode
-      //calculate times
-      ;
-    }
-    else if (speed<min_spd){
-      //speed below min_speed, so use pulsing mode
-      m_cur_speed=speed;
-      if (S_MOT_RUNNING) alt_io_motor_set_slow(m_cur_speed); //write only to motor if running!
-    }
-    else{
-      //continous mode
-      m_cur_speed=speed;
-      if (S_MOT_RUNNING) alt_io_motor_set(m_cur_speed); //write only to motor if running!
-    }
+  byte motor_pin = motor >= 1 ? MOTOR1_P : MOTOR0_P;
+  
+  if( ! (run_status & B00010000)  ) {
+    // if disabled, do not move motor, but
+    // instead adjust stored speed
+    mcur_spds[motor] = m_speed;
+    return;
+  }
+  else if( ! (ui_ctrl_flags & B00000100) && m_sms_tm[motor] > 0 ) {
+      // just in case
+    digitalWrite(motor_pin, LOW);
+      // return if we're in an SMS condition
+      // and not in manual mode
+    return;
   }
-  else{
-    //manual mode
+
+    // if we've made it this far, set motor pin
+    // to given analog speed
+
+    // only set analog speed if it exceeds min speed
+
+  if( m_speed >= min_spd[motor] ) {
+    analogWrite(motor_pin, m_speed);
   }
+  else {
+    // just in case... switching down from 
+    // pwm to pulsed...
+    digitalWrite(motor_pin,LOW);
+  }
+  
 }
 
-void motor_dir(byte dir ) {
-//TODO: SMS
-  if( m_dir == dir ) //already running in the right direction
-    return;
+void motor_calc_pulse_len(byte motor, unsigned int m_speed, boolean ignore_cal) {
+    // for how many periods should the motor be on and
+    // off? (pulsing mode)     
 
-  // get current speed for the motor and save it for writing back later
-  byte ths_speed = m_cur_speed;
+    float m_pct   = ( (float) m_speed / 255.0 );
+    float periods = 1333.0; // 25 times a second 
+    
+    on_pct[motor] = periods * m_pct; 
+    off_pct[motor] = (float) (periods - on_pct[motor]);
+      
+    float cal_amt = motor_cal_adjust(1,motor,m_speed, m_wasdir[motor]);
+    
+      // calibrate, if desired
+    if( ! ignore_cal && cal_amt != 1.0 )
+      off_pct[motor] = ( (double) off_pct[motor] * ( cal_amt * m_cal_constant[motor] )  ); 
+        
+    if(on_pct[motor] < 1)
+      on_pct[motor] = 1;
+
+    // make sure that we're on for a minimum amount of time
+    
+   if ( on_pct[motor] != 0 && on_pct[motor] < m_min_pulse[motor] ) {
+       // adjust so that off time is increased relative to on time
+     float diff = (float) m_min_pulse[motor] / (float) on_pct[motor];       
+     off_pct[motor] = ((float) off_pct[motor] * diff);
+     on_pct[motor] = m_min_pulse[motor];
+   }
+ 
+}
 
+void motor_dir( byte motor, byte dir ) {
+  
+  if( m_wasdir[motor] == dir )
+    return;
+ 
+   // get current speed for the motor
+  byte ths_speed = m_speeds[motor];
+    
+    // find direction pin
+  byte m_dirp = motor >= 1 ? MOTOR1_DIR : MOTOR0_DIR;
 
+    // reverse direction of motor #1, as the hardware
+    // has the directions reversed.
+    
+  byte m_dirc = motor >= 1 ? !dir : dir;
+  
   if( ths_speed > 0 ) {
-    // motor was already moving, need to stop
-    // and let motor settle before moving
-    // stop motor
-    motor_set_speed( 0 );
-    delay(100);
+      // motor was already moving, need to stop
+      // and let motor settle before moving
+      // stop motor
+    motor_set_speed( motor, 0 );
+    delay(100);    
   }
 
-
-  digitalWriteFast(MOTOR0_DIR, dir);
-  m_dir = dir;
-  //writing back saved speed
-  motor_set_speed( ths_speed );
+  
+  digitalWrite(m_dirp, m_dirc);  
+  m_wasdir[motor] = dir;
+  motor_set_speed( motor, ths_speed );
 }
+  
 
-
-float motor_calc_cpm(unsigned int spd, boolean ths_mode) {
-/*
- // calculate ipm for a given speed and mode
+float motor_calc_ipm(byte motor, unsigned int spd, boolean ths_mode) {
+  // calculate ipm for a given speed and mode
 
     // get max speed for either pulse or sms mode
-  // on calibration screen, always ch
-
-  float maxspd = ( ! ths_mode ) ? (float) m_maxsms : 255.0;
+    // on calibration screen, always ch
 
-  // in manual mode, we're always in 0-255 mode
-  if( ui_ctrl_flags & B00000100 )
+  float maxspd = ( ! ths_mode ) ? (float) m_maxsms[motor] : 255.0;
+  
+    // in manual mode, we're always in 0-255 mode
+  if( ui_ctrl_flags & B00000100 ) 
     maxspd = 255.0;
+    
+  float cur_ipm = (float) max_ipm[motor] * ( (float) spd / (float) maxspd );      
+  
+  return(cur_ipm);
+}
 
-  float cur_ipm = (float) max_cpm * ( (float) spd / (float) maxspd );
 
-  return(cur_ipm);
-  */
-return (0.0);
+void motor_update_dist(byte motor, float rpm, float diarev ) {
+    // set distance settings when rpm or diarev change
+    
+  max_ipm[motor] = rpm * diarev;
+  min_spd[motor] = 255 * ( min_ipm[motor] / max_ipm[motor] );
+  m_maxsms[motor] = max_ipm[motor] * 100;
+  
+  eeprom_write(24, max_ipm[0]);
+  eeprom_write(28, max_ipm[1]);
+  eeprom_write(48, min_spd[0]);
+  eeprom_write(49, min_spd[1]);
+  eeprom_write(63, m_maxsms[0]);
+  eeprom_write(65, m_maxsms[1]);
+
 }
 
+void motor_pulse() {
 
+    // this function is called by timer1 to pulse motors
+    // on and off in pulsing mode
+    
+  if( ! timer_engaged )
+    return;
+        
+  volatile static byte mstate[2] = {0,0};
+  volatile static unsigned long pulses[2]  = {1,1};
 
-void motor_update_dist(float rpm, float diarev ) {
+  volatile static byte pos = 0;
   
-  // set distance settings when rpm or diarev change
-   
-   max_cpm = rpm * diarev;
-   min_spd = 255 * ( min_cpm / max_cpm );
-   m_maxsms= max_cpm * 100; //TODO
-   
-   eeprom_write(EEPROM_TODO, max_cpm);
-   eeprom_write(EEPROM_TODO, min_spd);
-   eeprom_write(EEPROM_TODO, m_maxsms);
-   
+  pos++;
+  
+  
+  for( byte i = 0; i < MAX_MOTORS; i++ ) {
+      if( on_pct[i] > 0 ) {
+      // speed is below min cont. speed
+      
+        if( ! mstate[i] ) {
+          if( pulses[i] < off_pct[i] ) {
+            pulses[i]++;
+            continue;
+          }
+          else {            
+              // set port value high for given motor
+            PORTD |= (B00100000 << i);  
+            //analogWrite(5, 165);
+            mstate[i] = 1;
+            pulses[i] = 1;
+          }
+        }
+        else {
+          if( pulses[i] < on_pct[i] ) {
+            pulses[i]++;
+            continue;
+          }
+          else {
+            
+              // set port value low for given motor
+            //analogWrite(5, 0);
+            PORTD &= ( B11111111 ^ ( B00100000 << i ) ); 
+            mstate[i] = 0;
+            pulses[i] = 1;
+          }
+        } // end else not mstate...
+      }  // end if on_pct...
+  }  // end for
+    
 }
 
-/*void motor_pulse() { //TODO
-  // this function is called by timer1 to pulse motors
-   // on and off in pulsing mode
-   
-   if( ! timer_engaged )
+
+
+void run_motor_sms(byte motor) {
+
+ if( motor >= MAX_MOTORS ) {
    return;
+ }
+
+  cur_motor = motor;
+  motor = motor >= 1 ? MOTOR1_P : motor;
+  motor = motor == 0 ? MOTOR0_P : motor;
+ 
+ analogWrite(motor, 255);
+
+} 
+
+void stop_motor_sms() {
+
+ MsTimer2::stop();
+  
+  byte motor = cur_motor;
+  
+  motor = motor >= 1 ? MOTOR1_P : motor;
+  motor = motor == 0 ? MOTOR0_P : motor;
+ 
+ analogWrite(motor, 0);
+
+ motor_ran++;
+ 
+} 
+
+void motor_set_ramp(byte motor, byte ramp) {
+    // set motor ramp value, adjust
+    // associated values
+
    
-   volatile static byte mstate=0;
-   volatile static unsigned long pulses=1;
-   
-   volatile static byte pos = 0;
-   
-   pos++;
+   if( motor > MAX_MOTORS )
+     return;
    
+   m_ramp_set[motor]   = ramp > 255 ? 255 : ramp;
    
-   if( on_pct > 0 ) {
-   // speed is below min cont. speed
+    // calculate speed change per shot  
+   if( ramp > 0 ) {
+     m_ramp_shift[motor] = (float) m_speeds[motor] / ramp;
+     
+       // if there's less than one step per jump,
+       // we need to skip shots between increases
+       // so determine how many shots to skip
+      
+     if( m_ramp_shift[motor] < 1 ) {
+       m_ramp_mod[motor] = ramp / m_speeds[motor];
+       m_ramp_mod[motor] = m_ramp_mod[motor] < 2 ? 2 : m_ramp_mod[motor];
+       m_ramp_shift[motor] = 1.0;
+     }
+     else {
+       m_ramp_mod[motor] = 0;
+     }
    
-   if( ! mstate ) {
-   if( pulses < off_pct ) {
-   pulses++;
-   continue;
-   }
-   else {
-   // set port value high for given motor
-   //  PORTD |= (B00100000 << i);
-   digitalWriteFast(MOTOR0_P,HIGH);
-   mstate = 1;
-   pulses = 1;
-   }
    }
    else {
-   if( pulses < on_pct ) {
-   pulses++;
-   continue;
-   }
-   else {
-   
-   // set port value low for given motor
-   //   PORTD &= ( B11111111 ^ ( B00100000 << i ) );
-   digitalWriteFast(MOTOR0_P,LOW);
-   mstate[i] = 0;
-   pulses[i] = 1;
+     m_ramp_shift[motor] = 0;
+     m_ramp_mod[motor]   = 0;
    }
-   } // end else not mstate...
-   }  // end if on_pct...
-   
-  
-}
- */
+      
 
+}  
 
-void run_motor_sms() {
-  digitalWriteFast(MOTOR0_P,HIGH);
-}
 
-void stop_motor_sms() {
-  digitalWriteFast(MOTOR0_P,LOW);   
-  motor_ran++;
+void motor_stop_all() {
+  // stop all motors
+  
+      // disable pulsing interrupt if engaged
+  if( timer_engaged ) {
+    Timer1.detachInterrupt();
+    timer_engaged = false;
+  }
+
+  digitalWrite(MOTOR0_P, LOW);
+  digitalWrite(MOTOR1_P, LOW);
+  
+  motor_control(0, false);
+  motor_control(1, false);
+  
+  
+
 }
 
-void motor_set_ramp() {
-  //TODO: SMS!!
-  //to be called after a shoot to adjust speed for next one.
 
-  if (shots<=m_lead_in){
-    //during m_lead_in
-    m_cur_speed=0;
+float motor_cal_adjust(byte type, byte motor, byte m_spd, byte dir) {
+  
+  if( motor > 1 )
+    return(1.0);
+  
+  
+      // simplistic for sms mode
+  if( type == 0 ) 
+    return(m_cal_array[motor][m_angle[motor]][0][dir]);
+    
+    // determine which calibration position we fall
+    // into
+    
+  byte pos = 0;
+  
+    // if between two cal points, get position between them
+  byte cal_diff = motor_spd_cal[1] - motor_spd_cal[0];
+  byte hi_diff  = 255 - motor_spd_cal[1];
+  
+  if ( m_spd > motor_spd_cal[0] && m_spd < motor_spd_cal[1] ) {
+    unsigned int diff = m_spd - motor_spd_cal[0];
+    float diff_pct = (float) diff / (float) cal_diff;
+    float ret = ( m_cal_array[motor][m_angle[motor]][2][dir] * diff_pct ) + ( m_cal_array[motor][m_angle[motor]][1][dir] * ( 1.0 - diff_pct ) );
+    return(ret);
+  }
+  else if( m_spd > motor_spd_cal[1] ) {
+      // between last cal point and max speed
+    unsigned int diff = m_spd - motor_spd_cal[1];
+    float diff_pct = (float) diff / (float) hi_diff;
+    float ret = m_cal_array[motor][m_angle[motor]][2][dir] - (m_cal_array[motor][m_angle[motor]][2][dir] * diff_pct);
+    return(ret);
+  }
+  else if( m_spd <= motor_spd_cal[0] ) {
+    pos = 1;
+  }
+  else if( m_spd == motor_spd_cal[1] ) {
+    pos = 2;
   }
-  else if (shots<=(m_lead_in+m_ramp_in)){
-    //during m_ramp_in
-    //calculate speed
-    uint8_t speed_step;
-    uint8_t remaining_shots_for_ramp=(m_lead_in+m_ramp_in)-shots+1; //TODO
-    speed_step=(m_speed-m_cur_speed)/(remaining_shots_for_ramp+1);
-    m_cur_speed+=speed_step;
-  }  
-  else if (cam_max>0){
-    //ramp and lead out only make sense if max. shots are set.
-    if (shots<(cam_max-m_lead_out-m_ramp_out)){
-      //during normal mode
-      m_cur_speed=m_speed;
-    }
-    else if (shots<(cam_max-m_lead_out)){
-      //during m_ramp_out
-      //calculate speed
-      uint8_t speed_step;
-      uint8_t remaining_shots_for_ramp=cam_max-lead_out-shots;
-      speed_step=(m_cur_speed)/(remaining_shots_for_ramp+1);
-      m_cur_speed+=speed_step;
-    } 
-    else{
-        //during m_lead_out or finished.
-        m_cur_speed=0;
-    }
-  }  
   else {
-    //no cam_max set. so normal mode.
-    m_cur_speed=m_speed;
+    return(1.0);
   }
+  
+  return(m_cal_array[motor][m_angle[motor]][pos][dir]);
 }
-   
-float motor_cal_adjust(byte type, byte speed, byte dir) {
-   
-   //TODO: ber calibration array nachdenken.
-   
- 
-  if( type == MODE_SMS )
-    //sms mode
-    return(m_cal_array[m_angle][CALPOINT_SMS][dir]);
-  if (speed<min_spd) {
-    //pulse
-    return m_cal_array[m_angle][CALPOINT_PULSE][dir]);
+  
+
+void motor_run_pulsing() {
+  
+    // start pulsing motor movement
+  
+  if( ! timer_engaged ) {
+
+    // we use timer1, which disables pwm on
+    // lcd bkl pin
+    if( cur_bkl > 0 ) {
+      digitalWrite(LCD_BKL, HIGH);
     }
-  else{
-    //cont mode
-    // determine which calibration position we fall
-    // into
-   
-    byte pos = 0;
-   
-    // if between two cal points, get position between them
-    byte cal_diff = motor_spd_cal[CALPOINT_HIGH] - motor_spd_cal[CALPOINT_LOW];
-    byte hi_diff  = 255 - motor_spd_cal[1];
-   
-    if ( speed> motor_spd_cal[0] && speed < motor_spd_cal[1] ) {
-      //between
-      //calculate percentage of "low" and "high" to use
-      unsigned int diff = speed - motor_spd_cal[0];
-      float diff_pct = (float) diff / (float) cal_diff;
+    else {
+      digitalWrite(LCD_BKL, LOW);
+    }
+      
+    digitalWrite(MOTOR0_P, LOW);
+    digitalWrite(MOTOR1_P, LOW);
+    
+    Timer1.initialize(MP_PERIOD);
+    Timer1.attachInterrupt(motor_pulse);
+    timer_engaged = true;
+    timer_used = true;
+          
+ }
+}
+
+void motor_execute_ramp_changes() {
+  
+      // check for ramping, and ramp up or down as needed
+      
+
+  for(byte m = 0; m < MAX_MOTORS; m++) {
+      // no ramp, go to next motor
+    if( m_ramp_set[m] == 0 )
+      continue;
     
-      float ret = ( m_cal_array[m_angle[0]][CALPOINT_HIGH][dir] * diff_pct ) + ( m_cal_array[m_angle[0]][CALPOINT_LOW][dir] * ( 1.0 - diff_pct ) );
-      return(ret);
+      // handle lead-in
+    if( shots <= m_lead_in[m] ) {
+      motor_set_speed(m, 0); 
+      continue;  
     }
-    else if( speed> motor_spd_cal[1] ) {
-      // between high cal point and max speed
-      unsigned int diff = speed - motor_spd_cal[1];
-      float diff_pct = (float) diff / (float) hi_diff;
-      // float ret = m_cal_array[0][m_angle[0]][2][dir] - (m_cal_array[0][m_angle[0]][2][dir] * diff_pct); //TODO
-      float ret = m_cal_array[m_angle][CALPOINT_HIGH][dir] - (m_cal_array[m_angle][CALPOINT_HIGH][dir] * diff_pct);
-      return(ret);
+      
+      // ramp up?
+    if( m_ramp_set[m] >= ( shots - m_lead_in[m]) ) {
+        // if ramping less than once per shot 
+      if( m_ramp_mod[m] > 0 && ( shots - m_lead_in[m] ) % m_ramp_mod[m] == 0 ) {
+        motor_set_speed(m, m_speeds[m] + 1);
+      }
+      else if( m_ramp_mod[m] == 0 ) {  
+        motor_set_speed(m, (m_ramp_shift[m] * (shots - m_lead_in[m]) ) );
+      }
     }
-    else if( speed <= motor_spd_cal[0] ) {
-      //below or at low point
-      return(m_cal_array[m_angle][CALPOINT_LOW][dir]);
+    else if( (cam_max - shots - m_lead_out[m]) <= m_ramp_set[m] ) {
+        // ramping down, it seems
+      if( m_ramp_mod[m] > 0 && (cam_max - shots - m_lead_out[m]) % m_ramp_mod[m] == 0 ) {
+        byte m_spd = m_speeds[m] > 0 ? m_speeds[m] - 1 : 0;
+        motor_set_speed(m, m_spd);
+      }
+      else if( m_ramp_mod[m] == 0 ) {  
+        motor_set_speed(m, m_ramp_shift[m] * (cam_max - shots - m_lead_out[m]) );
+      }
     }
-    else if( speed == motor_spd_cal[1] ) {
-      //at high point
-      return(m_cal_array[m_angle][CALPOINT_HIGH][dir]);
-   }
-   else {
-     //where are we now? //TODO
-    return(1.0);
-   }
   }
+      
 }
 
-uint16_t calc_min_cam_max(){
-  uint16_t min_cam_max;
-  min_cam_max=m_ramp_in+m_ramp_out;
-  //if one of the ramps is enabled we need to more max shots than ramp shots
-  if (min_cam_max>0) min_cam_max+=2;
-  min_cam_max+=m_lead_in;
-  min_cam_max+=m_lead_out;
-  return min_cam_max;
-}
 
 void motor_run_calibrate(byte which, unsigned int mspd, byte dir) {
-  /* Serial.print("w:");
-   Serial.println(which);
-   Serial.print("msp:");
-   Serial.println(mspd);
-   
-   byte cur_dir = m_dir[0];
-   motor_dir(dir);
-   
-   if( which == 1 ) {
-   Serial.print("maxs:");
-   Serial.println(m_maxsms[0]);
-   float m_pct = ( (float) mspd / (float) m_maxsms[0] );
-   unsigned int run_tm = 60000.0 * m_pct;
-   Serial.print("pct:");
-   Serial.println(m_pct);
-   
-   motor_ran = 0;
-   
-   run_motor_sms();
-   MsTimer2::set(run_tm, stop_motor_sms);
-   MsTimer2::start();
-   
-   while( ! motor_ran )
-   continue;
-   
-   return;
-   }
-   else {
-   Serial.println("pulsing");
-   byte was_on_pct = on_pct[0];
-   byte was_off_pct = off_pct[0];
-   
-   motor_calc_pulse_len(mspd, true);
-   
-   unsigned long run_tm = millis();
-   Serial.println("start");
-   motor_run_pulsing();
-   
-   // main loop is ~ 10% slower than calibration loop
-   while( millis() - run_tm < 58000 ) {
-   // introduce timing block delay similar to main loop
-   int foo = analogRead(BUT_PIN);
-   }
-   Serial.println("stop");
-   motor_stop_all();
-   
-   on_pct[0]  = was_on_pct;
-   off_pct[0] = was_off_pct;
-   
-   }
-   
-   motor_dir(cur_dir);
-   */
-}
-
-
-
+  
 
+  byte cur_dir = m_wasdir[cur_motor];
+  motor_dir(cur_motor, dir);
+  
+  if( which == 1 ) {
+    float m_pct = ( (float) mspd / (float) m_maxsms[cur_motor] );  
+    unsigned int run_tm = 60000.0 * m_pct;
+    
+    motor_ran = 0;
+    
+    run_motor_sms(cur_motor);
+    MsTimer2::set(run_tm, stop_motor_sms);
+    MsTimer2::start();
+    
+    while( ! motor_ran )
+      continue;
+    
+    return;
+  }
+  else {
 
+       byte was_on_pct = on_pct[cur_motor];
+       byte was_off_pct = off_pct[cur_motor];     
+
+       motor_calc_pulse_len(cur_motor, mspd, true);
+       
+       unsigned long run_tm = millis();
+       
+       motor_run_pulsing();
+       
+         // main loop is ~ 10% slower than calibration loop
+       while( millis() - run_tm < 58000 ) {
+           // introduce timing block delay similar to main loop
+         int foo = analogRead(BUT_PIN);
+       }
+
+       motor_stop_all();
+         
+       on_pct[cur_motor]  = was_on_pct;
+       off_pct[cur_motor] = was_off_pct;
 
+  }
+  
+  motor_dir(cur_motor, cur_dir);
+  
+}
 
 
+  
+  
+         
+  
diff --git a/DollyShield/ds_ui.ino b/DollyShield/ds_ui.ino
index 2dd4239..6400724 100644
--- a/DollyShield/ds_ui.ino
+++ b/DollyShield/ds_ui.ino
@@ -1,180 +1,186 @@
 /* 
- 
- El Cheapo Dollyshield - UI Functions
- modified Version of Dynamic Perception LLC's DollyShield ds_ui.ino
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
-
-/*
-
- ========================================
- Core UI functions
- ========================================
- 
- */
-
 
-void init_user_interface() {
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
 
-  pinMode(LCD_BKL, OUTPUT);
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
-  // turn on lcd backlight
-  analogWrite(LCD_BKL, 255);
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-  // init lcd to 16x2 display
-  lcd.begin(16, 2);
-  lcd.setCursor(0,0);
 
-  // clear and turn on autoscroll
-  lcd.clear();
-  //lcd.autoscroll();
+*/
 
-  // banner
 
-  lcd.print("(c) DP / FZ");
+/*
 
-  lcd.setCursor(5,1);
-  lcd.print("GPLv3");
+  ========================================
+  Core UI functions
+  ========================================
+  
+*/
 
-  delay(750);
 
-  lcd.clear(); 
+void init_user_interface() {
 
-  lcd.setCursor(0,0); 
-  lcd.print("El Cheapo");
-  lcd.setCursor(3,1);
-  lcd.print("Ver 0.92.01");
+  pinMode(LCD_BKL, OUTPUT);
+  
+    // turn on lcd backlight
+  analogWrite(LCD_BKL, 255);
 
-  // setup button input
+    // init lcd to 16x2 display
+  lcd.begin(16, 2);
+  lcd.setCursor(0,0);
 
-    pinMode(BUT_PIN, INPUT);   
-  // enable internal pull-up
-  digitalWriteFast(BUT_PIN, HIGH);
+    // clear and turn on autoscroll
+ lcd.clear();
+ //lcd.autoscroll();
+ 
+   // banner
+   
+ lcd.print("(c) 2012 Dynamic");
+ 
+ lcd.setCursor(5,1);
+ lcd.print("Perception");
 
+ delay(750);
 
-  // set the update screen flag (draw main
-  // screen)
-  ui_ctrl_flags |= B10000000;
+ lcd.clear(); 
 
-  delay(3000);
+ lcd.setCursor(0,0); 
+ lcd.print("MX2 Dolly Engine");
+ lcd.setCursor(3,1);
+ lcd.print("Version 0.92");
+ 
+   // setup button input
 
+ pinMode(BUT_PIN, INPUT);   
+   // enable internal pull-up
+ digitalWrite(BUT_PIN, HIGH);
+ 
+ 
+   // set the update screen flag (draw main
+   // screen)
+ ui_ctrl_flags |= B10000000;
+ 
+ delay(3000);
+ 
 }
 
 
 void check_user_interface() {
+  
 
-
-  // turn off/on lcd backlight if needed
-  if( (ui_ctrl_flags & B00000010) && (input_last_tm < (millis() - (lcd_dim_tm * 1000))) ) {
-
+    // turn off/on lcd backlight if needed
+  if( ui_ctrl_flags & B00000010 && input_last_tm < millis() - (lcd_dim_tm * 1000) ) {
+    
     ui_ctrl_flags &= B11111101;
-
+    
     if( blank_lcd ) 
       lcd.noDisplay();
-
-    digitalWrite(LCD_BKL, 0);
+      
+    digitalWrite(LCD_BKL, LOW);
   }
-  else if( (! (ui_ctrl_flags & B00000010)) && (input_last_tm > millis() - (lcd_dim_tm * 1000)) ) {
+  else if( ! (ui_ctrl_flags & B00000010) && input_last_tm > millis() - (lcd_dim_tm * 1000) ) {
     ui_ctrl_flags |= B00000010;
-
+    
     lcd.display();
+    
     analogWrite(LCD_BKL, cur_bkl);
   }
-
-  // if we're set to update the display
-  // (on-demand or once a second when not
-  // in a menu)
+  
+    // if we're set to update the display
+    // (on-demand or once a second when not
+    // in a menu)
   if( ui_ctrl_flags & B10000000 ||
-    ( (ui_update_tm < millis() - 1000) && ! (ui_ctrl_flags & B01000000) ) ) {
-
-    // determine whether to show home or manual screen      
+      ( (ui_update_tm < millis() - 1000) && ! (ui_ctrl_flags & B01000000) ) ) {
+  
+      // determine whether to show home or manual screen      
     if( ! ( ui_ctrl_flags & B00000100 ) ) {
       show_home();
     }
-
+    
+//#ifdef MERLIN_ENABLED
+    else if( merlin_flags & B00100000 ) {
+      show_merlin();
+    }
+//#endif
 
     else {
       show_manual();
     }
-
+     
     ui_ctrl_flags &= B01111111;
     ui_update_tm = millis();
   }
-
+  
   byte held = ui_button_check();
-
-  // make sure to turn off motor if in manual
-  // control and no button is held
-  if( ui_ctrl_flags & B00000100 && held == false &&  S_MOT_RUNNING)//run_status & B00010000
-    motor_control( false);
-
+  
+      // make sure to turn off motor if in manual
+      // control and no button is held
+  if( ui_ctrl_flags & B00000100 && held == false && run_status & B00010000 )
+    motor_control(cur_motor, false);
+ 
 
 }
 
 
 byte ui_button_check() {
 
-  static byte hold_but_cnt = 0;
-
-  get_button_pressed();
-
-  boolean held = false;
-
-  for( byte i = BUT0; i <= BUT4; i++) {
-    byte bt_press = is_button_press( i );
-
-    if( bt_press == 0 )
-      continue;
-
-    if(  bt_press == 1 && millis() - input_last_tm > HOLD_BUT_MS ) {
-      // button is pressed        
-
-      hold_but_cnt  = 0;
-      inp_val_mult  = 1;
-      input_last_tm = millis();
-      handle_input(i, false);
-
-    }
-    else if( bt_press == 2 ) {
-      held = true;
-      // button being held
-      if( hold_but_tm <= millis() - HOLD_BUT_MS) {
-        hold_but_tm   = millis();
-        input_last_tm = millis();
-
-        handle_input(i, true);
-
-        hold_but_cnt++;
-
-        if( hold_but_cnt >= 8 ) {
-          inp_val_mult = inp_val_mult >= 1000 ? 1000 : inp_val_mult * HOLD_BUT_VALINC;
-          hold_but_cnt = 0;
-        }
-
-      }
-
-    } // end else if button press state == 2
-
-  } // end for loop
+ static byte hold_but_cnt = 0;
+  
+ get_button_pressed();
 
-  return(held);
+ boolean held = false;
+ 
+ for( byte i = BUT0; i <= BUT4; i++) {
+   byte bt_press = is_button_press( i );
+   
+   if( bt_press == 0 )
+     continue;
+   
+   if(  bt_press == 1 && millis() - input_last_tm > HOLD_BUT_MS ) {
+       // button is pressed        
+
+     hold_but_cnt  = 0;
+     inp_val_mult  = 1;
+     input_last_tm = millis();
+     handle_input(i, false);
 
+   }
+   else if( bt_press == 2 ) {
+     held = true;
+     // button being held
+     if( hold_but_tm <= millis() - HOLD_BUT_MS) {
+       hold_but_tm   = millis();
+       input_last_tm = millis();
+               
+       handle_input(i, true);
+       
+       hold_but_cnt++;
+       
+       if( hold_but_cnt >= 8 ) {
+         inp_val_mult = inp_val_mult >= 1000 ? 1000 : inp_val_mult * HOLD_BUT_VALINC;
+         hold_but_cnt = 0;
+       }
+
+     }
+
+   } // end else if button press state == 2
+
+ } // end for loop
+ 
+ return(held);
+ 
 }
 
 
@@ -186,13 +192,13 @@ void get_button_pressed() {
     // read analog input
   int val_read = analogRead(BUT_PIN - 14);
 
-  // don't let it flip in a single read
+    // don't let it flip in a single read
   if( abs(last_but_rd - val_read) > BUT_THRESH ) {
     last_but_rd = val_read; 
     button_pressed = 0;
     return;
   }
-
+  
   if( val_read > (BUT0_VAL - BUT_THRESH) && val_read < (BUT0_VAL + BUT_THRESH) ) {
     button_pressed = BUT0;
   }
@@ -211,83 +217,97 @@ void get_button_pressed() {
   else {
     button_pressed = 0;
   }
-
-
+  
+  
 }
 
 
 byte is_button_press(byte button) {
-
-  // determine if the given button was
-  // pressed, held, or is neither
+  
+    // determine if the given button was
+    // pressed, held, or is neither
 
   static byte button_was = 0;
-
-  // if the button is set as 'active'
+  
+    // if the button is set as 'active'
   if( button_pressed == button ) {
-    // if we have already registered a press without
-    // registering a non-press
+      // if we have already registered a press without
+      // registering a non-press
     if( button_was ) {
-      // increase 'skip hold count'
+        // increase 'skip hold count'
       return(2);
     }
-    // button was not previous pressed...
+      // button was not previous pressed...
     button_was = button;
     hold_but_tm = millis();
     return(1);
   }
-
-  // if button set as inactive
-
-  // if button was previously set as active,
-  // register previous state as inactive
+ 
+    // if button set as inactive
+    
+    // if button was previously set as active,
+    // register previous state as inactive
   if( button_was == button ) {
     button_was = 0;
-    // set button as not currently pressed
+        // set button as not currently pressed
     button_pressed = 0;
   }
-
+    
   return(0);
 }
-
-
+  
+  
 byte get_menu( byte mnu, byte pos ) {
 
   // where is our target menu when 
-  // mnu.pos is pressed?  
-  //MainMenu is menu 0, its submenus are menus 1-4. AdvancedMotorMenu is menu 5. 
-  //Special return codes for calibration, manual move and input.
-
-  if (mnu == 0) return (pos+1);   //in Main Menu, 0 is mainmenu, so return pos +1
-  else if (mnu == 2 && pos == 6) return 5; //Advanced Motor Menu
-  else if (mnu == 5 && pos == 0 ) return MENU_CALIBRATION; //Calibration in Adv. Menu selected
-  else if (mnu == 1) return MENU_MANUAL; 
-  else return(MENU_INPUT); //No Submenu, Input Menu.
+  // mnu.pos is pressed?
+
+
+  switch(mnu) {
+    case 0:
+    
+      if( pos <= 5 )
+        return( pos + 1 );
+
+      break;
+    
+    case 1:
+        // manual control is special return code
+      return(254);
+      
+    default:
+      break;        
+  }
+      
+ 
 
+  // default is 'no target', an input value
+ return(255);
+ 
 }
 
 /*
    handle user input
- */
+*/
 
 void handle_input( byte button, boolean held ) {
-
+  
   // do what needs to be done when whatever
   // button is hit
-
+  
   if( button == BUT_CT ) {
-    // call center button function
+      // call center button function
     ui_button_center(held);    
   }
-
+  
   else if( button == BUT_DN ) {
     ui_button_down(held);
   }
-
+  
   else if( button == BUT_UP ) {
     ui_button_up(held);
   }
-
+  
   else if( button == BUT_RT ) {
     ui_button_rt(held);
   }  
@@ -297,339 +317,457 @@ void handle_input( byte button, boolean held ) {
 
 
   return;
-
+    
 
 }
 
 
-// button handlers
-
-
+  // button handlers
+  
+  
 void ui_button_center( boolean held ) {
-  // center button
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B01000000 ) {
-      // completed calibrating
-      ui_cal_scrn_flags &= B00111111;
-      show_calibrate();
-      return;
-    }  
-    else if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating input
-
-      if( held == true )
-        return;
-
-      m_cal_done = true;
-      return;
+      // center button
+
+        // on calibration screen
+
+     if( ui_ctrl_flags & B00000001 ) {
+       
+       if( ui_cal_scrn_flags & B01000000 ) {
+         // completed calibrating
+         ui_cal_scrn_flags &= B00111111;
+         show_calibrate();
+         return;
+       }  
+       else if( ui_cal_scrn_flags & B10000000 ) {
+         // in calibrating input
+         
+         if( held == true )
+           return;
+           
+         m_cal_done = true;
+         return;
+       }
+       
+       execute_calibrate();
+       return;
+     }
+
+
+     if( main_scr_input > 0 ) {
+         // make sure to abort main screen input
+       lcd.noBlink();
+       main_scr_input = 0;
+     }
+     
+     
+       // if in manual control
+     if( ui_ctrl_flags & B00000100  ) {
+         // clear out manual ctrl flag
+       ui_ctrl_flags &= B11111011;
+       
+       merlin_flags &= B11011111;
+
+         // resume back to setup menu
+       ui_ctrl_flags |= B01000000;
+       cur_menu = 1; // show manual menu again
+       draw_menu(0, false);
+       return;
+     }
+
+
+    if( ! (ui_ctrl_flags & B01000000) ) {
+        // not in any setup menu
+      ui_ctrl_flags |= B01000000;
+      cur_menu = 0;
+      draw_menu(0,false);
     }
+    else {
+       
+      
+        // in a setup menu, find
+        // the next menu to go to
+        
+          // calibration, don't do anything else
+          // EJD:20130329: Corregido && cur_pos == 6 que no dejaba acceder a calibrar la constante 
+      if( (cur_menu == 2 || cur_menu == 3) && cur_pos == 5 ) {
+        get_value(cur_menu, cur_pos, false);
+        return;
+      }
 
-    execute_calibrate();
-    return;
-  }
 
+      byte new_menu = get_menu(cur_menu, cur_pos);
 
-  if( main_scr_input > 0 ) {
-    // make sure to abort main screen input
-    lcd.noBlink();
-    main_scr_input = 0;
-  }
+        // if drawing motor manual screen...
+        
+      if( new_menu == 254 ) {
+        get_value(cur_menu, cur_pos, false);
+        return;
+      }
+      
+      
+      if( new_menu == 255 && ! (ui_ctrl_flags & B00100000) )  {
+            // this is not a menu, but an input of some
+            // sort
+                  
+          draw_menu(3,true);
+          return;
+      }
+      else if( ui_ctrl_flags & B00100000 ) {
+          // exiting out of value entry (save...)
+          // go to previous menu
+
+          // clear the cursor position
+        cur_inp_pos = 0;
+          
+          // read value back from input
+        get_value(cur_menu, cur_pos, true);
+        
+          // reset the float tenths (vs 100ths) parameter
+        ui_float_tenths = false;
+        
+          // clear in value setting flag
+          // and the flag indicating that
+          // we've already displayed this value
+        ui_ctrl_flags &= B11001111;
+        draw_menu(0,false);
+      }
+      else {
 
+          // entering another menu
+          
+          // record the last menu we were at
+        push_menu(cur_menu);
 
-  // if in manual control
-  if( ui_ctrl_flags & B00000100  ) {
-    // clear out manual ctrl flag
-    ui_ctrl_flags &= B11111011;
+          // clear in value setting flag
+        ui_ctrl_flags &= B11011111;
 
-    // resume back to setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 1; // show manual menu again
-    draw_menu(0, false);
-    return;
-  }
+          // set menu to new menu
+        cur_menu = new_menu;
+        draw_menu(0,false);
+      }
 
 
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // not in any setup menu
-    ui_ctrl_flags |= B01000000;
-    cur_menu = 0;
-    draw_menu(0,false);
-  }
-  else {
+    }
+}
 
 
-    // in a setup menu, find
-    // the next menu to go to
+void ui_button_down( boolean held ) {
 
-    byte new_menu = get_menu(cur_menu, cur_pos);
+        // on calibration screen
+
+     if( ui_ctrl_flags & B00000001 ) {
+         
+       if( ui_cal_scrn_flags & B10000000 ) {
+         // in calibrating settings
+         move_val(false);
+         update_cal_screen();
+         return;
+       }
+         
+       m_cur_cal = m_cur_cal > 0 ? m_cur_cal - 1 : 0;
+       show_calibrate();
+       
+       return;
+     }
+  
+
+      // if in manual motor mode...
+    if( ui_ctrl_flags & B00000100 ) {
+
+      if( merlin_flags & B00100000 ) {
+
+        if( held == true ) 
+           return;
+        
+        if( merlin_flags & B01000000 ) {
+            merlin_stop(1);
+              // speed was modified by running, return to
+              // original value
+            merlin_set_speed(1, merlin_speeds[1]);
+          }
+          else {
+            // AC:20120114: moved toe code to merlin_move_manual() to save a few bytes
+            merlin_move_manual(1,1);
+          }
+
+        show_merlin();
+      }
+      else {
+        motor_speed_adjust(cur_motor, -1 * inp_val_mult, true);
+        show_manual();
+      }
 
 
-    if( new_menu == MENU_CALIBRATION || new_menu==MENU_MANUAL ) {
-      // if drawing motor manual screen or in calibration screen...
-      get_value(cur_menu, cur_pos, false);
       return;
     }
-
-
-    if( new_menu == MENU_INPUT && ! (ui_ctrl_flags & B00100000) )  {
-      // this is not a menu, but an input of some
-      // sort
-
-      draw_menu(3,true);
+    
+      // if not currently in setup menus, or
+      // modifying a main screen value
+    if( ! (ui_ctrl_flags & B01000000) & main_scr_input == 0 )
       return;
-    }
-    else if( ui_ctrl_flags & B00100000 ) {
-      // exiting out of value entry (save...)
-      // go to previous menu
-
-      // clear the cursor position
-      cur_inp_pos = 0;
-
-      // read value back from input
-      get_value(cur_menu, cur_pos, true);
 
-      // reset the float tenths (vs 100ths) parameter
-      ui_float_tenths = false;
-
-      // clear in value setting flag
-      // and the flag indicating that
-      // we've already displayed this value
-      ui_ctrl_flags &= B11001111;
-      draw_menu(0,false);
+   if( main_scr_input > 0 ) {
+     move_val(false);
+       // save present value
+     get_mainscr_set(main_scr_input, true);
+       // set screen to update
+     ui_ctrl_flags |= B10000000;
+   }
+   else if( ui_ctrl_flags & B00100000 ) {
+        // entering a value
+      move_val(false);
+      draw_menu(3,true);
     }
     else {
-
-      // entering another menu
-
-      // record the last menu we were at
-      push_menu(cur_menu);
-
-      // clear in value setting flag
-      ui_ctrl_flags &= B11011111;
-
-      // set menu to new menu
-      cur_menu = new_menu;
-      draw_menu(0,false);
+        // moving to next menu item
+      draw_menu(2,false);
     }
-
-
-  }
+    
 }
 
+void ui_button_up( boolean held ) {
 
-void ui_button_down( boolean held ) {
-
-  // on calibration screen
-
-  if( ui_ctrl_flags & B00000001 ) {
-
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(false);
-      update_cal_screen();
+        // on calibration screen
+     if( ui_ctrl_flags & B00000001 ) {
+         
+       if( ui_cal_scrn_flags & B10000000 ) {
+         // in calibrating settings
+         move_val(true);
+         update_cal_screen();
+         return;
+       }
+
+       m_cur_cal = m_cur_cal > 1 ? 2 : m_cur_cal + 1;
+       show_calibrate();
+       
+       return;
+     }
+  
+      // if in manual motor mode...
+    if( ui_ctrl_flags & B00000100 ) {
+
+      if( merlin_flags & B00100000 ) {
+
+          if( held == true ) 
+           return;
+
+        
+          if( merlin_flags & B01000000 ) {
+            merlin_stop(1);
+              // speed was modified by running, return to
+              // original value
+            merlin_set_speed(1, merlin_speeds[1]);
+          }
+          else {
+            // AC:20120114: changed to merlin_move_manual()
+            merlin_move_manual(1,0);
+          }
+
+        show_merlin();
+      }
+      else {
+        motor_speed_adjust(cur_motor,1 + inp_val_mult, true);
+        show_manual();
+      }
       return;
     }
-    //TODO
-    // m_cur_cal = m_cur_cal > 0 ? m_cur_cal - 1 : 0;
-    show_calibrate();
-
-    return;
-  }
-
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust( -1 * inp_val_mult, true);
-    show_manual();
-    return;
-  }
-
-  // if not currently in setup menus, or
-  // modifying a main screen value
-  if( ! (ui_ctrl_flags & B01000000) && main_scr_input == 0 )
-    return;
-
-  if( main_scr_input > 0 ) {
-    move_val(false);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(false);
-    draw_menu(3,true);
-  }
-  else {
-    // moving to next menu item
-    draw_menu(2,false);
-  }
-
-}
-
-void ui_button_up( boolean held ) {
+    
+    if( ! (ui_ctrl_flags & B01000000) & main_scr_input == 0 ) {
+      
+        // alternate between merlin and home screens
+        
+      if( merlin_enabled ) {
+          // switch between merlin and normal home screens
+        if( merlin_flags & B00010000 ) {
+          merlin_flags &= B11101111;
+        }
+        else {          
+          merlin_flags |= B00010000;
+        }
 
-  // on calibration screen
-  if( ui_ctrl_flags & B00000001 ) {
-    if( ui_cal_scrn_flags & B10000000 ) {
-      // in calibrating settings
-      move_val(true);
-      update_cal_screen();
       return;
+      
+      }
+    }
+      
+   if( main_scr_input > 0 ) {
+    
+     move_val(true);
+       // save present value
+     get_mainscr_set(main_scr_input, true);
+     
+       // set screen to update
+     ui_ctrl_flags |= B10000000;
+   }
+   else if( ui_ctrl_flags & B00100000 ) {
+        // entering a value
+      move_val(true);
+      draw_menu(3,true);
+    }
+    else {
+      draw_menu(1,false);
     }
-    //TODO
-    //m_cur_cal = m_cur_cal > 1 ? 2 : m_cur_cal + 1;
-    show_calibrate();    
-    return;
-  }
-
-  // if in manual motor mode...
-  if( ui_ctrl_flags & B00000100 ) {
-    motor_speed_adjust(1 + inp_val_mult, true);
-    show_manual();
-    return;
-  }
-
-  // if not currently in setup menus, or
-  // modifying a main screen value
-  if( ! (ui_ctrl_flags & B01000000) && main_scr_input == 0 )
-    return;
-
-  if( main_scr_input > 0 ) {
-    move_val(true);
-    // save present value
-    get_mainscr_set(main_scr_input, true);
-
-    // set screen to update
-    ui_ctrl_flags |= B10000000;
-  }
-  else if( ui_ctrl_flags & B00100000 ) {
-    // entering a value
-    move_val(true);
-    draw_menu(3,true);
-  }
-  else {
-    draw_menu(1,false);
-  }
 
 }
 
 void ui_button_rt( boolean held ) {
+  
+     // clear out calibration screen value, if
+     // set
+    if( ui_ctrl_flags & B00000001 )
+      ui_ctrl_flags &= B11111110;
+
+      // if in manual control
+    if( ui_ctrl_flags & B00000100 ) {
+
+      if( merlin_flags & B00100000 ) {
+
+         if( held == true ) 
+           return;
+           
+         if( merlin_flags & B10000000 ) {
+           merlin_stop(0);
+              // speed was modified by running, return to
+              // original value
+            merlin_set_speed(0, merlin_speeds[0]);
+          }
+         else {
+             // AC:20120114: changed to merlin_move_manual()
+             merlin_move_manual(0,0);
+         }
+          
+        //show_merlin();
+      }
+      else {
+           // in manual
+        if( held == true ) {
+           // change motor direction
+          motor_dir(cur_motor, 0);
+          if( ! (run_status & B00010000) )
+            motor_control(cur_motor, true);
+          }
+  
+        show_manual();
+      }
+      
+      return;
+    }  
 
-  // clear out calibration screen value, if
-  // set
-  if( ui_ctrl_flags & B00000001 )
-    ui_ctrl_flags &= B11111110;
-
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {
-      // change motor direction
-      motor_dir(false);
-      if( ! (S_MOT_RUNNING) )//run_status & B00010000
-        motor_control(true);
-    }
-    show_manual();
-
-
-    return;
-  }  
 
+    if( ! (ui_ctrl_flags & B01000000) ) {
+      // we're on main screen, rt switches value we can
+      // adjust
+      main_screen_select(true);
+      return;
+    }
+    
+    if( ui_ctrl_flags & B00100000 ) {
+        // we're in a value entry mode.  Exit
+        // entry without saving the value
+
+        // clear in value setting flag
+        // and the flag indicating that
+        // we've already displayed this value
+      ui_ctrl_flags &= B11001111;        
+              // reset the float tenths (vs 100ths) parameter
+      ui_float_tenths = false;
 
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, rt switches value we can
-    // adjust
-    main_screen_select(true);
-    return;
-  } 
+      draw_menu(0,false);
+      return;
+    }
+    
+      // draw previous menu
+      
+    if( cur_menu == 0 ) { 
+        // we're at the highest menu, back to main screen 
+      cur_pos = 0;  
+        // clear setup flag
+        // indicate display needs updating
+      ui_ctrl_flags &= B10111111;
+      ui_ctrl_flags |= B10000000;
+        // clear out list of menus
+      flush_menu();
+    }
+    else {
+        // a parent menu can be drawn
+      cur_menu = pop_menu();
+      draw_menu(0,false);
+    }
+  
 
 }
 
 
 void ui_button_lt(boolean held) {
-  // if in manual control
-  if( ui_ctrl_flags & B00000100 ) {
-    if( held == true ) {        
-      // change motor direction
-      motor_dir(true);
-      // get motor moving (if not already)
-      if (!(S_MOT_RUNNING)) motor_control(true); //run_status & B00010000 
-      show_manual();
-    }
-    return;
-  }  
-
-  if( ! (ui_ctrl_flags & B01000000) ) {
-    // we're on main screen, lt switches value we can
-    // adjust
-    main_screen_select(false);
-    return;
-  }
+        // if in manual control
+    if( ui_ctrl_flags & B00000100 ) {
+
+      
+      if( merlin_flags & B00100000 ) {
+
+          if( held == true ) 
+           return;
+
+          if( merlin_flags & B10000000 ) {
+            merlin_stop(0);
+              // speed was modified by running, return to
+              // original value
+            merlin_set_speed(0, merlin_speeds[0]);
+          }
+          else {
+            // AC:20120114: changed to merlin_move_manual()              
+            merlin_move_manual(0,1);  
+          }
 
-  // left button
-  if( ! (ui_ctrl_flags & B01000000 || ui_ctrl_flags & B00100000 ))
-    return;
-
-  if( ui_ctrl_flags & B00100000 ) {
-    // we're in a value entry mode.  Exit
-    // entry without saving the value
+      }
+      else {
+        if( held == true ) {        
+           // change motor direction
+          motor_dir(cur_motor, 1);
+            // get motor moving (if not already)
+          if( ! (run_status & B00010000) )
+            motor_control(cur_motor, true);
+        }
 
-    // clear in value setting flag
-    // and the flag indicating that
-    // we've already displayed this value
-    ui_ctrl_flags &= B11001111;        
-    // reset the float tenths (vs 100ths) parameter
-    ui_float_tenths = false;
+      show_manual();
+      }
 
-    draw_menu(0,false);
-    return;
-  }
+      return;
+    }  
 
-  // draw previous menu
-
-  if( cur_menu == 0 ) { 
-    // we're at the highest menu, back to main screen 
-    cur_pos = 0;  
-    // clear setup flag
-    // indicate display needs updating
-    ui_ctrl_flags &= B10111111;
-    ui_ctrl_flags |= B10000000;
-    // clear out list of menus
-    flush_menu();
-  }
-  else {
-    // a parent menu can be drawn
-    cur_menu = pop_menu();
-    draw_menu(0,false);
-  }
+    if( ! (ui_ctrl_flags & B01000000) ) {
+      // we're on main screen, lt switches value we can
+      // adjust
+      main_screen_select(false);
+      return;
+    }
 
+    // left button
+    if( ! (ui_ctrl_flags & B01000000) || ui_ctrl_flags & B00100000 )
+      return;
 }
 
 
+
 /* 
- Draw screens
- */
+  Draw screens
+*/
 
 
 void draw_menu(byte dir, boolean value_only) {
 
-
-  // turn off blinking, if on...
+  
+    // turn off blinking, if on...
   lcd.noBlink();
-
+  
   boolean draw_all = false;
 
   // determine the direction we are going, up/down (1/2),
   // draw all (but don't move position) (3), and draw
   // new menu from top (0)
-
+  
   if( dir == 2 ) {
-    // down
+      // down
     cur_pos++;
     if( cur_pos > cur_pos_sel ) {
       lcd.clear();
@@ -637,90 +775,97 @@ void draw_menu(byte dir, boolean value_only) {
     }
   }    
   else if( dir == 1 ) {
-    // up
+      // up
     cur_pos = cur_pos == 0 ? 0 : cur_pos - 1;
-
+    
     if( cur_pos < cur_pos_sel ) {
       lcd.clear();
       draw_all = true;
     }
   }
   else if( dir == 3 ) {
-    // draw all (no move)
+      // draw all (no move)
     draw_all = true;
   }
   else {
-    // draw new menu (from top)
+      // draw new menu (from top)
     cur_pos = 0;
     draw_all = true;
   }
-
-  // don't overrun the memory locations for this menu
-
+  
+    // don't overrun the memory locations for this menu
+    
   cur_pos = cur_pos > max_menu[cur_menu] ? max_menu[cur_menu] : cur_pos;
-
-  switch( cur_menu ) {
-    //draw the menu
-  case 0:
-
-    draw_values(menu_str, draw_all, value_only);
-    break;
-
-  case 1:
-
-    draw_values(man_str, draw_all, value_only);
-    break;
-
-  case 2:
-
-    draw_values(axis0_str, draw_all, value_only);
-    break;
-
-  case 3:
-
-    draw_values(cam_str, draw_all, value_only);
-    break;
-
-  case 4:
-
-    draw_values(set_str, draw_all, value_only);
-    break;
-
-  case 5:
-    draw_values(axis_adv_str, draw_all, value_only);
-
-  default: 
-    return;  
+  
+   switch( cur_menu ) {
+    
+    case 0:
+    
+      draw_values(menu_str, draw_all, value_only);
+      break;
+      
+    case 1:
+    
+      draw_values(man_str, draw_all, value_only);
+      break;
+      
+    case 2:
+    
+      draw_values(axis0_str, draw_all, value_only);
+      break;
+      
+    case 3:
+    
+      draw_values(axis1_str, draw_all, value_only);
+      break;
+
+    case 4:
+
+      draw_values(cam_str, draw_all, value_only);
+      break;
+  
+    case 5:
+    
+      draw_values(set_str, draw_all, value_only);
+      break;
+
+    case 6:
+    
+      draw_values(scope_str, draw_all, value_only);
+      break;
+      
+    default: 
+      return;  
   }
-
+  
 
 }
 
-
-void draw_values(const char* const these[], boolean draw_all, boolean value_only) {
-
+   
+void draw_values(const char *these[], boolean draw_all, boolean value_only) {
+  
   if( draw_all == true ) {
 
     // must draw the whole display
     lcd.clear();
-    // clear out lcd buffer
-
-      memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
-
-    // draw first option
+      // clear out lcd buffer
+      
+    memset(lcd_buf, ' ', sizeof(char) * MAX_LCD_STR);
+    
+      // draw first option
     lcd.noCursor();
     lcd.setCursor(0,0);
     cur_pos_sel = cur_pos;
-
+    
     strcpy_P(lcd_buf, (char*) pgm_read_word(&(these[cur_pos])));
     lcd.print("> ");
     lcd.print(lcd_buf);
     lcd.setCursor(0,1);
-
-    // if we're not displaying only a value, and there's
-    // another menu entry to display -- display it on the 
-    // second line..
-
+    
+      // if we're not displaying only a value, and there's
+      // another menu entry to display -- display it on the 
+      // second line..
+      
     if( ! value_only ) {
       if( cur_pos + 1 <= max_menu[cur_menu] ) {
         cur_pos_sel = cur_pos + 1;
@@ -729,37 +874,34 @@ void draw_values(const char* const these[], boolean draw_all, boolean value_only
         lcd.print("  ");
         lcd.print(lcd_buf);
       }
-      // clear out in value entry setting, if set
+        // clear out in value entry setting, if set
       ui_ctrl_flags &= B11011111;
-
+      
     }
     else {
-
-      // display the value of the current entry
+      
+        // display the value of the current entry
       ui_ctrl_flags |= B00100000;
-
-
+      
+ 
       if(! ( ui_ctrl_flags & B00010000 ) ) {
-        // have just drawn this value
+         // have just drawn this value
 
-        // place value from variable into
-        // temporary buffer
+           // place value from variable into
+           // temporary buffer
         get_value(cur_menu, cur_pos, false);
-
+         
         ui_ctrl_flags |= B00010000;
       }
-
-
-
-      // display the correct current
-      // temporary input value
-
-
-
-      switch(ui_type) {
-      case INPUT_IO:
-        // for alt i/o inputs
-
+      
+   
+
+        // display the correct current
+        // temporary input value
+        
+      if( ui_type_flags2 & B10000000 ) {
+            // for alt i/o inputs
+            
         if( cur_inp_long == 0 ) {
           lcd.print("Disabled");
         }
@@ -787,89 +929,94 @@ void draw_values(const char* const these[], boolean draw_all, boolean value_only
         else {
           lcd.print("Change Dir");
         }
-        break;
-      case INPUT_SPEED: 
-        // cal speed inputs in gobal set menu
-        display_spd_cpm(cur_inp_long);
-        break;
-      case INPUT_FLOAT:
-        lcd.print(cur_inp_float, (byte) 2);
-        break;
-      case INPUT_ONOF:
-        if (cur_inp_bool == true) {
-          lcd.print("On");
-        } 
-        else {
-          lcd.print("Off");
-        }
-        break;
-      case INPUT_LTRT:
-        if (cur_inp_bool == true) {
-          lcd.print("Rt");
-        } 
-        else {
-          lcd.print("Lt");
-        }
-        break;
-      case INPUT_CMPCT:
-        if (cur_inp_bool == true) {
-          lcd.print("CPM");
-        } 
-        else {
-          lcd.print("PCT");
-        }
-        break;
-      case INPUT_CONTSMS:
-        if (cur_inp_bool == true) {
-          lcd.print("Cont.");
-        } 
-        else {
-          lcd.print("S-M-S");
-        }
-        break;
-      case INPUT_ANGLE:
-        if( cur_inp_long == 0 ) {
-          lcd.print(0,DEC);
-        }
-        else if( cur_inp_long == 1 ) {
-          lcd.print(45,DEC);
-        }
-        else {
-          lcd.print(90,DEC);
-        }
-        break;
-      case INPUT_SHUTTER:
-        // for shutter type
-        if( cur_inp_long == SHUTTER_MODE_CABLE_FOCUS ) {
-          lcd.print("Cable+Focus");
-        }
-        else if( cur_inp_long == SHUTTER_MODE_CABLE_NO_FOCUS ) {
-          lcd.print("Cable");
-        }
-        else if( cur_inp_long == SHUTTER_MODE_IR_CANON ) {
-          lcd.print("IR Canon");
-        }
-        else if ( cur_inp_long == SHUTTER_MODE_IR_NIKON ) {
-          lcd.print("IR NIKON");
-        }
-        break;  
-      default:
-        lcd.print((unsigned long)cur_inp_long);
         return;
       }
-
-
-
+      else if( ui_type_flags2 & B01000000 ) {
+          // cal speed inputs in gobal set menu
+        display_spd_ipm(cur_inp_long, 0);
+        return;
+      }
+      
+      switch(ui_type_flags) {
+        case B10000000:
+          lcd.print(cur_inp_float, (byte) 2);
+          break;
+        case B01000000:
+          if (cur_inp_bool == true) {
+           lcd.print("On");
+          } 
+          else {
+             lcd.print("Off");
+          }
+          break;
+        case B00100000:
+          if (cur_inp_bool == true) {
+           lcd.print("Up");
+          } 
+          else {
+             lcd.print("Dn");
+          }
+          break;
+        case B00010000:
+          if (cur_inp_bool == true) {
+           lcd.print("Rt");
+          } 
+          else {
+             lcd.print("Lt");
+          }
+          break;
+        case B00001000:
+          if (cur_inp_bool == true) {
+           lcd.print("IPM");
+          } 
+          else {
+             lcd.print("PCT");
+          }
+          break;
+        case B00000100:
+          if (cur_inp_bool == true) {
+           lcd.print("Pulse");
+          } 
+          else {
+             lcd.print("Interleave");
+          }
+          break;
+        case B00000010:
+          if (cur_inp_bool == true) {
+           lcd.print("Rotary");
+          } 
+          else {
+             lcd.print("Linear");
+          }
+          break;
+        case B00000001:
+          if( cur_inp_long == 0 ) {
+            lcd.print(0,DEC);
+          }
+          else if( cur_inp_long == 1 ) {
+            lcd.print(45,DEC);
+          }
+          else {
+            lcd.print(90,DEC);
+          }
+          break;
+        default:
+          lcd.print((unsigned long)cur_inp_long);
+          return;
+      }
+      
+      
+      
     }
-
+    
   } // end if( draw_all == true
-
+        
   else {
-
-    // do not need to re-draw the whole screen
-
-    // move cursor down if we're not in
-    // a value input screen
+    
+      // do not need to re-draw the whole screen
+      
+      // move cursor down if we're not in
+      // a value input screen
     if( ! (ui_ctrl_flags & B00100000) ) {
       lcd.setCursor(0,0);
       lcd.print(' ');
@@ -882,30 +1029,30 @@ void draw_values(const char* const these[], boolean draw_all, boolean value_only
 
 
 void ui_set_backlight(byte value) {
-  /* //TODO
-   // make sure to not use pwm on lcd bkl pin
-   // if timer1 has been used at some point
-   if( ! timer_used ) {
-   analogWrite(LCD_BKL, cur_bkl);
-   }
-   else {
-   if( cur_bkl > 0 ) {
-   digitalWriteFast(LCD_BKL, HIGH);
-   }
-   else {
-   digitalWriteFast(LCD_BKL, LOW);
-   }
-   } */
+
+    // make sure to not use pwm on lcd bkl pin
+    // if timer1 has been used at some point
+  if( ! timer_used ) {
+    analogWrite(LCD_BKL, cur_bkl);
+  }
+  else {
+    if( cur_bkl > 0 ) {
+      digitalWrite(LCD_BKL, HIGH);
+    }
+    else {
+      digitalWrite(LCD_BKL, LOW);
+    }
+  }
 }
 
 /* 
- 
+
  Menu history functions
  
- */
-
+*/
+ 
 void push_menu(byte this_menu) { 
-  // push the given entry to the end of the list
+    // push the given entry to the end of the list
   for( byte i = 0; i < sizeof(hist_menu) / sizeof(hist_menu[0]); i++) {
     if( hist_menu[i] == 0 ) {
       hist_menu[i] = this_menu;
@@ -929,5 +1076,3 @@ void flush_menu() {
 }
 
 
-
-
diff --git a/DollyShield/ds_ui_screens.ino b/DollyShield/ds_ui_screens.ino
index c4ee300..9a474fc 100644
--- a/DollyShield/ds_ui_screens.ino
+++ b/DollyShield/ds_ui_screens.ino
@@ -1,42 +1,42 @@
 /* 
- 
- El Cheapo Dollyshield - UI Screens
- modified Version of Dynamic Perception LLC's DollyShield ds_ui_screens.ino
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
+
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+*/
+
 
 /*
 
- ========================================
- UI Screen-drawing functions
- ========================================
- 
- */
+  ========================================
+  UI Screen-drawing functions
+  ========================================
+  
+*/
 
 
 void prep_home_screen() {
   lcd.clear();
   lcd.setCursor(0,0);
 
-  if(S_RUNNING) {//run_status & B10000000
-    // in 'external intervalometer' mode, show 'ext' instead of 'on'
-    if( (external_io & (EXT_INTV_1|EXT_INTV_2)) || gb_enabled == true ) {
+  if( run_status & B10000000 ) {
+      // in 'external intervalometer' mode, show 'ext' inseatd of 'on'
+    if( external_interval & B11000000 || gb_enabled == true ) {
       lcd.print("Ext");
     }
     else {
@@ -50,25 +50,67 @@ void prep_home_screen() {
   lcd.setCursor(4, 0);
 }
 
+void show_merlin_home() {
 
-void show_home() {
+  lcd.print("  Scope");  
 
-  prep_home_screen();  
+  lcd.setCursor(0,1);
+  
+  if( merlin_dir[0] == 1 ) {
+    lcd.print('L');
+  }
+  else {
+    lcd.print('R');
+  }
+
+
+ display_spd_merlin(merlin_speeds[0], 0);
+
+ 
+  lcd.setCursor(8,1);
+  
+  
+  if( merlin_dir[1] == 1 ) {
+    lcd.print('D');
+  }
+  else {
+    lcd.print('U');
+  }
+
+ display_spd_merlin(merlin_speeds[1], 1);
+
+    // we call this here mainly to reset the
+    // cursor position when in an input
+  if( main_scr_input ) 
+    get_merlin_set(main_scr_input, false);
+
+}
 
-  // deal with interval times that are less than total time
-  // required between shots
-  float i_total = calc_total_cam_tm();
 
+void show_home() {
+  
+  prep_home_screen();  
+  
+  if( merlin_flags & B00010000 ) {
+    // show merlin screen instead
+    show_merlin_home();
+    return;
+  }
+  
+    // deal with interval times that are less than total time
+    // required between shots
+  float i_total = calc_total_cam_tm();
+  
   if( cam_interval < i_total ) {
     lcd.print(i_total, 1);
   }
   else {
     lcd.print((float) cam_interval, 1);
   }
-
+  
   lcd.print("s ");
-
-
+ 
+  
   if( shots > 999 ) {
     lcd.setCursor(10,0);
   }
@@ -85,138 +127,161 @@ void show_home() {
   lcd.print('[');
   lcd.print(shots, DEC);
   lcd.print(']');
-
+ 
   lcd.setCursor(0,1);
-
-  // dir displays
+  
+      // dir displays
   char lt = ui_invdir == true ? 'R' : 'L';
   char rt = ui_invdir == true ? 'L' : 'R';
 
-  if( m_dir == 1 ) {
+  if( m_wasdir[0] == 1 ) {
     lcd.print(lt);
   }
   else {
     lcd.print(rt);
   }
 
+ 
+if( ui_motor_display ) {
+  // display pct 
+   display_spd_ipm(m_speeds[0], 0);
+ }
+ else {
+  display_spd_pct(m_speeds[0]);
+ }
 
-  if( ui_motor_display ) {
-    // display pct 
-    display_spd_cpm(m_speed);
+ 
+  lcd.setCursor(8,1);
+  
+  
+  if( m_wasdir[1] == 1 ) {
+    lcd.print(lt);
   }
   else {
-    display_spd_pct(m_speed);
+    lcd.print(rt);
   }
 
+if( ui_motor_display ) {
+  // display pct 
+   display_spd_ipm(m_speeds[1], 1);
+ }
+ else {
+  display_spd_pct(m_speeds[1]);
+ }
 
-  lcd.setCursor(8,1);
-
-
-
-  // we call this here mainly to reset the
-  // cursor position when in an input
+    // we call this here mainly to reset the
+    // cursor position when in an input
   if( main_scr_input ) 
     get_mainscr_set(main_scr_input, false);
 }
 
 
 void main_screen_select(boolean dir) {
-
-  byte max_inputs = 4;
-
-  if( main_scr_input == 0) {
-    //enter main scr setup
+  
+  if( main_scr_input == 0 && dir == true ) {
     lcd.blink();
   }
-
+  
   if( dir ) {
     main_scr_input++;
   }
   else {
-    main_scr_input+=max_inputs;
+    main_scr_input--;
   }
 
-  if (main_scr_input>max_inputs) main_scr_input-=max_inputs;
+    
+    // merlin screen has five inputs, normal home
+    // has six
+    
+  byte max_inputs = (merlin_flags & B00010000) ? 5 : 6;
 
-  if(main_scr_input == 0 ) {
     // exit main scr setup
+  
+  if( (dir == true && main_scr_input > max_inputs) ||
+      (dir == false && main_scr_input == 0 ) ) {
     lcd.noBlink();
+    main_scr_input = 0;
     return;
   }
-
-  get_mainscr_set(main_scr_input, false);
+  
+ get_mainscr_set(main_scr_input, false);
 }
 
-
+      
 void show_manual() {
 
-  ui_ctrl_flags |= B00000100;
+ ui_ctrl_flags |= B00000100;
 
-  lcd.clear();
-  lcd.noBlink();
-
-  lcd.setCursor(0, 0);
-
-
-  lcd.print("[Sel] to exit");
-
-
-  lcd.setCursor(0, 1);
-  lcd.print("Speed: ");
-
-  if( ui_motor_display ) {
-    // display ipm 
-    display_spd_cpm(m_speed);
-  }
-  else {
-    display_spd_pct(m_speed);
-  }
+ lcd.clear();
+ lcd.noBlink();
 
+ lcd.setCursor(0, 0);
 
+ if( cur_motor == 0 ) {
+  lcd.print("Axis 1");
+ }
+ else {
+  lcd.print("Axis 2");
+ }
+ 
+ lcd.setCursor(0, 1);
+ lcd.print("Speed: ");
+
+ if( ui_motor_display ) {
+  // display ipm 
+   display_spd_ipm(m_speeds[cur_motor], cur_motor);
+ }
+ else {
+  display_spd_pct(m_speeds[cur_motor]);
+ }
+ 
+  
 }
 
-
+ 
 void show_calibrate() {
 
-  // show the motor calibrate screen
-
-  ui_ctrl_flags |= B00000001;
-
-  lcd.clear();
-  lcd.noBlink();
-
-  lcd.setCursor(0,0);
-
-  lcd.print("Cal M");
-  lcd.print(" [");
-
-  byte angle = 45;//m_cur_cal * 45;//TODO
+    // show the motor calibrate screen
+    
+ ui_ctrl_flags |= B00000001;
 
-  lcd.print(angle, DEC);
-  lcd.print(" Deg]");
+ lcd.clear();
+ lcd.noBlink();
 
+ lcd.setCursor(0,0);
+ 
+ lcd.print("Cal M");
+ lcd.print(cur_motor + 1, DEC);
+ lcd.print(" [");
+ 
+ byte angle = m_cur_cal * 45;
+ 
+ lcd.print(angle, DEC);
+ lcd.print(" Deg]");
+ 
 }
 
 
 
 void execute_calibrate() {
 
-  // in calibration  
-  ui_cal_scrn_flags |= UI_CAL_CALIBRATING;
-  // floating point input
-  ui_type = INPUT_FLOAT;
+    // in calibration  
+  ui_cal_scrn_flags |= B10000000;
+    // floating point input
+  ui_type_flags |= B10000000;
 
   ui_float_tenths = false;
-
-
+ 
+  
   byte was_cur_pos = 0;
   byte completed = 0;   
-
-  // sms calibration
+  
+    // sms calibration
   for( byte i = 0; i <= 1; i++ ) {
-    float traveled = 0.01 * (max_cpm);
-    unsigned int runspd = 0.01 * m_maxsms;
+    float traveled = 0.01 * (max_ipm[cur_motor]);
+    unsigned int runspd = 0.01 * m_maxsms[cur_motor];
     cur_inp_float = traveled;
+
     completed++;
     
     lcd.clear();
@@ -224,81 +289,78 @@ void execute_calibrate() {
     lcd.print("Running ");  
     lcd.print('[');
     lcd.print(completed, DEC);
-    lcd.print(" of 8]");
-
-    // sms moving in i dir
-    // at 6% of total distance
-   // motor_run_calibrate(1, runspd, i);
+    lcd.print(" of 6]");
+    
+      // sms moving in i dir
+      // at 6% of total distance
+    motor_run_calibrate(1, runspd, i);
 
     update_cal_screen();
-
+        
     m_cal_done = false;
-//where is cal_done set??
+
     while( m_cal_done == false ) {
-      byte held = ui_button_check();
+        byte held = ui_button_check();
     }
-    //TODO
-    //  m_cal_array[m_cur_cal][0][i] = traveled / cur_inp_float;
+    
+    m_cal_array[cur_motor][m_cur_cal][0][i] = traveled / cur_inp_float;
 
   }
-  //pulse calibration
-    //TODO
-  // cont. calibration  
+
+  
+    // pulse calibration  
   for( byte c = 1; c <= 2; c++ ) {
-		//get speed for calibration
     byte ths_spd = c == 1 ? motor_spd_cal[0] : motor_spd_cal[1];
+    
     for( byte i = 0; i <= 1; i++ ) {
-      float des_ipm = motor_calc_cpm(ths_spd, true);
+      float des_ipm = motor_calc_ipm(cur_motor, ths_spd, true);
       cur_inp_float = des_ipm;
 
       completed++;
-      Serial.print("comp:");
-      Serial.println(completed);
+      
       lcd.clear();
       lcd.setCursor(0,0);
       lcd.print("Running ");  
       lcd.print('[');
       lcd.print(completed, DEC);
-      lcd.print(" of 8]");
+      lcd.print(" of 6]");
 
-      // cont moving in i dir
+        // pulse moving in i dir
       motor_run_calibrate(2, ths_spd, i);
-
+    
       update_cal_screen();
-
+      
       m_cal_done = false;
-
+      
       while(  m_cal_done == false ) {
-        byte held = ui_button_check();
+          byte held = ui_button_check();
       }
-      //TODO
-      //   m_cal_array[m_cur_cal][c][i] = ( cur_inp_float / des_ipm );
+      
+      m_cal_array[cur_motor][m_cur_cal][c][i] = ( cur_inp_float / des_ipm );
     }
   }
 
-
-  ui_cal_scrn_flags &= ~UI_CAL_CALIBRATING;
-  ui_cal_scrn_flags |= UI_CAL_DONE;
-
-  // save values to memory
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[3][4][2] 
-  // 3 * 4 * 2 * 4 = 96
-
+  
+  ui_cal_scrn_flags &= B01111111;
+  ui_cal_scrn_flags |= B01000000;
+  
+   // save values to memory
+   // handle m_cal_array in a sane manner
+   // float m_cal_array[2][3][3][2] 
+   // 2 * 3 * 3 * 2 * 4 = 144
+   
   byte* p = (byte*)(void*)&m_cal_array;
-  eeprom_write(EEPROM_TODO, *p, (3*4*2*4))
-
+  eeprom_write(71, *p, 144);
+  
 }
 
-
+  
 void update_cal_screen() {
-
-  lcd.clear();
-  lcd.setCursor(0,0);
-  lcd.print("Dist Moved:");
-  lcd.setCursor(0,1);
-
-  lcd.print(cur_inp_float, 2);
+  
+    lcd.clear();
+    lcd.setCursor(0,0);
+    lcd.print("Dist Moved:");
+    lcd.setCursor(0,1);
+    
+    lcd.print(cur_inp_float, 2);
 }
-
-
diff --git a/DollyShield/ds_ui_values.ino b/DollyShield/ds_ui_values.ino
index 18aab09..2be3f11 100644
--- a/DollyShield/ds_ui_values.ino
+++ b/DollyShield/ds_ui_values.ino
@@ -1,84 +1,87 @@
 /* 
- 
- El Cheapo Dollyshield - UI Values
- modified Version of Dynamic Perception LLC's DollyShield ds_ui_values.ino
- (c) 2010-2011 C.A. Church / Dynamic Perception LLC
- (c) FFZ
- For more info go to http://openmoco.org or http://www.thundercorp.de/timelapse
- 
- This program is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by
- the Free Software Foundation, either version 3 of the License, or
- (at your option) any later version.
- 
- This program is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of
- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- GNU General Public License for more details.
- 
- You should have received a copy of the GNU General Public License
- along with this program.  If not, see <http://www.gnu.org/licenses/>.
- 
- */
 
-/*
+   "DollyShield" MX2
+   
+   (c) 2010 C.A. Church / Dynamic Perception LLC
+   
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
 
- ========================================
- UI Value Handling/Lookup functions
- ========================================
- 
- */
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
 
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
-void get_value( byte menu, byte pos, boolean read_save ) {
 
-  // find the correct value to display for the current menu item
-  // calls the necessary related function to handle value display/setting
-  if( pos > max_menu[menu] )
-    return;
+*/
 
-  //set as non-floating point/bool by default
-  ui_type = INPUT_ONOF;
 
-  switch(menu) {
-  case 1:
-    get_manual_select(pos);
-    break;
-  case 2:    
-    get_m_axis_set(pos, read_save);
-    break;
-  case 3:    
-    get_m_cam_set(pos, read_save);
-    break;
-  case 4:
-    get_global_set(pos, read_save);
-    break;
-  case 5:
-    get_m_adv_set(pos,read_save);
-    break;
+/*
 
-  }
+  ========================================
+  UI Value Handling/Lookup functions
+  ========================================
+  
+*/
 
 
+void get_value( byte menu, byte pos, boolean read_save ) {
 
+    // find the correct value to display for the current menu item
+    // calls the necessary related function to handle value display/setting
+  if( pos > max_menu[menu] )
+    return;
+    
+    //set as non-floating point/bool by default
+  ui_type_flags = 0;
+  
+  switch(menu) {
+    case 1:
+      get_manual_select(pos);
+      break;
+    case 2:    
+      get_m_axis_set(pos, read_save, 0);
+      break;
+    case 3:    
+      get_m_axis_set(pos, read_save, 1);
+      break;
+   case 4:
+      get_m_cam_set(pos, read_save);
+      break;
+   case 5:
+       get_global_set(pos, read_save);
+       break;
+   case 6:
+       get_scope_set(pos, read_save);
+       break;
+  }
+  
+  
+ 
 }
 
 
 void move_val(boolean dir) {
 
-  // increase or decrease input value
-  if( ui_type==INPUT_FLOAT) {
-    // float type
+    // increase or decrease input value
 
+  if( ui_type_flags & B10000000 ) {
+      // float type
 
-    // how much to add/remove each time?
-
+    
+      // how much to add/remove each time?
+      
     float mod = ui_float_tenths ? 0.1 : 0.01;
     mod *= (float) inp_val_mult;
-
-    // floating point input
+        
+      // floating point input
     if( dir == true ) {
-      // increase value
+        // increase value
       cur_inp_float += mod;
     }
     else {
@@ -88,19 +91,20 @@ void move_val(boolean dir) {
       else {
         cur_inp_float -= mod;
       }
-
+      
     }
 
   }
-  else if( ui_type==INPUT_ONOF ||ui_type==INPUT_LTRT ||ui_type==INPUT_CMPCT || ui_type==INPUT_CONTSMS ) {
-    // any boolean type
+  else if( ui_type_flags & B01111110 ) {
+      // any boolean type
 
     cur_inp_bool = ! cur_inp_bool;
   }
   else {
-    // unsigned long type
+    
+      // unsigned long type
     unsigned long mod = (1 * inp_val_mult);
-    // long input
+      // long input
     if( dir == true ) {
       cur_inp_long += mod;
     }
@@ -112,531 +116,823 @@ void move_val(boolean dir) {
         cur_inp_long -= mod;
       }
     } // end if dir not true
-
-    // ceiling on certain values
-    if (ui_type==INPUT_ANGLE ) {
-      cur_inp_long = cur_inp_long > 2 ? 2 : cur_inp_long;
+    
+    if( ui_type_flags & B00000001 ) {
+            // ceiling on certain values
+        cur_inp_long = cur_inp_long > 2 ? 2 : cur_inp_long;
     }
-    else if (ui_type==INPUT_IO ) {
-      cur_inp_long = cur_inp_long > 8 ? 8 : cur_inp_long;
-    }
-    else if (ui_type==INPUT_SHUTTER ) {
-      cur_inp_long = cur_inp_long > 3 ? 3 : cur_inp_long;
+    else if( ui_type_flags2 & B10000000 ) {
+          // ceiling for alt i/o types
+        cur_inp_long = cur_inp_long > 8 ? 8 : cur_inp_long;
     }
 
   } // end else long type...
-
+  
 }
 
 
 
 
-void get_m_axis_set( byte pos, boolean read_save) {
-
-  ui_type = INPUT_LONG;
-
-  // set axis configurable values
-
-  switch(pos) { 
-  case 0:
-    ui_type=INPUT_CONTSMS;
-    // set Movement Mode (SMS/CONT)
-    if( read_save == true ) {
-      m_mode = cur_inp_bool;
-      eeprom_write(EEPROM_TODO, m_mode);
-    }
-
-    cur_inp_bool = m_mode;
-    break;
-
-  case 1:
-    // set ramp in value
-    if( read_save == true ) {
-      m_ramp_in=cur_inp_long;         
-      eeprom_write(EEPROM_TODO, m_ramp_in);
-    }
-
-    cur_inp_long = m_ramp_in;
-    break;
-
-  case 2:
-    // set ramp out value
-    if( read_save == true ) {
-      m_ramp_out=cur_inp_long;         
-      eeprom_write(EEPROM_TODO, m_ramp_out);
-    }
-
-    cur_inp_long = m_ramp_out;
-    break;
-
-  case 3: 
-    // doly angle (for calibration)
-    ui_type=INPUT_ANGLE;
-
-    if( read_save == true ) {
-      m_angle = cur_inp_long;
-      eeprom_write(EEPROM_TODO, m_angle);
-    }
-
-    cur_inp_long = m_angle;
-    break;
-
-  case 4:
-    // set lead-in value
-    if( read_save == true ) {
-      m_lead_in = cur_inp_long;
-      eeprom_write(EEPROM_TODO, m_lead_in);
-    }
-
-    cur_inp_long = m_lead_in;
-    break;
-
-  case 5:
-    // set lead-out value
-    if( read_save == true ) {
-      m_lead_out = cur_inp_long;
-      eeprom_write(EEPROM_TODO, m_lead_out);
-    }
-
-    cur_inp_long = m_lead_out;
-    break;
-
-
-
-  }
-
+void get_m_axis_set( byte pos, boolean read_save, byte motor ) {
+
+    ui_type_flags = 0;
+    ui_type_flags2 = 0;
+    
+      // set axis configurable values
+      
+    switch(pos) { 
+      case 0:
+          // set ramp value
+        if( read_save == true ) {
+          motor_set_ramp(motor, cur_inp_long);         
+          eeprom_write(61 + motor, m_ramp_set[motor]);
+        }
+
+        cur_inp_long = m_ramp_set[motor];
+        break;
+
+      case 1:
+          // set lead-in value
+        if( read_save == true ) {
+          m_lead_in[motor] = cur_inp_long;
+          eeprom_write(229 + (motor*2), m_lead_in[motor]);
+        }
+
+        cur_inp_long = m_lead_in[motor];
+        break;
+
+      case 2:
+          // set lead-out value
+        if( read_save == true ) {
+          m_lead_out[motor] = cur_inp_long;
+          eeprom_write(233 + (motor*2), m_lead_out[motor]);
+        }
+
+        cur_inp_long = m_lead_out[motor];
+        break;
+        
+      case 3:
+        ui_type_flags |= B10000000;
+          // set rpm
+        if( read_save == true ) {
+          m_rpm[motor] = cur_inp_float;
+          motor_update_dist(motor, m_rpm[motor], m_diarev[motor]);
+          eeprom_write(32 + (motor*4), m_rpm[motor]);
+        }
+        
+        cur_inp_float = m_rpm[motor];
+        break;
+
+
+      case 4: 
+      
+          // doly angle (for calibration)
+        ui_type_flags |= B00000001;
+        
+        if( read_save == true ) {
+          m_angle[motor] = cur_inp_long;
+          eeprom_write(215 + motor, m_angle[motor]);
+        }
+        
+        cur_inp_long = m_angle[motor];
+        break;
+
+        
+      case 5:
+          // calibrate motor
+          get_calibrate_select(motor);
+          break;
+       
+      case 6:
+          // calibration constant
+                
+        ui_type_flags |= B10000000;
+        
+        if( read_save == true ) {
+          m_cal_constant[motor] = cur_inp_float;
+          eeprom_write(239 + (motor * 4), m_cal_constant[motor]);
+        }
+        
+        cur_inp_float = m_cal_constant[motor];
+        break;
+        
+      case 7:
+          // min ipm setting
+        ui_type_flags |= B10000000;
+        if( read_save == true ) {
+            
+          min_ipm[motor] = cur_inp_float;
+          min_spd[motor] = 255 * ( min_ipm[motor] / max_ipm[motor] );
+          eeprom_write(40 + (motor*4), min_ipm[motor]);
+          eeprom_write(48 + motor, min_spd[motor]);
+        } 
+        cur_inp_float = min_ipm[motor];
+
+        break;
+        
+      case 8:
+          // distance per revolution
+        ui_type_flags |= B10000000;
+ 
+        if( read_save == true ) {
+          m_diarev[motor] = cur_inp_float;
+          motor_update_dist(motor, m_rpm[motor], m_diarev[motor]);
+          eeprom_write(16 + (motor*4), m_diarev[motor]);
+        }
+        
+        cur_inp_float = m_diarev[motor];
+
+        break;
+
+      case 9:
+          // motor min pulse
+        if( read_save == true ) {
+          
+          if(cur_inp_long > 255)
+            cur_inp_long = 255;
+            
+          m_min_pulse[motor] = cur_inp_long;          
+          eeprom_write(50 + motor, m_min_pulse[motor]);
+        }
+        cur_inp_long = m_min_pulse[motor];
+        break;
+        
+
+    }
+    
 }
 
-void get_m_adv_set( byte pos, boolean read_save){
-
-  switch (pos){
-  case 0:
-    // calibrate motor
-    get_calibrate_select(0);
-    break;
-
-  case 1:
-    ui_type =INPUT_FLOAT;
-    // set rpm
-    if( read_save == true ) {
-      m_rpm = cur_inp_float;
-      motor_update_dist(m_rpm, m_diarev);
-      eeprom_write(EEPROM_TODO, m_rpm);
-    }
-
-    cur_inp_float = m_rpm;
-    break;
-
-  case 2:
-    // distance per revolution
-    ui_type=INPUT_FLOAT;
-
-    if( read_save == true ) {
-      m_diarev = cur_inp_float;
-      motor_update_dist(m_rpm, m_diarev);
-      eeprom_write(EEPROM_TODO, m_diarev);
-    }
-    cur_inp_float = m_diarev;
-    break;
-
-  case 3:
-    // min cont setting //TODO: Input in CPM instead of speed
-    ui_type=INPUT_FLOAT;
-    if( read_save == true ) {
-      min_cpm = cur_inp_float;
-      min_spd = 255 * ( min_cpm / max_cpm );
 
-      eeprom_write(EEPROM_TODO, min_cpm);
-      eeprom_write(EEPROM_TODO, min_spd);
-    } 
-    cur_inp_float = min_cpm;
-    break;
 
-    //TODO 4+5
 
-  case 6:
-    // low calibration spd
-    ui_type=INPUT_LONG; //ui_type_flags2 |= B01000000;
-    if( read_save == true ) {
-      motor_spd_cal[0] = cur_inp_long;
-      eeprom_write(EEPROM_TODO, motor_spd_cal[0]);
-    }
-    cur_inp_long = motor_spd_cal[0];
-    break;
+void get_m_cam_set( byte pos, boolean read_save ) {
 
+    // reset this flag
+  ui_float_tenths = false;
+  
+  
+  switch(pos) {
+    case 0:
+        // interval timer
+        
+      ui_type_flags |= B10000000;
+      ui_float_tenths = true;
+      
+      if( read_save == true ) { 
+        cam_interval = cur_inp_float;
+        eeprom_write(67, cam_interval);
+      }
+      cur_inp_float = cam_interval;
+      break;
+    case 1:
+        // max shots
+      if( read_save == true ) {
+        cam_max = cur_inp_long;
+        eeprom_write(10, cam_max);
+      }
+      cur_inp_long = cam_max;
+      break;
+    case 2:
+        // exposure time
+      if( read_save == true ) { 
+        exp_tm = cur_inp_long;
+        eeprom_write(260, exp_tm);
+      }
+      cur_inp_long = exp_tm;
+      break;    
+    case 3:
+        // post exp delay
+      if( read_save == true ) { 
+        post_delay_tm = cur_inp_long;
+        eeprom_write(5, post_delay_tm);
+      }
+      cur_inp_long = post_delay_tm;
+      break;
+    case 4:
+        // focus tap tm
+      if( read_save == true ) {
+        focus_tap_tm = cur_inp_long;
+        eeprom_write(3, focus_tap_tm);
+      }
+      cur_inp_long = focus_tap_tm;
+      break;
+    case 5:
+        // focus w/ shutter
+      ui_type_flags |= B01000000;
+      if( read_save == true ) {
+        focus_shutter = cur_inp_bool;
+        eeprom_write(7, focus_shutter);
+      }
+      cur_inp_bool = focus_shutter;
+      break;
+   case 6:
+       // camera repeat value
+      if( read_save == true ) {
+        cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
+        cam_repeat = cur_inp_long;
+        eeprom_write(249, cam_repeat);
+      }
+      cur_inp_long = cam_repeat;
+      break;
   case 7:
-    // high calibration spd
-    ui_type=INPUT_LONG; //ui_type_flags2 |= B01000000;
-    if( read_save == true ) {
-      motor_spd_cal[1] = cur_inp_long;
-      eeprom_write(EEPROM_TODO, motor_spd_cal[1]);
-    }
-    cur_inp_long = motor_spd_cal[1];
-    break;
+      // camera repeat delay
+      if( read_save == true) {
+        cam_rpt_dly = cur_inp_long;
+        eeprom_write(250, cam_rpt_dly);
+      }
+      cur_inp_long = cam_rpt_dly;
+      break;
   }
-
 }
 
+void get_scope_set(byte pos, boolean read_save) {
 
-void get_m_cam_set( byte pos, boolean read_save ) {
-
-  // reset this flag
+   // reset this flag
   ui_float_tenths = false;
-
-
+  
+  
   switch(pos) {
-  case 0:
-    // interval timer
-    ui_type=INPUT_FLOAT;
-    ui_float_tenths = true;
-
-    if( read_save == true ) { 
-      cam_interval = cur_inp_float;
-      eeprom_write(EEPROM_TODO, cam_interval);
-    }
-    cur_inp_float = cam_interval;
-    break;
-
-  case 1:
-    // max shots
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      cam_max = cur_inp_long;
-      eeprom_write(EEPROM_TODO, cam_max);
-    }
-    cur_inp_long = cam_max;
-    break;
-
-  case 2:
-    // exposure time
-    ui_type=INPUT_LONG;
-    if( read_save == true ) { 
-      exp_tm = cur_inp_long;
-      eeprom_write(EEPROM_TODO, exp_tm);
-    }
-    cur_inp_long = exp_tm;
-    break;    
-
-  case 3:
-    //Shutter Type
-    ui_type=INPUT_SHUTTER;
-    if( read_save == true ) { 
-      shutter_mode = cur_inp_long;
-      eeprom_write(EEPROM_TODO, shutter_mode);
-    }
-    cur_inp_long = shutter_mode;
-    break;
-
-  case 4:
-    //bulb mode
-    ui_type=INPUT_ONOF;
-
-    if( read_save == true ) {
-      bulb_mode = cur_inp_bool;
-      eeprom_write(EEPROM_TODO, bulb_mode);
-    }
-
-    cur_inp_bool = bulb_mode;
-    break;
-
-  case 5:
-    // camera repeat value
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
-      cam_repeat = cur_inp_long;
-      eeprom_write(EEPROM_TODO, cam_repeat);
-    }
-    cur_inp_long = cam_repeat;
-    break;
-
-  case 6:
-    // camera repeat delay
-    ui_type=INPUT_LONG;
-    if( read_save == true) {
-      cam_rpt_dly = cur_inp_long;
-      eeprom_write(EEPROM_TODO, cam_rpt_dly);
-    }
-    cur_inp_long = cam_rpt_dly;
-    break;
-
-  case 7:
-    // pre exp delay
-    ui_type=INPUT_LONG;
-    if( read_save == true ) { 
-      post_delay_tm = cur_inp_long;
-      eeprom_write(EEPROM_TODO, pre_delay_tm);
-    }
-    cur_inp_long = pre_delay_tm;
-    break;
-
-  case 8:
-    // post exp delay
-    ui_type=INPUT_LONG;
-    if( read_save == true ) { 
-      post_delay_tm = cur_inp_long;
-      eeprom_write(EEPROM_TODO, post_delay_tm);
-    }
-    cur_inp_long = post_delay_tm;
-    break;
-
-  case 9:
-    // focus delay / tap time
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      focus_tap_tm = cur_inp_long;
-      eeprom_write(EEPROM_TODO, focus_tap_tm);
-    }
-    cur_inp_long = focus_tap_tm;
-    break;
-
+    case 0:
+      ui_type_flags |= B10000000;
+      ui_float_tenths = false;
+      
+      if( read_save == true ) {
+        merlin_man_spd[0] = cur_inp_float;
+        merlin_man_spd[0] = merlin_man_spd[0] > 350.0 ? 350.0 : merlin_man_spd[0];
+        eeprom_write(221, merlin_man_spd[0]);
+      }
+      
+      cur_inp_float = merlin_man_spd[0];
+      break;
+   case 1:
+      ui_type_flags |= B10000000;
+      ui_float_tenths = false;
+      
+      if( read_save == true ) {
+        merlin_man_spd[1] = cur_inp_float;
+        merlin_man_spd[1] = merlin_man_spd[1] > 350.0 ? 350.0 : merlin_man_spd[1];
+        eeprom_write(225, merlin_man_spd[1]);
+      }
+      
+      cur_inp_float = merlin_man_spd[1];
+      break;
   }
 }
 
-
+      
 
 void get_global_set(byte pos, boolean read_save) {
 
+  ui_type_flags  = 0;
+  ui_type_flags2 = 0;
+  
   switch(pos) {
-
-  case 0:
-    // backlight level    
-    ui_type=INPUT_LONG;
-    if(read_save == true) {
-      cur_bkl = cur_inp_long > 255 ? 255 : cur_inp_long;
-      ui_set_backlight(cur_bkl);
-      eeprom_write(EEPROM_TODO, cur_bkl);
-    }
-    cur_inp_long = cur_bkl;
-    break;
-
-  case 1:
-    // lcd dim time
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      lcd_dim_tm = cur_inp_long;
-      eeprom_write(EEPROM_TODO, lcd_dim_tm);
-    }
-
-    cur_inp_long = lcd_dim_tm;
-    break;
-
-  case 2:
-    // blank lcd   
-    ui_type=INPUT_ONOF;
-    if( read_save == true ) {
-      blank_lcd = cur_inp_bool;
-      eeprom_write(EEPROM_TODO, blank_lcd);
-    }
-
-    cur_inp_bool = blank_lcd;
-    break;
-
-  case 3: 
-    // input 1
-    ui_type=INPUT_IO;
-    if( read_save == true ) {
-      altio_connect(0, cur_inp_long);
-      eeprom_write(EEPROM_TODO,input_type[0]);
-    }
-    cur_inp_long = input_type[0];
-    break;
-
-  case 4: 
-    // input 2 
-    ui_type=INPUT_IO;
-    if( read_save == true ) {
-      altio_connect(1, cur_inp_long);
-      eeprom_write(EEPROM_TODO,input_type[1]);
-    }
-    cur_inp_long = input_type[1];
-    break;
-
-  case 5: 
-    // input delay
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      ext_in_delay = cur_inp_long;
-      eeprom_write(EEPROM_TODO, ext_in_delay);
-    }
-    cur_inp_long =  ext_in_delay;
-    break;
-
-  case 6:
-    // output delay
-    ui_type=INPUT_LONG;
-    if( read_save == true ) {
-      ext_out_delay = cur_inp_long;
-      eeprom_write(EEPROM_TODO, ext_out_delay);
-    }
-
-    cur_inp_long = ext_out_delay;
-    break;
-
-  case 7:
-    // GB enable
-    ui_type=INPUT_ONOF;
-    if( read_save == true ) {
-      gb_enabled = cur_inp_bool;
-      eeprom_write(EEPROM_TODO, gb_enabled);
-    }
-
-    cur_inp_bool = gb_enabled;
-    break;
-
-  case 8:
-    // invert dir display
-    ui_type=INPUT_ONOF;
-    if( read_save == true ) {
-      ui_invdir = cur_inp_bool;
-      eeprom_write(EEPROM_TODO, ui_invdir);
-    }
-
-    cur_inp_bool = ui_invdir;
-    break;
-
-  case 9:
-    // flip I/O trigger type
-    ui_type=INPUT_ONOF;
+  
+    case 0:
+          // motor display type
+        ui_type_flags |= B00001000;      
+        
+        if( read_save == true ) {
+          ui_motor_display = cur_inp_bool;
+          eeprom_write(56, ui_motor_display);
+        }
+        
+        cur_inp_bool = ui_motor_display;
+        break;
+
+    case 1:
+          // motor slow type
+        ui_type_flags |= B00000100;      
+        
+        if( read_save == true ) {
+          motor_sl_mod = cur_inp_bool;
+          eeprom_write(57, motor_sl_mod);
+        }        
+        
+        cur_inp_bool = motor_sl_mod;
+        break;
+
+    case 2:
+  
+        // backlight level    
+      if(read_save == true) {
+        cur_bkl = cur_inp_long > 255 ? 255 : cur_inp_long;
+        ui_set_backlight(cur_bkl);
+        eeprom_write(266, cur_bkl);
+      }
+      
+      cur_inp_long = cur_bkl;
+      break;
+      
+   case 3:
+   
+       // lcd dim time
+     if( read_save == true ) {
+       lcd_dim_tm = cur_inp_long;
+       eeprom_write(58, lcd_dim_tm);
+     }
+     
+     cur_inp_long = lcd_dim_tm;
+     break;
+     
+   case 4:
+        // blank lcd   
+      ui_type_flags |= B01000000;
+      
+      if( read_save == true ) {
+        blank_lcd = cur_inp_bool;
+        eeprom_write(60, blank_lcd);
+      }
+      
+      cur_inp_bool = blank_lcd;
+      break;
+      
+   case 5: 
+       // input 1
+       
+      ui_type_flags2 |= B10000000;
+      
+      if( read_save == true ) {
+        altio_connect(0, cur_inp_long);
+        eeprom_write(217,input_type[0]);
+      }
+      
+      cur_inp_long = input_type[0];
+      break;
+
+   case 6: 
+       // input 2
+       
+      ui_type_flags2 |= B10000000;
+      
+      if( read_save == true ) {
+        altio_connect(1, cur_inp_long);
+        eeprom_write(218,input_type[1]);
+      }
+      
+      cur_inp_long = input_type[1];
+      break;
+      
+   case 7:
+      // metric display
+     ui_type_flags |= B01000000;
+     
+     if( read_save == true ) {
+       if ( cur_inp_bool != ui_is_metric ) {
+         
+           // only convert values when the 
+           // UI metric type changes
+           
+           
+         if( ui_is_metric ) {
+           // going to imperial
+           m_diarev[0] = m_diarev[0] / 2.54;
+           min_ipm[0]  = min_ipm[0] / 2.54;
+           m_diarev[1] = m_diarev[1] / 2.54;
+           min_ipm[1]  = min_ipm[1] / 2.54;
+
+         }
+         else {
+           // going to metric
+           m_diarev[0] *= 2.54;
+           min_ipm[0]  *= 2.54;
+           m_diarev[1] *= 2.54;
+           min_ipm[1]  *= 2.54;
+         }
+         
+         ui_is_metric = cur_inp_bool;
+           // write values to memory
+         eeprom_write(219, ui_is_metric);
+         
+         eeprom_write(16, m_diarev[0]);
+         eeprom_write(20, m_diarev[1]);  
+         eeprom_write(40, min_ipm[0]);
+         eeprom_write(44, min_ipm[1]);
+         
+         motor_update_dist(0, m_rpm[0], m_diarev[0]);
+         motor_update_dist(1, m_rpm[1], m_diarev[1]);
+  
+       }
+       
+     }
+     
+     cur_inp_bool = ui_is_metric;
+     break;
+     
+   case 8:
+     // reset memory
+
+     ui_type_flags |= B01000000;
+     
+     if( read_save == true ) {
+       if( cur_inp_bool )
+         eeprom_saved(false);
+     }
+     
+     cur_inp_bool = false;
+     break;
+     
+   case 9:
+     // merlin enable
+      ui_type_flags |= B01000000;
+      
+      if( read_save == true ) {
+        merlin_enabled = cur_inp_bool;
+        eeprom_write(220, merlin_enabled);
+      }
+      
+      cur_inp_bool = merlin_enabled;
+      break;
+
+   case 10:
+     // low calibration spd
+      ui_type_flags2 |= B01000000;
+      
+      if( read_save == true ) {
+        motor_spd_cal[0] = cur_inp_long;
+        eeprom_write(237, motor_spd_cal[0]);
+      }
+      
+      cur_inp_long = motor_spd_cal[0];
+      break;
+
+   case 11:
+     // high calibration spd
+      ui_type_flags2 |= B01000000;
+      
+      if( read_save == true ) {
+        motor_spd_cal[1] = cur_inp_long;
+        eeprom_write(238, motor_spd_cal[1]);
+      }
+      
+      cur_inp_long = motor_spd_cal[1];
+      break;
+  
+  case 12: 
+    // alt output pre time
+    
     if( read_save == true ) {
-      altio_dir = (cur_inp_bool == false) ? FALLING : RISING;
-      eeprom_write(EEPROM_TODO, altio_dir);
+      ext_trig_pre_delay = cur_inp_long;
+      eeprom_write(252, ext_trig_pre_delay);
     }
-
-    cur_inp_bool = (altio_dir == FALLING) ? false : true;
+    
+    cur_inp_long = ext_trig_pre_delay;
     break;
-
-  case 10:
-    // reset memory
-    ui_type=INPUT_ONOF;
-
+    
+  case 13:
+    // alt output post time
+    
     if( read_save == true ) {
-      if( cur_inp_bool )
-        eeprom_saved(false);
-    }
-    cur_inp_bool = false;
-    break;
-
-
-
+      ext_trig_pst_delay = cur_inp_long;
+      eeprom_write(256, ext_trig_pst_delay);
+    }
+    
+    cur_inp_long = ext_trig_pst_delay;
+    break;
+     
+   case 14:
+     // GB enable
+      ui_type_flags |= B01000000;
+      
+      if( read_save == true ) {
+        gb_enabled = cur_inp_bool;
+        eeprom_write(264, gb_enabled);
+      }
+      
+      cur_inp_bool = gb_enabled;
+      break;
+
+   case 15:
+     // invert dir display
+      ui_type_flags |= B01000000;
+      
+      if( read_save == true ) {
+        ui_invdir = cur_inp_bool;
+        eeprom_write(265, ui_invdir);
+      }
+      
+      cur_inp_bool = ui_invdir;
+      break;
+      
+   case 16:
+     // flip I/O trigger type
+     
+     ui_type_flags |= B01000000;
+     
+     if( read_save == true ) {
+       altio_dir = (cur_inp_bool == false) ? FALLING : RISING;
+       eeprom_write(52, altio_dir);
+     }
+     
+     cur_inp_bool = (altio_dir == FALLING) ? false : true;
+     break;
+     
   }
-
+  
+  
+  
 }
 
 
 void get_mainscr_set(byte pos, boolean read_save) {
-  ui_float_tenths = false;
-
 
+    // clear out previous on/off select
+     
+  ui_type_flags   = 0;
+  ui_type_flags2  = 0;
+  ui_float_tenths = false;
 
-  switch(pos) {
-  case 1:
-    // on/off
-    lcd.setCursor(0,0);
-    ui_type=INPUT_ONOF;
-    if( read_save ) {
-      if( cur_inp_bool > 0 ) {   
-        // if set to positive value
-        start_executing();
+  if( merlin_flags & B00010000 ) {
+    get_merlin_set(pos, read_save);
+    return;
+  }  
+
+   switch(pos) {
+    case 1:
+
+        // on/off
+        
+      lcd.setCursor(0,0);
+      
+      if( read_save ) {
+        if( cur_inp_bool > 0 ) {   
+            // if set to positive value
+       
+         start_executing();
+         
+        }
+        else {
+          stop_executing();
+        }
+        
       }
-      else {
-        stop_executing();
+        
+      ui_type_flags |= B01000000;
+      
+      cur_inp_bool = run_status >> 7;
+      break;
+
+    case 2:
+    
+        // set interval time
+      lcd.setCursor(4, 0);
+      
+      ui_type_flags |= B10000000;
+      ui_float_tenths = true;
+      
+      if( read_save ) {
+        cam_interval = cur_inp_float;
+        eeprom_write(67, cam_interval);
       }
-    }
-    cur_inp_bool =S_RUNNING ; //run_status >> 7
-    break;
-
-  case 2:
-    // set interval time
-    lcd.setCursor(4, 0);
 
-    ui_type=INPUT_FLOAT;
-    ui_float_tenths = true;
-
-    if( read_save ) {
-      cam_interval = cur_inp_float;
-      eeprom_write(EEPROM_TODO, cam_interval);
-    }
+      cur_inp_float = cam_interval;
+      break;
+      
+    case 3:
+
+        // dir for m1
+      lcd.setCursor(0,1);
+
+      if( read_save )
+        motor_dir(0, cur_inp_bool);
+           
+      ui_type_flags |= B00010000;
+      cur_inp_bool = m_wasdir[0];
+      break;
+
+    case 4:
+        // spd for m1
+
+      lcd.setCursor(1,1);
+
+      if( ! motor_sl_mod ) {
+          // shoot-move-shoot?
+          
+        cur_inp_long = cur_inp_long > m_maxsms[0] ? m_maxsms[0] : cur_inp_long;
+      } 
+      else {       
+        
+        cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
+      }
+      
+      if( read_save ) {
+        motor_set_speed(0, (unsigned int) cur_inp_long); 
+            // calculate speed change per shot for ramping
+            // if needed - use function to update values
+        motor_set_ramp(0, m_ramp_set[0]);
+           
+      }
+      
+      cur_inp_long = m_speeds[0];
+              
+      break;
+
+    case 5:
+        // dir for m2
+      lcd.setCursor(8,1);
+ 
+      if( read_save )
+        motor_dir(1, cur_inp_bool);
+           
+      ui_type_flags |= B00010000;
+      cur_inp_bool = m_wasdir[1];
+      break;
+      
+    case 6:
+        // spd for m2
+        
+      lcd.setCursor(9,1);
+      
+     if( ! motor_sl_mod ) {
+          // shoot-move-shoot?
+          
+        cur_inp_long = cur_inp_long > m_maxsms[1] ? m_maxsms[1] : cur_inp_long;
+      } 
+      else {        
+        cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
+      }
 
-    cur_inp_float = cam_interval;
-    break;
+      
+      if( read_save ) {
+        motor_set_speed(1, (unsigned int) cur_inp_long); 
+            // calculate speed change per shot for ramping
+            // if needed - use function to update values
+        motor_set_ramp(1, m_ramp_set[1]);
+      }
 
-  case 3:
-    // dir for motor
-    lcd.setCursor(0,1);
-    ui_type=INPUT_LTRT;
+      cur_inp_long = m_speeds[1];
+      break;
+   }
+   
 
-    if( read_save )
-      motor_dir(cur_inp_bool);
+}
 
 
-    cur_inp_bool = m_dir;
-    break;
+void get_merlin_set(byte pos, boolean read_save) {
+  
+  ui_type_flags   = 0;
+  ui_type_flags2  = 0;
+  ui_float_tenths = false;
+  
+  switch(pos) {
+    case 1:
+
+        // on/off
+        
+      lcd.setCursor(0,0);
+      
+      if( read_save ) {
+        if( cur_inp_bool > 0 ) {   
+            // if set to positive value
+       
+         start_executing();
+         
+        }
+        else {
+          stop_executing();
+        }
+        
+      }
+        
+      ui_type_flags |= B01000000;
+      
+      cur_inp_bool = run_status >> 7;
+      break;
+
+    case 2: 
+      // dir for yaw
+
+      lcd.setCursor(0,1);
+
+      if( read_save )
+        merlin_set_dir(0, cur_inp_bool);
+      
+      ui_type_flags |= B00010000;
+      cur_inp_bool = merlin_dir[0];
+      break;      
+      
+   case 3:
+     // speed for yaw
+       lcd.setCursor(1,1);
+       ui_type_flags |= B10000000;
+       ui_float_tenths = false;
+ 
 
-  case 4:
-    // speed for motor
-    lcd.setCursor(1,1);
-    ui_type=INPUT_LONG;
-    if( m_mode==MODE_SMS) {
-      // shoot-move-shoot?
-      cur_inp_long = cur_inp_long > m_maxsms ? m_maxsms: cur_inp_long;
-    } 
-    else {       
-      cur_inp_long = cur_inp_long > 255 ? 255 : cur_inp_long;
-    }
+      
+        // degrees
+      cur_inp_float = cur_inp_float > 360.0 ? 360.0 : cur_inp_float;
+      
+      if( read_save ) 
+        merlin_set_speed(0, cur_inp_float); 
+              
+      cur_inp_float = merlin_speeds[0];
+              
+      break;  
+    case 4: 
+      // dir for pitch
+
+      lcd.setCursor(8,1);
+
+      if( read_save )
+        merlin_set_dir(1, cur_inp_bool);
+           
+      ui_type_flags |= B00010000;
+      cur_inp_bool = merlin_dir[1];
+      break;
+      
+   case 5:
+     // speed for yaw
+       lcd.setCursor(9,1);
+       ui_type_flags |= B10000000;
+       ui_float_tenths = false;
+ 
 
-    if( read_save ) {
-      motor_set_speed((unsigned int) cur_inp_long); 
-      // calculate speed change per shot for ramping
-      // if needed - use function to update values
-      //  motor_set_ramp(m_ramp_set);  //TODO
-    }
-    cur_inp_long = m_speed;
-    break; 
+        // degrees
+      cur_inp_float = cur_inp_float > 360.0 ? 360.0 : cur_inp_float;
+      
+      if( read_save ) 
+        merlin_set_speed(1, cur_inp_float); 
+              
+      cur_inp_float = merlin_speeds[1];
+              
+      break;  
   }
+
 }
 
 
 
 void get_manual_select(byte pos) {
 
-  switch (pos) {
-  case 0:  
+  
     // set in manual mode
-    ui_ctrl_flags |= B00000100;
-    show_manual();
-    break;
-
-  case 1:
-    //TODO
-    break;
+  ui_ctrl_flags |= B00000100;
+
+    // merlin manual screen
+    
+  if( pos == 2 ) {
+    merlin_flags |= B00100000;
+      // set merlin into high speed mode
+      // AC/20120113: removed 
+      // ratio is now set in merlin_move_manual()
+      
+   // merlin.setRatio(1, 3);
+   // merlin.setRatio(2, 3);
+      // show merlin screen
+    show_merlin();
+    return;
   }
-}
 
+    // set current motor
+  cur_motor = pos;
+
+    // show manual motor screen
+  show_manual();
+
+
+}
+  
+    
 void get_calibrate_select(byte pos) {
-  // display calibrate screen  
+    // display calibrate screen
+  cur_motor = pos;  
   show_calibrate();
 }
 
-void display_spd_cpm(unsigned int spd) {
-
-  float cur_ipm = motor_calc_cpm(spd, m_mode);
+void display_spd_ipm(unsigned int spd, byte motor) {
+  
+  float cur_ipm = motor_calc_ipm(motor, spd, motor_sl_mod);
   lcd.print(cur_ipm, 2);
-  lcd.print("cm/min");
-
+  
+        // handle metric conversion
+  if( ui_is_metric ) {
+     lcd.print('c');
+  }
+  else {
+    lcd.print('i');
+  }
+  
+  
 }
 
 void display_spd_pct(byte spd) {
   float cur_pct =  (float) spd / (float) 255;
   cur_pct *= 100;
-
+  
   if( cur_pct < 100 ) {
     lcd.print(cur_pct,1);
   }
-  else {
-    lcd.print((int) cur_pct, DEC);
-  }
+   else {
+     lcd.print((int) cur_pct, DEC);
+   }
   lcd.print('%');
 }
 
 
+void display_spd_merlin(unsigned int spd, byte motor) {
+
+  lcd.print(merlin_speeds[motor], 2);
+    
+}
+
+
diff --git a/DollyShield/notes.txt b/DollyShield/notes.txt
deleted file mode 100644
index e18fb58..0000000
--- a/DollyShield/notes.txt
+++ /dev/null
@@ -1,287 +0,0 @@
- REMOVED FUNCTIONS:
- - main handler:
-	pre_focus_clear
-	ext_trigger_pre_delay und post_delay. den gesammten trigger krams nochmal ansehen!!
-	motor_sl_mod angefangen rauszunehmen
- 
- 
- 
- 
-  // motor slow mode is pulse (true) or sms (false)
-boolean motor_sl_mod = true;
- 
- 
- 
- 
- 
- 
- 
- 
- 
- enum  __attribute__((packed)) INPUTS {
-     INPUT_FLOAT, INPUT_ONOF, INPUT_SHUTTER, INPUT_LTRT, INPUT_CMPCT,INPUT_CONTSMS,INPUT_ANGEL,INPUT_IO,INPUT_SPEED,INPUT_PREPOST
- };
-
-
-
- /* input type flags
- 
-   B0 = input value is a float
-   B1 = input is a bool (on/off) value
-   B2 = input is a bool (up/dn) value
-   B3 = input is a bool (lt/rt) value
-   B4 = input is a bool (ipm/pct) value
-   B5 = input is a bool (pulse/sms) value
-   B6 = input is a bool (rotary/linear) value
-   B7 = input is list (0,45,90) value
-   
- */
- 
-
-
-
-  #define 3 EEPROM_POS_focus_tap_tm 3   //uint16
-  #define 5 EEPROM_POS_post_delay_tm 5  //
-  #define 7 EEPROM_POS_shutter_mode 7
-
-  #define 10 EEPROM_POS_cam_max
-  #define 16 EEPROM_POS_m_diarev
-  #define 24 EEPROM_POS_max_ipm
-  #define 32 EEPROM_POS_m_rpm
-  #define 40 EEPROM_POS_min_cpm
-  #define 48 EEPROM_POS_min_spd
-  #define 50 EEPROM_POS_m_min_pulse
-  #define 52 EEPROM_POS_altio_dir
-  #define 56 EEPROM_POS_ui_motor_display
-  #define 57 EEPROM_POS_motor_sl_mod
-  #define 58 EEPROM_POS_lcd_dim_tm
-  #define 60 EEPROM_POS_blank_lcd
-  #define 61 EEPROM_POS_m_ramp_set
-  #define 63 EEPROM_POS_m_maxsms
-  #define 67 EEPROM_POS_cam_interval
-
-  // handle m_cal_array in a sane manner
-  // float m_cal_array[1][3][3][2] 
-  // 1 * 3 * 3 * 2 * 4 = 72
-
-  byte* p = (byte*)(void*)&m_cal_array;
-  #define 71 EEPROM_POS_*p EEPROM_POS_(1*3*3*2*4)
-
-  #define 217 EEPROM_POS_input_type[0]
-  #define 218 EEPROM_POS_input_type[1]
-  #define 219 EEPROM_POS_ui_is_metric
-  #define 229 EEPROM_POS_m_lead_in
-  #define 233 EEPROM_POS_m_lead_out
-  #define 237 EEPROM_POS_motor_spd_cal
-  #define 239 EEPROM_POS_m_cal_constant
-  #define 249 EEPROM_POS_cam_repeat
-  #define 250 EEPROM_POS_cam_rpt_dly
-
-  #define 252 EEPROM_POS_ext_trig_pre_delay
-  #define 256 EEPROM_POS_ext_trig_pst_delay
-  #define 260 EEPROM_POS_exp_tm
-  #define 264 EEPROM_POS_gb_enabled
-  #define 265 EEPROM_POS_ui_invdir
-  #define 266 EEPROM_POS_cur_bkl
-  #define 267 EEPROM_POS_ir_remote
-  
-  
-  
-  
-  
-  
-  
-  
-  
-  //digitalwritefastmod
-  //+++++++++++++++++++++++++++++++++++++++++++++++++
-  //+++++++++++++++++++++++++++++++++++++++++++++++++
-  #include "Arduino.h" 
-
-#define BIT_READ(value, bit) (((value) >> (bit)) & 0x01)
-#define BIT_SET(value, bit) ((value) |= (1UL << (bit)))
-#define BIT_CLEAR(value, bit) ((value) &= ~(1UL << (bit)))
-#define BIT_WRITE(value, bit, bitvalue) (bitvalue ? BIT_SET(value, bit) : BIT_CLEAR(value, bit))
-
-#if !defined(digitalPinToPortReg)
-#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-// Arduino Mega Pins
-#define digitalPinToPortReg(P) \
-(((P) >= 22 && (P) <= 29) ? &PORTA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PORTB : \
-(((P) >= 30 && (P) <= 37) ? &PORTC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PORTD : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &PORTE : \
-(((P) >= 54 && (P) <= 61) ? &PORTF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PORTG : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PORTH : \
-(((P) == 14 || (P) == 15) ? &PORTJ : \
-(((P) >= 62 && (P) <= 69) ? &PORTK : &PORTL))))))))))
-
-#define digitalPinToDDRReg(P) \
-(((P) >= 22 && (P) <= 29) ? &DDRA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &DDRB : \
-(((P) >= 30 && (P) <= 37) ? &DDRC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &DDRD : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &DDRE : \
-(((P) >= 54 && (P) <= 61) ? &DDRF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &DDRG : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &DDRH : \
-(((P) == 14 || (P) == 15) ? &DDRJ : \
-(((P) >= 62 && (P) <= 69) ? &DDRK : &DDRL))))))))))
-
-#define digitalPinToPINReg(P) \
-(((P) >= 22 && (P) <= 29) ? &PINA : \
-((((P) >= 10 && (P) <= 13) || ((P) >= 50 && (P) <= 53)) ? &PINB : \
-(((P) >= 30 && (P) <= 37) ? &PINC : \
-((((P) >= 18 && (P) <= 21) || (P) == 38) ? &PIND : \
-((((P) >= 0 && (P) <= 3) || (P) == 5) ? &PINE : \
-(((P) >= 54 && (P) <= 61) ? &PINF : \
-((((P) >= 39 && (P) <= 41) || (P) == 4) ? &PING : \
-((((P) >= 6 && (P) <= 9) || (P) == 16 || (P) == 17) ? &PINH : \
-(((P) == 14 || (P) == 15) ? &PINJ : \
-(((P) >= 62 && (P) <= 69) ? &PINK : &PINL))))))))))
-
-#define __digitalPinToBit(P) \
-(((P) >=  7 && (P) <=  9) ? (P) - 3 : \
-(((P) >= 10 && (P) <= 13) ? (P) - 6 : \
-(((P) >= 22 && (P) <= 29) ? (P) - 22 : \
-(((P) >= 30 && (P) <= 37) ? 37 - (P) : \
-(((P) >= 39 && (P) <= 41) ? 41 - (P) : \
-(((P) >= 42 && (P) <= 49) ? 49 - (P) : \
-(((P) >= 50 && (P) <= 53) ? 53 - (P) : \
-(((P) >= 54 && (P) <= 61) ? (P) - 54 : \
-(((P) >= 62 && (P) <= 69) ? (P) - 62 : \
-(((P) == 0 || (P) == 15 || (P) == 17 || (P) == 21) ? 0 : \
-(((P) == 1 || (P) == 14 || (P) == 16 || (P) == 20) ? 1 : \
-(((P) == 19) ? 2 : \
-(((P) == 5 || (P) == 6 || (P) == 18) ? 3 : \
-(((P) == 2) ? 4 : \
-(((P) == 3 || (P) == 4) ? 5 : 7)))))))))))))))
-
-// 15 PWM
-#define __digitalPinToTimer(P) \
-(((P) == 13 || (P) ==  4) ? &TCCR0A : \
-(((P) == 11 || (P) == 12) ? &TCCR1A : \
-(((P) == 10 || (P) ==  9) ? &TCCR2A : \
-(((P) ==  5 || (P) ==  2 || (P) ==  3) ? &TCCR3A : \
-(((P) ==  6 || (P) ==  7 || (P) ==  8) ? &TCCR4A : \
-(((P) == 46 || (P) == 45 || (P) == 44) ? &TCCR5A : 0))))))
-#define __digitalPinToTimerBit(P) \
-(((P) == 13) ? COM0A1 : (((P) ==  4) ? COM0B1 : \
-(((P) == 11) ? COM1A1 : (((P) == 12) ? COM1B1 : \
-(((P) == 10) ? COM2A1 : (((P) ==  9) ? COM2B1 : \
-(((P) ==  5) ? COM3A1 : (((P) ==  2) ? COM3B1 : (((P) ==  3) ? COM3C1 : \
-(((P) ==  6) ? COM4A1 : (((P) ==  7) ? COM4B1 : (((P) ==  8) ? COM4C1 : \
-(((P) == 46) ? COM5A1 : (((P) == 45) ? COM5B1 : COM5C1))))))))))))))
-
-#else
-
-// Standard Arduino Pins
-#define digitalPinToPortReg(P) \
-(((P) >= 0 && (P) <= 7) ? &PORTD : (((P) >= 8 && (P) <= 13) ? &PORTB : &PORTC))
-#define digitalPinToDDRReg(P) \
-(((P) >= 0 && (P) <= 7) ? &DDRD : (((P) >= 8 && (P) <= 13) ? &DDRB : &DDRC))
-#define digitalPinToPINReg(P) \
-(((P) >= 0 && (P) <= 7) ? &PIND : (((P) >= 8 && (P) <= 13) ? &PINB : &PINC))
-#define __digitalPinToBit(P) \
-(((P) >= 0 && (P) <= 7) ? (P) : (((P) >= 8 && (P) <= 13) ? (P) - 8 : (P) - 14))
-
-#if defined(__AVR_ATmega8__)
-// 3 PWM
-#define __digitalPinToTimer(P) \
-(((P) ==  9 || (P) == 10) ? &TCCR1A : (((P) == 11) ? &TCCR2 : 0))
-#define __digitalPinToTimerBit(P) \
-(((P) ==  9) ? COM1A1 : (((P) == 10) ? COM1B1 : COM21))
-#else  //168,328
-
-// 6 PWM
-#define __digitalPinToTimer(P) \
-(((P) ==  6 || (P) ==  5) ? &TCCR0A : \
-(((P) ==  9 || (P) == 10) ? &TCCR1A : \
-(((P) == 11 || (P) ==  3) ? &TCCR2A : 0)))
-#define __digitalPinToTimerBit(P) \
-(((P) ==  6) ? COM0A1 : (((P) ==  5) ? COM0B1 : \
-(((P) ==  9) ? COM1A1 : (((P) == 10) ? COM1B1 : \
-(((P) == 11) ? COM2A1 : COM2B1)))))
-#endif  //defined(__AVR_ATmega8__)
-
-
-#endif  //mega
-#endif  //#if !defined(digitalPinToPortReg)
-
-
-
-
-#define __atomicWrite__(A,P,V) \
-if ( (int)(A) < 0x40) { bitWrite(*(A), __digitalPinToBit(P), (V) );}  \
-else {                                                         \
-uint8_t register saveSreg = SREG;                          \
-cli();                                                     \
-bitWrite(*(A), __digitalPinToBit(P), (V) );                   \
-SREG=saveSreg;                                             \
-} 
-
-// && __builtin_constant_p(V)
-#ifndef digitalWriteFast
-#define digitalWriteFast(P, V) \
-do {                       \
-if (__builtin_constant_p(P)) {\
-	if(V)   __atomicWrite__((uint8_t*) digitalPinToPortReg(P),P,HIGH) \
-	else     __atomicWrite__((uint8_t*) digitalPinToPortReg(P),P,LOW)\
-}\
-else  digitalWrite((P), (V));         \
-}while (0)
-#endif  //#ifndef digitalWriteFast2
-
-#if !defined(pinModeFast)
-#define pinModeFast(P, V) \
-do {if (__builtin_constant_p(P) && __builtin_constant_p(V)) __atomicWrite__((uint8_t*) digitalPinToDDRReg(P),P,V) \
-else pinMode((P), (V)); \
-} while (0)
-#endif
-
-
-#ifndef noAnalogWrite
-#define noAnalogWrite(P) \
-	do {if (__builtin_constant_p(P) )  __atomicWrite((uint8_t*) __digitalPinToTimer(P),P,0) \
-		else turnOffPWM((P));   \
-} while (0)
-#endif		
-
-
-#ifndef digitalReadFast
-	#define digitalReadFast(P) ( (int) _digitalReadFast_((P)) )
-	#define _digitalReadFast_(P ) \
-	(__builtin_constant_p(P) ) ? ( \
-	( BIT_READ(*digitalPinToPINReg(P), __digitalPinToBit(P))) ) : \
-	digitalRead((P))
-#endif
-
-//ende digitalwritefastmod
-//----------------------------------------------------------------------
-//----------------------------------------------------------------------
-
-
-
-
-
-
-//avrstudio porjekt, ir funktion verndert:
-//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-void send_ir(uint8_t brand){
-  for(uint8_t i=1;i<=*(seqs[brand]);i++){
-    uint8_t ir_status=0;
-    int  n=*(seqs[brand] + i);
-    while(n>0){
-      n--;
-      delayMicroseconds(oscd);
-	  ir_status=!ir_status;
-  			digitalWriteFast(IR_PIN, (ir_status&&(i%2))); 
-	   
-	}
-  }
-}
-
-//ende  
diff --git a/Libraries/MerlinMount/LICENSE.txt b/Libraries/MerlinMount/LICENSE.txt
new file mode 100644
index 0000000..64ffed3
--- /dev/null
+++ b/Libraries/MerlinMount/LICENSE.txt
@@ -0,0 +1,623 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+
diff --git a/Libraries/MerlinMount/examples/MerlinExample.pde b/Libraries/MerlinMount/examples/MerlinExample.pde
new file mode 100644
index 0000000..9c3376e
--- /dev/null
+++ b/Libraries/MerlinMount/examples/MerlinExample.pde
@@ -0,0 +1,48 @@
+/*
+ * MerlinExample
+ *
+ * Basic test code for the Arduino MerlinMount library.
+ *
+ */
+
+#include <merlin_mount.h>
+
+void setup() {
+  //start serial used to communicate with Merlin/Orion mount
+  Serial.begin(9600);
+  
+  //Init the Merlin mount and reset start/end position.
+  merlin.init();
+
+}
+
+
+
+void  loop() {   // run over and over again
+	long pos_pitch = 0;
+	long pos_yaw = 0;
+	
+	//Start to move downward
+	merlin.startMoving(AXIS_PITCH, DIR_DOWN);
+	delay(5000);
+	
+	//Start to move left as well
+	merlin.startMoving(AXIS_PITCH, DIR_LEFT);
+	delay(5000);
+
+	//Stop moving
+	merlin.stopMoving(AXIS_YAW);
+	merlin.stopMoving(AXIS_PITCH);
+	
+	//Read current position
+	pos_pitch = merlin.readAxisPosition(AXIS_PITCH);
+	pos_yaw = merlin.readAxisPosition(AXIS_YAW);
+	
+	pos_yaw = pos_yaw + merlin.fromAngle(20.0);
+	
+	//Move 20 degrees
+	merlin.driveToPositionBothAxis(pos_yaw, pos_pitch, SYNC_SYNCHRONY);
+	
+	delay(5000);
+
+}
diff --git a/Libraries/MerlinMount/keywords.txt b/Libraries/MerlinMount/keywords.txt
new file mode 100644
index 0000000..395a17b
--- /dev/null
+++ b/Libraries/MerlinMount/keywords.txt
@@ -0,0 +1,54 @@
+#######################################
+# Syntax Coloring MerlinMount
+#######################################
+
+#######################################
+# Datatypes (KEYWORD1)
+#######################################
+
+#######################################
+# Methods and Functions (KEYWORD2)
+#######################################
+parsePosVal	KEYWORD2
+valToHexStr	KEYWORD2
+toAngle	KEYWORD2
+fromAngle	KEYWORD2
+init	KEYWORD2
+startMoving	KEYWORD2
+stopMoving	KEYWORD2
+driveToPosition	KEYWORD2
+driveToPositionBothAxis	KEYWORD2
+takePicture	KEYWORD2
+readAxisPosition	KEYWORD2
+readAxisStatus	KEYWORD2
+sendCommand	KEYWORD2
+setRatio KEYWORD2
+getSteps KEYWORD2
+getSidereal KEYWORD2
+moveAngle KEYWORD2
+runMotor KEYWORD2
+#######################################
+# Instances (KEYWORD2)
+#######################################
+
+merlin	KEYWORD2
+
+#######################################
+# Constants (LITERAL1)
+#######################################
+INIT_SUCCESS	KEYWORD2
+INIT_FAILED	KEYWORD2
+AXIS_YAW	KEYWORD2
+AXIS_PITCH	KEYWORD2
+DIR_UP	KEYWORD2
+DIR_DOWN	KEYWORD2
+DIR_RIGHT	KEYWORD2
+DIR_LEFT	KEYWORD2
+DIR_STOPPED	KEYWORD2
+STATUS_STOPPED	KEYWORD2
+STATUS_RUNNING	KEYWORD2
+MOUNT_RX_PIN	KEYWORD2
+MOUNT_TX_PIN	KEYWORD2
+SYNC_ASYNCHRONY	KEYWORD2
+SYNC_SYNCHRONY	KEYWORD2
+
diff --git a/Libraries/MerlinMount/merlin_mount.cpp b/Libraries/MerlinMount/merlin_mount.cpp
new file mode 100755
index 0000000..d91377a
--- /dev/null
+++ b/Libraries/MerlinMount/merlin_mount.cpp
@@ -0,0 +1,480 @@
+/*
+  merlin_mount.cpp - Arduino library support for Merlin/Orion telescope mounts
+  Copyright (c)2009 Gustav Evertsson All right reserved
+  www.guzzzt.com - me@guzzzt.com
+ 
+ 	Changes by C.A. Church for openmoco.org 11/1/2010
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+	
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+	
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	
+  Version:   1.0 - Aug 7 2009
+  
+*/
+
+#include "Arduino.h"		//all things wiring / arduino
+
+#include "merlin_mount.h"
+#include "HardwareSerial.h"
+
+
+  // Init
+uint8_t MerlinMount::init() {
+	char res[16];
+	
+	if(this->_initiated == 1)
+		return INIT_SUCCESS;
+
+	// cchurch - changes
+	
+		// check to make sure motors are present..
+	this->sendCommand(":F1\r", res);
+	this->sendCommand(":F2\r", res);	
+
+		// get information about both axes
+	_precision[0] = this->getSteps(AXIS_YAW);	
+	_sidereal[0]  = this->getSidereal(AXIS_YAW);
+
+	_precision[1] = this->getSteps(AXIS_PITCH);	
+	_sidereal[1]  = this->getSidereal(AXIS_PITCH);
+	
+	
+	this->_initiated = 1;
+
+	return INIT_SUCCESS;
+}
+
+  // Control functions
+void MerlinMount::startMoving(uint8_t axis, uint8_t dir, unsigned long spd) {
+
+	// modified cchurch - more control over motor movement
+	
+	char res[16];
+
+	  // stop any current movement
+	this->stopMoving(axis);
+	
+	  // set direction and speed ratio
+	  // (speed ratio uses setRatio to set value)
+	this->setDirection(axis, dir);
+	
+	  // set speed value	
+	this->setSpeed(axis, spd);
+	
+	  // tell motor to start moving
+	this->runMotor(axis, res);
+
+	
+}
+
+void MerlinMount::startMoving( uint8_t axis, uint8_t dir ) {
+	 // call without speed to use saved speed
+	this->startMoving(axis, dir, _curSpd[axis - 1]);
+}
+
+void MerlinMount::runMotor(uint8_t axis, char* res) {
+		// turn the motor on
+	Serial.print(":J");
+	Serial.print(axis, DEC);	
+	this->sendCommand("\r", res);
+}
+
+void MerlinMount::stopMoving(uint8_t axis) {
+	char res[16];
+
+	Serial.print(":L");
+	Serial.print(axis, DEC);
+	this->sendCommand("\r", res);
+}
+
+long MerlinMount::getSidereal(uint8_t axis) {
+		// cchurch - wrap up get sidereal command
+		// for re-use
+	char res[16];
+
+	Serial.print(":D");
+	Serial.print(axis,DEC);
+	this->sendCommand("\r", res);
+	
+	return this->parsePosVal(res); 
+}
+
+
+void MerlinMount::setDirection(uint8_t axis, uint8_t dir) {
+		// cchurch - wrap up set direction/ratio command
+		// for re-use
+	char res[16];
+
+	Serial.print(":G");
+	Serial.print(axis,DEC);
+	Serial.print(_ratio[axis - 1], DEC);
+	Serial.print(dir, DEC);
+
+	this->sendCommand("\r", res);
+}
+
+void MerlinMount::setMovePrecision(unsigned int threshold) {
+	
+	_movePrecisionSteps = threshold;
+}
+
+	// move drive a specified angle by running a motor and reading its position
+	// call setMovePrecision() to set desired accuracy in encoder steps
+	// the faster you move, the higher this must be set!
+void MerlinMount::moveToPrecise(uint8_t axis, unsigned long speed, long position) {
+
+	long tempPos = this->readAxisPosition(axis);
+	if(tempPos == position)
+		return;
+	
+	uint8_t dir = tempPos > position;	
+
+	uint8_t oldRatio = this->setRatio(axis, 1);	
+	this->setDirection(axis, dir);	
+		
+	this->startMoving(axis, dir, speed);
+
+		// loop, reading value and getting position back
+		// note that the threshold is also your minimum accuracy
+		// amount.
+	
+	while( 1 ) {
+		tempPos = this->readAxisPosition(axis);
+		
+			// if we hit our target, break out of loop
+		if( tempPos >= (position - _movePrecisionSteps) && tempPos <= (position + _movePrecisionSteps) ) 
+			break;		
+	}			
+	this->stopMoving(axis);
+//	Serial.println(tempPos);
+	this->setRatio(axis, oldRatio);
+
+	return;
+}
+
+
+
+	// move drive a specified angle using a single GOTO command
+void MerlinMount::moveAngle(uint8_t axis, uint8_t dir, float angle) {
+	
+
+	long stepsAngle = (angle * ((float) _precision[axis - 1] / 360.0 ));
+
+	long targetPos = this->readAxisPosition(axis);
+	
+		// determine where we want to land by which 
+		// dir we are heading and number of steps to undershoot
+		// in order to prevent backlash when reversing gears
+	if( ! dir ) {	
+		targetPos = targetPos + stepsAngle;
+	}
+	else {
+		targetPos = targetPos - stepsAngle;
+	}			
+	this->driveToPosition(axis, targetPos);
+}
+
+
+// move drive a specified angle using a single GOTO command
+void MerlinMount::driveToPosition(uint8_t axis, long position) {
+	char res[16];	
+	long tempPos = 0;
+	
+	tempPos = this->readAxisPosition(axis);
+	if(tempPos == position)
+		return;
+	
+	
+	uint8_t dir = tempPos > position;	
+
+	uint8_t oldRatio = this->setRatio(axis, 4);
+	this->setDirection(axis, dir);
+	
+	Serial.print(":S");
+	Serial.print(axis, DEC);
+	this->_printHex(position);
+	this->sendCommand("\r", res);
+	
+	this->runMotor(axis, res);
+
+	this->setRatio(axis, oldRatio);
+	
+}
+
+
+void MerlinMount::driveToPositionBothAxis(long positionYaw, long positionPitch, uint8_t sync) {
+	driveToPosition(AXIS_YAW, positionYaw);
+	driveToPosition(AXIS_PITCH, positionPitch);
+	
+	// if synchrony then wait unit both axis have stopped
+	if(sync == SYNC_SYNCHRONY) {
+		delay(600);
+		while(this->readAxisStatus(AXIS_YAW) == STATUS_RUNNING ||
+					this->readAxisStatus(AXIS_PITCH) == STATUS_RUNNING) {
+			delay(200);
+		}
+	}
+
+}
+
+  // Camera functions
+void MerlinMount::takePicture(int shutterTime) {
+	char res[10];
+	
+	this->sendCommand(":O11\r", res);
+	delay(shutterTime);
+	this->sendCommand(":O10\r", res);
+}
+
+  	
+	// Status functions
+long MerlinMount::readAxisPosition(uint8_t axis) {
+	char res[16];
+
+	Serial.print(":j");
+	Serial.print(axis, DEC);
+	this->sendCommand("\r", res);
+	
+	return this->parsePosVal(res);
+}
+
+uint8_t MerlinMount::readAxisStatus(uint8_t axis) {
+	char res[16];
+
+	Serial.print(":f");
+	Serial.print(axis, DEC);
+	this->sendCommand("\r", res);
+	
+	if(res[1] == '0')
+		return STATUS_STOPPED;
+	else
+		return STATUS_RUNNING;
+}
+
+long MerlinMount::getSteps(uint8_t axis) {
+
+	// cchurch - get number of pulses/steps in a 
+	// complete circle
+	
+	char res[16];
+	
+	Serial.print(":a");
+	Serial.print(axis, DEC);
+	this->sendCommand("\r", res);
+	
+	return this->parsePosVal(res);
+	
+}
+
+uint8_t MerlinMount::setRatio(uint8_t axis, uint8_t ratio) {
+	uint8_t oldRatio = _ratio[axis - 1];
+	_ratio[axis - 1] = ratio;
+	return oldRatio;
+}
+
+void MerlinMount::_printHex(unsigned long val) {
+
+	// send hex value in little-endian form,
+	// with nibbles in original order
+	
+    for( byte i = 0; i < 3; i++) {
+  	  byte x = (byte) ( val >> (8*i)  );
+
+	// deal with stupidity in Serial.print(v, HEX);	
+          
+          if( x == 0 ) {
+            Serial.print("00");
+          }
+          else if( x > 0xF ) {
+            Serial.print(x, HEX);
+          }
+          else {
+            Serial.print('0');
+            Serial.print(x, HEX);
+          }
+         
+  }
+}
+
+
+
+	// Low byte is sent first (A35483 is read 8354A3).
+long MerlinMount::parsePosVal(char* hexStr) {
+	long val = 0;
+	char c = 0;
+  for(int i = 5; i > 0; i = i - 2) {
+    val <<= 4;
+    c = hexStr[i-1];
+      
+    if( c >= '0' && c <= '9')
+      val += (c - '0');
+    else if( c >= 'A' && c <= 'F')
+      val += (c - 'A' + 10);
+
+
+    val <<= 4;
+    c = hexStr[i];
+      
+    if( c >= '0' && c <= '9')
+      val += (c - '0');
+    else if( c >= 'A' && c <= 'F')
+      val += (c - 'A' + 10);
+  }
+   return val;
+}
+
+void MerlinMount::valToHexStr(long val, char* hexStr) {
+
+		// cchurch - this fails on some speeds, use
+		// _printHex for speeds/distances instead
+		
+	char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
+
+	const byte* p = (const byte*)(const void*)&val;
+	
+	hexStr[0] = hexval[((*p >> 4) & 0xF)];
+	hexStr[1] = hexval[*p & 0x0F];
+	p++;
+	hexStr[2] = hexval[((*p >> 4) & 0xF)];
+	hexStr[3] = hexval[*p & 0x0F];
+	p++;
+	hexStr[4] = hexval[((*p >> 4) & 0xF)];
+	hexStr[5] = hexval[*p & 0x0F];
+}
+
+double MerlinMount::toAngle(long first, long second) {
+	long distance = 0;
+	distance = first - second;
+	
+	return (double)distance / (double) _precision[0] * 360.0;
+}
+
+long MerlinMount::fromAngle(double angle) {
+	return (long)(((double)_precision[0] / 360.0) * angle);
+}
+
+/* Modified 10/26/2010
+   cchurch : add support for variable speeds
+*/
+
+	// Communication with the Merlin mount
+void MerlinMount::sendCommand(const char* send, char* response) {
+  
+  Serial.print(send);
+			
+  delay(50);
+  this->_getResponse(response);
+  
+}
+
+
+
+void MerlinMount::setSpeed(uint8_t axis, unsigned long speed) {
+	
+  char response[16];
+  
+  Serial.print(":I");
+  Serial.print(axis, DEC);
+    
+  this->_printHex(speed);
+  Serial.print("\r");
+  delay(50);
+  this->_getResponse(response);
+  
+  _curSpd[axis - 1] = speed;
+	
+	
+}
+
+
+	
+void MerlinMount::setSpeed( uint8_t axis, float degrees ) {
+		// set speed value based on degrees per min (rather than integer #)
+	
+	double interim = 360.0 / (float) _precision[axis - 1];
+	interim /= degrees;
+	interim *= 60.0;
+	
+	double speed = 0;
+	
+	if( _ratio[axis - 1] == 1 ) {
+		speed = 19531.25 * interim;
+	}
+	else {
+		speed = 666666.0 * interim;
+	}
+	
+	if( speed > int(speed) ) {
+		speed = int(speed) + 1;
+	}
+	
+	this->setSpeed(axis, (unsigned long) speed);
+}
+		
+
+void MerlinMount::_getResponse(char* response) {
+		// handle reading response back from telescope head
+  uint8_t incomingByte = 0;
+  uint8_t pos = 0;
+  uint8_t found = 0;
+	
+  while( Serial.available() == 0 ) { ; }
+	
+  while (Serial.available() > 0) {
+		
+    // read the incoming byte:
+    incomingByte = Serial.read();
+		
+			// ignore everything until we read a valid
+			// response start char from the telescope head...
+		if( incomingByte == '=' || incomingByte == '!' ) {
+			found = 1;
+				// do not include response start char in return value
+			continue;
+		}
+		
+	  if( found == 1 ) 
+			response[pos++] = incomingByte;
+		
+  }
+	
+  response[pos] = '\0';
+}
+
+  // class constructor
+MerlinMount::MerlinMount() {
+	// set default values
+	// AC/20120113: changed default ratios to 1
+	// beacause that is what we always use except in goto
+  this->_ratio[0] = 1;
+  this->_ratio[1] = 1;
+
+	this->_precision[0] = 0;
+	this->_precision[1] = 0;
+
+  this->_sidereal[0]  = 0;
+  this->_sidereal[1]  = 0;
+	
+	this->_curSpd[0] = 0;
+	this->_curSpd[1] = 0;
+		
+	this->_movePrecisionSteps = 100;
+	
+  this->_initiated = 0;
+}
+
+
+
+
+MerlinMount merlin = MerlinMount();
+
diff --git a/Libraries/MerlinMount/merlin_mount.h b/Libraries/MerlinMount/merlin_mount.h
new file mode 100755
index 0000000..3e78bd8
--- /dev/null
+++ b/Libraries/MerlinMount/merlin_mount.h
@@ -0,0 +1,120 @@
+/*
+  merlin_mount.cpp - Arduino library support for Merlin/Orion telescope mounts
+  Copyright (c)2009 Gustav Evertsson All right reserved
+  www.guzzzt.com - me@guzzzt.com
+ 
+	Changes by C.A. Church for openmoco.org 11/1/2010
+  
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+	
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+	
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+	
+  Version:   1.0 - Aug 7 2009
+  Version:	 2.0 - Nov 1 2010
+	
+*/
+
+#include <inttypes.h>
+#include "HardwareSerial.h"
+
+#ifndef	MERLIN_MOUNT_H
+#define MERLIN_MOUNT_H
+
+#define INIT_SUCCESS 1
+#define INIT_FAILED  0
+
+#define AXIS_YAW   1
+#define AXIS_PITCH 2
+
+#define DIR_UP    0
+#define DIR_DOWN  1
+#define DIR_RIGHT 0
+#define DIR_LEFT  1
+#define DIR_STOPPED 2
+
+#define STATUS_STOPPED 0
+#define STATUS_RUNNING 1
+
+#define SYNC_ASYNCHRONY 0
+#define SYNC_SYNCHRONY  1
+
+
+class MerlinMount
+{
+	private:
+		
+		uint8_t 			_initiated;
+		uint8_t 			_ratio[2];
+		char 					_lastCmd[16];
+		long    			_precision[2];
+		unsigned long _curSpd[2];
+		unsigned long _sidereal[2];
+		unsigned int	_movePrecisionSteps;
+		
+		void _getResponse(char* response);
+		void _printHex(unsigned long speed);
+		
+		
+  public:
+
+			// constructor
+	  MerlinMount();
+		
+	  	// Init mount
+	  uint8_t init();
+
+		
+			// Parse/convert values
+	  long parsePosVal(char* hexStr);
+	  void valToHexStr(long val, char* hexStr);
+	  double toAngle(long first, long second);
+	  long fromAngle(double angle);
+
+	  	// set speed ratio
+	  uint8_t setRatio(uint8_t axis, uint8_t ratio);
+	  	// get step count for every 360' (precision)
+	  long getSteps(uint8_t axis);
+
+			// set direction command
+	  void setDirection(uint8_t axis, uint8_t dir);
+			// get sidereal speed rate
+	  long getSidereal(uint8_t axis);
+
+		void setMovePrecision(unsigned int threshold);	  
+
+			// Motor Control functions	
+    void startMoving(uint8_t axis, uint8_t dir, unsigned long spd);
+    void startMoving(uint8_t axis, uint8_t dir);
+    void stopMoving(uint8_t axis);
+    void runMotor(uint8_t axis, char* res);
+    void moveAngle(uint8_t axis, uint8_t dir, float angle);
+	void moveToPrecise(uint8_t axis, unsigned long speed, long position);
+    void driveToPosition(uint8_t axis, long position);
+    void driveToPositionBothAxis(long positionYaw, long positionPitch, uint8_t sync);
+		
+			// set speed value
+    void setSpeed(uint8_t axis, unsigned long spd);
+		void setSpeed(uint8_t axis, float degrees);
+		
+  // Camera functions
+  	void takePicture(int shutterTime);
+  	
+	// Status functions
+		long readAxisPosition(uint8_t axis);
+		uint8_t readAxisStatus(uint8_t axis);
+	
+	// Communication with the Merlin mount
+		void sendCommand(const char* send, char* respose);
+};
+
+extern MerlinMount merlin;
+#endif
diff --git a/Libraries/MsTimer2/MsTimer2.cpp b/Libraries/MsTimer2/MsTimer2.cpp
new file mode 100644
index 0000000..0a32701
--- /dev/null
+++ b/Libraries/MsTimer2/MsTimer2.cpp
@@ -0,0 +1,157 @@
+/*
+  MsTimer2.h - Using timer2 with 1ms resolution
+  Javier Valencia <javiervalencia80@gmail.com>
+  
+  History:
+  	29/May/09 - V0.5 added support for Atmega1280 (thanks to Manuel Negri)
+  	19/Mar/09 - V0.4 added support for ATmega328P (thanks to Jerome Despatis)
+  	11/Jun/08 - V0.3 
+  		changes to allow working with different CPU frequencies
+  		added support for ATMega128 (using timer2)
+  		compatible with ATMega48/88/168/8
+	10/May/08 - V0.2 added some security tests and volatile keywords
+	9/May/08 - V0.1 released working on ATMEGA168 only
+	
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#include <MsTimer2.h>
+
+unsigned long MsTimer2::msecs;
+void (*MsTimer2::func)();
+volatile unsigned long MsTimer2::count;
+volatile char MsTimer2::overflowing;
+volatile unsigned int MsTimer2::tcnt2;
+
+void MsTimer2::set(unsigned long ms, void (*f)()) {
+	float prescaler = 0.0;
+	
+#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega48__) || defined (__AVR_ATmega88__) || defined (__AVR_ATmega328P__) || (__AVR_ATmega1280__)
+	TIMSK2 &= ~(1<<TOIE2);
+	TCCR2A &= ~((1<<WGM21) | (1<<WGM20));
+	TCCR2B &= ~(1<<WGM22);
+	ASSR &= ~(1<<AS2);
+	TIMSK2 &= ~(1<<OCIE2A);
+	
+	if ((F_CPU >= 1000000UL) && (F_CPU <= 16000000UL)) {	// prescaler set to 64
+		TCCR2B |= (1<<CS22);
+		TCCR2B &= ~((1<<CS21) | (1<<CS20));
+		prescaler = 64.0;
+	} else if (F_CPU < 1000000UL) {	// prescaler set to 8
+		TCCR2B |= (1<<CS21);
+		TCCR2B &= ~((1<<CS22) | (1<<CS20));
+		prescaler = 8.0;
+	} else { // F_CPU > 16Mhz, prescaler set to 128
+		TCCR2B |= ((1<<CS22) | (1<<CS20));
+		TCCR2B &= ~(1<<CS21);
+		prescaler = 128.0;
+	}
+#elif defined (__AVR_ATmega8__)
+	TIMSK &= ~(1<<TOIE2);
+	TCCR2 &= ~((1<<WGM21) | (1<<WGM20));
+	TIMSK &= ~(1<<OCIE2);
+	ASSR &= ~(1<<AS2);
+	
+	if ((F_CPU >= 1000000UL) && (F_CPU <= 16000000UL)) {	// prescaler set to 64
+		TCCR2 |= (1<<CS22);
+		TCCR2 &= ~((1<<CS21) | (1<<CS20));
+		prescaler = 64.0;
+	} else if (F_CPU < 1000000UL) {	// prescaler set to 8
+		TCCR2 |= (1<<CS21);
+		TCCR2 &= ~((1<<CS22) | (1<<CS20));
+		prescaler = 8.0;
+	} else { // F_CPU > 16Mhz, prescaler set to 128
+		TCCR2 |= ((1<<CS22) && (1<<CS20));
+		TCCR2 &= ~(1<<CS21);
+		prescaler = 128.0;
+	}
+#elif defined (__AVR_ATmega128__)
+	TIMSK &= ~(1<<TOIE2);
+	TCCR2 &= ~((1<<WGM21) | (1<<WGM20));
+	TIMSK &= ~(1<<OCIE2);
+	
+	if ((F_CPU >= 1000000UL) && (F_CPU <= 16000000UL)) {	// prescaler set to 64
+		TCCR2 |= ((1<<CS21) | (1<<CS20));
+		TCCR2 &= ~(1<<CS22);
+		prescaler = 64.0;
+	} else if (F_CPU < 1000000UL) {	// prescaler set to 8
+		TCCR2 |= (1<<CS21);
+		TCCR2 &= ~((1<<CS22) | (1<<CS20));
+		prescaler = 8.0;
+	} else { // F_CPU > 16Mhz, prescaler set to 256
+		TCCR2 |= (1<<CS22);
+		TCCR2 &= ~((1<<CS21) | (1<<CS20));
+		prescaler = 256.0;
+	}
+#endif
+	
+	tcnt2 = 256 - (int)((float)F_CPU * 0.001 / prescaler);
+	
+	if (ms == 0)
+		msecs = 1;
+	else
+		msecs = ms;
+		
+	func = f;
+}
+
+void MsTimer2::start() {
+	count = 0;
+	overflowing = 0;
+#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega48__) || defined (__AVR_ATmega88__) || defined (__AVR_ATmega328P__) || (__AVR_ATmega1280__)
+	TCNT2 = tcnt2;
+	TIMSK2 |= (1<<TOIE2);
+#elif defined (__AVR_ATmega128__)
+	TCNT2 = tcnt2;
+	TIMSK |= (1<<TOIE2);
+#elif defined (__AVR_ATmega8__)
+	TCNT2 = tcnt2;
+	TIMSK |= (1<<TOIE2);
+#endif
+}
+
+void MsTimer2::stop() {
+#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega48__) || defined (__AVR_ATmega88__) || defined (__AVR_ATmega328P__) || (__AVR_ATmega1280__)
+	TIMSK2 &= ~(1<<TOIE2);
+#elif defined (__AVR_ATmega128__)
+	TIMSK &= ~(1<<TOIE2);
+#elif defined (__AVR_ATmega8__)
+	TIMSK &= ~(1<<TOIE2);
+#endif
+}
+
+void MsTimer2::_overflow() {
+	count += 1;
+	
+	if (count >= msecs && !overflowing) {
+		overflowing = 1;
+		count = 0;
+		(*func)();
+		overflowing = 0;
+	}
+}
+
+ISR(TIMER2_OVF_vect) {
+#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega48__) || defined (__AVR_ATmega88__) || defined (__AVR_ATmega328P__) || (__AVR_ATmega1280__)
+	TCNT2 = MsTimer2::tcnt2;
+#elif defined (__AVR_ATmega128__)
+	TCNT2 = MsTimer2::tcnt2;
+#elif defined (__AVR_ATmega8__)
+	TCNT2 = MsTimer2::tcnt2;
+#endif
+	MsTimer2::_overflow();
+}
+
diff --git a/Libraries/MsTimer2/MsTimer2.h b/Libraries/MsTimer2/MsTimer2.h
new file mode 100644
index 0000000..d9809fe
--- /dev/null
+++ b/Libraries/MsTimer2/MsTimer2.h
@@ -0,0 +1,19 @@
+#ifndef MsTimer2_h
+#define MsTimer2_h
+
+#include <avr/interrupt.h>
+
+namespace MsTimer2 {
+	extern unsigned long msecs;
+	extern void (*func)();
+	extern volatile unsigned long count;
+	extern volatile char overflowing;
+	extern volatile unsigned int tcnt2;
+	
+	void set(unsigned long ms, void (*f)());
+	void start();
+	void stop();
+	void _overflow();
+}
+
+#endif
diff --git a/Libraries/MsTimer2/examples/FlashLed/FlashLed.pde b/Libraries/MsTimer2/examples/FlashLed/FlashLed.pde
new file mode 100644
index 0000000..5fda885
--- /dev/null
+++ b/Libraries/MsTimer2/examples/FlashLed/FlashLed.pde
@@ -0,0 +1,21 @@
+#include <MsTimer2.h>
+
+// Switch on LED on pin 13 each second
+
+
+void flash() {
+  static boolean output = HIGH;
+  
+  digitalWrite(13, output);
+  output = !output;
+}
+
+void setup() {
+  pinMode(13, OUTPUT);
+
+  MsTimer2::set(500, flash); // 500ms period
+  MsTimer2::start();
+}
+
+void loop() {
+}
diff --git a/Libraries/TimerOne/TimerOne.cpp b/Libraries/TimerOne/TimerOne.cpp
new file mode 100644
index 0000000..7a52ae0
--- /dev/null
+++ b/Libraries/TimerOne/TimerOne.cpp
@@ -0,0 +1,101 @@
+/*
+ *  Interrupt and PWM utilities for 16 bit Timer1 on ATmega168/328
+ *  Original code by Jesse Tane for http://labs.ideo.com August 2008
+ *  Modified March 2009 by Jrme Despatis and Jesse Tane for ATmega328 support
+ *  Modified June 2009 by Michael Polli and Jesse Tane to fix a bug in setPeriod() which caused the timer to stop
+ *
+ *  This is free software. You can redistribute it and/or modify it under
+ *  the terms of Creative Commons Attribution 3.0 United States License. 
+ *  To view a copy of this license, visit http://creativecommons.org/licenses/by/3.0/us/ 
+ *  or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
+ *
+ */
+
+#include "TimerOne.h"
+
+TimerOne Timer1;              // preinstatiate
+
+ISR(TIMER1_OVF_vect)          // interrupt service routine that wraps a user defined function supplied by attachInterrupt
+{
+  Timer1.isrCallback();
+}
+
+void TimerOne::initialize(long microseconds)
+{
+  TCCR1A = 0;                 // clear control register A 
+  TCCR1B = _BV(WGM13);        // set mode as phase and frequency correct pwm, stop the timer
+  setPeriod(microseconds);
+}
+
+void TimerOne::setPeriod(long microseconds)
+{
+  long cycles = (F_CPU * microseconds) / 2000000;                                // the counter runs backwards after TOP, interrupt is at BOTTOM so divide microseconds by 2
+  if(cycles < RESOLUTION)              clockSelectBits = _BV(CS10);              // no prescale, full xtal
+  else if((cycles >>= 3) < RESOLUTION) clockSelectBits = _BV(CS11);              // prescale by /8
+  else if((cycles >>= 3) < RESOLUTION) clockSelectBits = _BV(CS11) | _BV(CS10);  // prescale by /64
+  else if((cycles >>= 2) < RESOLUTION) clockSelectBits = _BV(CS12);              // prescale by /256
+  else if((cycles >>= 2) < RESOLUTION) clockSelectBits = _BV(CS12) | _BV(CS10);  // prescale by /1024
+  else        cycles = RESOLUTION - 1, clockSelectBits = _BV(CS12) | _BV(CS10);  // request was out of bounds, set as maximum
+  ICR1 = pwmPeriod = cycles;                                                     // ICR1 is TOP in p & f correct pwm mode
+  TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
+  TCCR1B |= clockSelectBits;                                                     // reset clock select register
+}
+
+void TimerOne::setPwmDuty(char pin, int duty)
+{
+  unsigned long dutyCycle = pwmPeriod;
+  dutyCycle *= duty;
+  dutyCycle >>= 10;
+  if(pin == 1 || pin == 9)       OCR1A = dutyCycle;
+  else if(pin == 2 || pin == 10) OCR1B = dutyCycle;
+}
+
+void TimerOne::pwm(char pin, int duty, long microseconds)  // expects duty cycle to be 10 bit (1024)
+{
+  if(microseconds > 0) setPeriod(microseconds);
+  if(pin == 1 || pin == 9) {
+    DDRB |= _BV(PORTB1);                                   // sets data direction register for pwm output pin
+    TCCR1A |= _BV(COM1A1);                                 // activates the output pin
+  }
+  else if(pin == 2 || pin == 10) {
+    DDRB |= _BV(PORTB2);
+    TCCR1A |= _BV(COM1B1);
+  }
+  setPwmDuty(pin, duty);
+  start();
+}
+
+void TimerOne::disablePwm(char pin)
+{
+  if(pin == 1 || pin == 9)       TCCR1A &= ~_BV(COM1A1);   // clear the bit that enables pwm on PB1
+  else if(pin == 2 || pin == 10) TCCR1A &= ~_BV(COM1B1);   // clear the bit that enables pwm on PB2
+}
+
+void TimerOne::attachInterrupt(void (*isr)(), long microseconds)
+{
+  if(microseconds > 0) setPeriod(microseconds);
+  isrCallback = isr;                                       // register the user's callback with the real ISR
+  TIMSK1 = _BV(TOIE1);                                     // sets the timer overflow interrupt enable bit
+  sei();                                                   // ensures that interrupts are globally enabled
+  start();
+}
+
+void TimerOne::detachInterrupt()
+{
+  TIMSK1 &= ~_BV(TOIE1);                                   // clears the timer overflow interrupt enable bit 
+}
+
+void TimerOne::start()
+{
+  TCCR1B |= clockSelectBits;
+}
+
+void TimerOne::stop()
+{
+  TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));          // clears all clock selects bits
+}
+
+void TimerOne::restart()
+{
+  TCNT1 = 0;
+}
diff --git a/Libraries/TimerOne/TimerOne.h b/Libraries/TimerOne/TimerOne.h
new file mode 100644
index 0000000..385b5c6
--- /dev/null
+++ b/Libraries/TimerOne/TimerOne.h
@@ -0,0 +1,41 @@
+/*
+ *  Interrupt and PWM utilities for 16 bit Timer1 on ATmega168/328
+ *  Original code by Jesse Tane for http://labs.ideo.com August 2008
+ *  Modified March 2009 by Jrme Despatis and Jesse Tane for ATmega328 support
+ *  Modified June 2009 by Michael Polli and Jesse Tane to fix a bug in setPeriod() which caused the timer to stop
+ *
+ *  This is free software. You can redistribute it and/or modify it under
+ *  the terms of Creative Commons Attribution 3.0 United States License. 
+ *  To view a copy of this license, visit http://creativecommons.org/licenses/by/3.0/us/ 
+ *  or send a letter to Creative Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
+ *
+ */
+
+#include <avr/io.h>
+#include <avr/interrupt.h>
+
+#define RESOLUTION 65536    // Timer1 is 16 bit
+
+class TimerOne
+{
+  public:
+  
+    // properties
+    unsigned int pwmPeriod;
+    unsigned char clockSelectBits;
+
+    // methods
+    void initialize(long microseconds=1000000);
+    void start();
+    void stop();
+    void restart();
+    void pwm(char pin, int duty, long microseconds=-1);
+    void disablePwm(char pin);
+    void attachInterrupt(void (*isr)(), long microseconds=-1);
+    void detachInterrupt();
+    void setPeriod(long microseconds);
+    void setPwmDuty(char pin, int duty);
+    void (*isrCallback)();
+};
+
+extern TimerOne Timer1;
diff --git a/README.md b/README.md
index aee9db0..e0eea75 100644
--- a/README.md
+++ b/README.md
@@ -1,14 +1,12 @@
-DollyEngine - El Cheapo
-=========================
+DollyEngine
+===========
 
-This is a modification of the DollyEngine firmware for the MX2 Controller (and clones) with simplified UI and support for one motor only.
+This is the latest DollyEngine firmware for the MX2 Controller (and clones).
 
 This version of the firmware is ready for compiling in Arduino 1.0+
 
-All the Pins (including former PWM Pins) can be changed. Currently set up for use with DFRobot Keypad Shield.
+For more information, see http://dynamicperception.com
 
-For more information, see http://dynamicperception.com and http://www.thundercorp.de/timelapse/
-
-Status / Changelog
-=========================
-CURRENTLY NOT RUNNING!! PROBABLY DOESNT EVEN COMPILE!! WORK IN PROGRESS!!
\ No newline at end of file
+MX2 Firmware 0.92
+=================
+EJD:20130329: Fixed bug at line 391 of sketch ds_ui.ino that not allowed to change the value of the calibration constant
